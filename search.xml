<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何有效的扫除迷茫？]]></title>
    <url>%2F2017%2F01%2F03%2F%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E7%9A%84%E6%89%AB%E9%99%A4%E8%BF%B7%E8%8C%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[本文旨在帮助这个行业的年轻人于前进道路上少走弯路。 谁的人生，都有一个慢慢修炼的过程。这个成长的修炼从来都是千转百回。在这样一个浮躁急速的时代，容易迷茫的个体很多，不要怕，不要否定自己，只要随时保持自省和行动才是对未来最好的承担。 你在二十岁到三十岁之间，在生命力最旺盛的时候，要想清楚几件事。 第一件事你要想清楚，这辈子最喜欢的工作是什么，热爱什么东西，这个是最关键的事情； 第二要让自己成为一个专业的人； 第三你愿意用未来的二十年时间去完成这件你喜欢的工作和专业的事情。 全文分四个部分，分别是 内功心法 、 能力修炼 、 养德 和 突破 ，各部分相辅相成，缺一不可。下面就开始介绍内功心法： 内功心法心法一:打破“理都懂”的幻觉 理都懂，然并卵。 很多人都觉得是在讲自己，其实娱乐下是可以的，但是认真你就输了。你真的理都懂吗？那你知道理都懂，然并卵的理吗？ 该幻觉产生的原因无非有两点：第一，你对系统理解不到位，或根本没有系统看待问题的思想，非懂的你产生了似懂幻觉；第二，你无法坚持执行有效的解决方案，造成了然并卵的结果。该幻觉对个人成长不利，打破它，是改变的第一步。 心法二:停止迷信权威年轻人成长过程中总会遇到一些 “权威人士” 。他们会告诉你错误知识，总结错误道理，营造错误激励，带来严重的负面影响。 在我小的时候就有一些权威神色严肃的讲神户岛是日本四大岛之一、人不及时大便，大便会被身体反复吸收等等他们想当然的知识点或道理；长大后准备就业时又有一些过来人拿切身经历向我们讲述国企有多好私企有多苦；工作后也常遇到领导对质疑提问者挖苦讽刺，对附和者和颜悦色等等。可想而知，这些权威人士对我们的成长造成了多少负面影响。但是，如果你很早就意识到权威人士不一定是对的，你和他们之间也只是合作关系，各取所需，负面影响就会被大大削弱。 即使是良师，也难免犯错。所以，停止迷信权威吧，越早越好。 心法三:养成同侪（chai）压抗同龄人和朋友之间的影响力叫同侪压力，对同侪压力的抗性就叫同侪压抗。我们都常被同侪压力所操纵，毫无防守之力。我们毫不犹豫去做房奴，去考公务员，去读研，被传销，去参加义和团等等，在同侪压力下，这些都是天经地义正确的事情。我们或被永远蒙在鼓里，或直到泡沫幻灭才发现开始埋怨社会无情，骗子无义。同侪压力是你阻止你理智决策的重要敌人，你需要不断的去培养同侪压抗。 总结一下，就是你知道的不一定是对的，权威人士说的不一定是对的，大家都在做的不一定是对的。（温馨提示：不一定是对的不代表一定是错的，小心矫枉过正） 能力修炼有了这三点内功心法，就可以开始正儿八经的能力修炼了。修炼从以下几个方面入手： • 增加见识很多人由于自我设限而没有勇气改变自己：我这胖子不可能瘦下来，我不是当领导的料，我太丑追不上漂亮女孩，我双鱼座就是不能控制情绪等等。自我设限会让你永远不去尝试改变，而如果有一个人用他的亲身经历打破了你的这种认识，对你来说会是极大的鼓舞。大郅进NBA，激励了姚明当NBA状元；王祖蓝娶一米七老婆，也同样能激励你去俘获比你高的女神。 因此，从成长角度来说，你的一切行为选择，都要考虑它能不能增加你的见识，从而增大遇到能打破你自我设限的牛人的几率。在此原则下，你选大学的标准自然就转变成了：城市优先于学校，学校优先于专业；你读到大二后就开始焦虑：再不辍学，你就要毕业了；之后的每一年你都会选择一个此阶段能踏上的最好的平台（包括原平台）。此时，你眼中的习以为常，成了外人眼中疯狂地成长。 • 持续磨练技能定个大致计划，从现在开始几个月内重点磨练某一项技能，不论是专业技能还是辅助技能。如果是专业程度较高的技能，你需要识别自己所欠缺的重要系统知识点（后文会介绍方法），然后将其逐个攻破。比如，要修炼计算机视觉，你需要解决的重要系统知识点有 线性代数 、 编程能力 、 opencv 第三方库使用方法等，将其逐个攻破之后，再想提升就主要靠经验积累了，这时候就可以定制下一个技能的修炼计划了。 识别自己欠缺知识点的方法：1、 知乎 上面搜一圈，看看过来人对该技能需要知识点的总结归纳；2、登录 琅琅比价网 ，搜目标技能的关键字，排名靠前的书一般都有不错的归纳。有钱一定要买正版，没钱去新浪微盘下载电子书，记得感恩作者；3、 网易公开课 、 可汗学院 ，不仅能帮你识别，还能找世界最优秀的老师帮你恶补，强烈推荐。 • 培养判断力上文提到了一些词： 系统思考 、 最好平台 、 系统知识点 、 同侪压抗养成 等，这些都需要个人的判断力。判断力的提升是不能一蹴而就的，需要持续培养。 第一步，读完下面这些书：《优势谈判》《难度对话》《沟通的艺术》《关键对话》《批判性思维》《谈判力》《心理学与生活》《学会提问》《从0到1》《基业长青》《创业维艰》《2小时品牌素养》《品牌洗脑》《迷恋》《第五项修炼》《失控》《时间简史》《经济学基础》（曼昆）《浪潮之巅》《从黎明到衰落》《艺术的故事》《全球通史》《人类简史》《奇点降临》《哲学家们都干了些什么》《西方哲学史》《金融的逻辑》《还原真实的美联储》 第二步：这些读得差不多后，你自然就知道适用于你的第二步怎么走了。养德正是由于技术变革和社会变革之间所产生的时间滞差，才造成了几千年来世界历史上众多的苦难和暴行——全球通史。 人在前进的过程中，对力量控制的能力很容易跟不上自己的飞速成长的力量。当你开始系统地学习知识，学得越多，就越发现周围的人大多在说着不靠谱的道理，做着愚蠢的行为。你会很轻易的去跟他们争辩，好为人师，对他们鄙视，沦为喷子。这样做不但浪费了你大量的时间，还会加速破坏你的人际关系。结果就是：你懂得越多，死得越快。 因此，学习和成长的过程中，不要忘记对自身修养品德的提高。要有别人说错而不指出的涵养，只跟有系统思想的人争辩讨论，并注意方式，最好做到既不争锋相对也不冷漠回避。 另外我想从经济的角度谈谈秀技的收益。秀技的边际收益最高的时限大约在18-24岁（艺术类除外）。过了这个阶段，就要朝着能做事，能带队伍，能整合资源的方向去发展了。目前在很多电视节目都能看到，仅把一项技能做到极致的人，结果大多是去找综合能力强的人来投资他。所以，有天赋的年轻人应该在18到24岁之间，通过秀技去获取更多的资源或者修炼其他能力的机会。过了这个阶段，秀技可能就没那么有效了，抱大腿会更好使一点。 突破上面说了一堆，对你来说很有可能全是废话，因为对人的毅力有不低的要求。但是有一招，能让其变废为宝，那就是集中你全身所有的意志力，养成第一个以前没有的好习惯。可以是健身、跑步、读书、早起、写日记等等。 习惯的养成，也要从简到繁。比如健身，大都是分组练，每组8到10个俯卧撑之类。尽量备齐能氛围的道具，如镜子、瑜伽垫、小伙伴等等。习惯养成的途中也要持续关注该习惯正确的打开方式，系统的学习与之相关的理论知识。 相信没多久，你就可以发现自己的一些变化，胸肌变大了，体力变好了，说话有料了等等，这样你会更自信的去修炼其他的项目，上文说的那些修炼也就有了被执行的可能。 你在开始学开车时，需要很多有意识的注意力，特别是如果你学开的是手动挡的车。那时，你实际上觉得很难和坐在旁边的人说话。假如旁边的人让你“减速、换低挡、下一个路口右转弯”，你可能当时就放弃了。然而，几个月以后，你不需要，或很少用有意识的注意力，就能完成这些任务，它们都成了可以被“自动”完成的任务。令人惊异的是，你很快就能在交通繁忙的路上，边开车边跟旁边的人说话，而几乎不需要有意识地注意那些需要留心应对的变量，哪怕它们实际上多达数百个——《第五项修炼》 结束语此刻，你内心的深渊是否依然雾气茫茫？可是你愿意为你的当下付出多少的行动成本？最重要的是你有没有愿意沉浸下来的心念，给自己一段完全属于自己的寂寞时光，心平气和地有所学有所为。你接纳迷茫的态度和你努力行动的力度，却最终会让你这一路走来，重新瞥见光影。]]></content>
      <tags>
        <tag>生活</tag>
        <tag>读书</tag>
        <tag>思考</tag>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小白的自学养成记]]></title>
    <url>%2F2016%2F09%2F30%2F%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%99%BD%E7%9A%84%E5%85%BB%E6%88%90%E8%AE%B0%EF%BC%88%E8%87%AA%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言随着今年9月 微信小程序 的推出，前端开发工程师一跃成为市场上供不应求的香饽饽。为什么很多公司开到 20K+ 的月薪都招不到一个优秀的前端工程师？这个问题不在本文的讨论范围内，想知道的同学可以转到 100offer 这篇文章 为什么整个互联网行业都缺前端工程师？ 很多同学，包括以前做机械的、UI的、Java的、或者对于IT完全零基础的同学都想自学前端。下图是我整理的一份Web前端的技能树，很多初学者表示看到这些密密麻麻的知识点就已经晕了。确实，前端是一门涵盖面很广的学科。但是想学好前端找到一份好工作的你也不用慌张，内容虽多但有迹可循，只要循序渐进就不怕学不好前端！ 什么是前端 前端是对于网站或者网络应用来说的，前端是相对 后端 来说的。前端对于网站来说，通常是指，网站的前台部分包括网站的表现层和结构层。后端对于网站来说，通常是指网站的后台部分包括网站的业务逻辑层、数据持久层、负载均衡等。现在还出来个新名词叫全栈，就是前后端的大多数技能都掌握，不过真能达到那是牛人值得仰望。因此前端技术一般分为 前端设计 和 前端开发 ，前端设计一般可以理解为网站的视觉设计，前端开发则是网站的前台代码实现，包括基本的 HTML 和 CSS 以及 JavaScript/ajax ，现在最新的高级版本HTML5、CSS3，以及 SVG 等。 正文1、明确你的意愿其实不管是前端还是 后端 ，首先要清楚，自己是想从事 业务 型的技术工作，还是 Research 型的技术工作。前者可以理解为：互联网公司的程序员。业务型的前端工程师，最大的一个特点是：从客户需求出发，去真真正正地做出一个产品来，交付客户，让客户满意，并对客户产生实际的价值，这也是大部分互联网技术从业人员的工作内容。业务型的技术人员使用的技术往往不是最新的前沿技术，而是经过验证的效益更高的技术，用最小化的成本来服务客户。这需要不停地实践与实战，以便更快、更高效地实现客户需求的满足。后者可以理解为：行业的科学家。这种角色时常走在行业的前面，去带领互联网公司，甚至是技术行业，探索更先进的技术、挖掘更有价值的数据、构建服务大众的基础设施平台等……目前，绝大部分互联网技术人员都从事着业务型的技术工作，少部分极其优秀的技术人员可以从事 Research 型的技术工作。文章一开始就强调要了解清楚自己想从事的是哪个类型的技术工作，目的是树立一个终极目标。而要从事 Research 型的技术工作，首先必定是需要多年的业务型技术工作的经验积累的。 2、补充一个题外话很多没有接触过编程的人都以为编程很难，要具备很高的数学能力，是因为他们往往都把“编程”这个活动理解为从事 Research 型的技术工作了。这是他们的一大误区。其实大部分的编程活动，都是对“业务逻辑”的理解，然后用代码拼凑出产品和服务，这里面涉及到多深的数学知识？我看不多……编程的总体思路就像是写书。写书前，你已经识字了，这是你的基础，你还会运用积累下来的一些表达技巧，让你的书更加吸引人，实现更高的销量。写书前，你已经知道了很多前人规划好的、约定俗成的东西了，而你要做的是，利用这些约定俗成的东西，去写一本自己的书。这本书可以参考前人的书，也可以参考已有的论文。编程，往往是一个创造过程，而不是一个发明过程。 3、前端自学路径指南前端作为一个新兴工种和职业，它一直未能有幸像 Java、C 等后端语言一样，进入高校，成为一门课程。这就导致几乎所有的前端工程师，要么是从后端工程师转型而来，要么从设计师转行而来，都靠自学成才。而我也发现，校内极少人从事前端开发，大部分人都走后端和客户端路线。而前端从诞生至今，一直未能跳脱 HTML、CSS、JavaScript 这三门“语言”。自然地，入门指南当然围绕三者讲起： HTML、HTML5记住至少 90% 的 HTML 标签及其语义，重点是header、footer、article、main、section、nav、aside 这种语义特别明显的用于布局的标签。 CSS、CSS3记住至少 90% 的 CSS 属性与写法，重点是盒模型（margin、padding、border、box-sizing）、页面布局相关（position 的用法、淘宝的双飞翼布局）、页面渲染相关（背景、阴影、字体样式等）……以上是编写静态页面的基础，重点是多实践。 BootstrapCSS 框架 Bootstrap 应该是大部分前端工程师绕不过的一个点。它流行到以至于现在有些前端开发人员都刻意避免使用 Bootstrap 来防止页面撞脸了。即使如此，还是阻挡不了大部分前端开发人员使用它的热情。毕竟它能帮助我们快速实现页面响应式布局、快速编写出可交互的页面。我的建议：觉得 HTML、CSS 基础了解得差不多了，我主张先学习 Bootstrap，重点是学会 Bootstrap 的栅格系统及其原理，了解响应式网页设计是如何实现的，能够用 Bootstrap 拼出一套管理后台界面。Bootstrap 的进阶用法就是：自行定制 Bootstrap。虽然已有 Bootswatch 这样的第三方 Bootstrap 主题能满足大部分一般需求，但总有些时候需要自定义样式。而在使用 Bootstrap 的过程中，修改 Bootstrap 默认主题的最佳方式不是覆盖默认设置，而是自定义主题后构建出自己的 Bootstrap 主题。关于定制 Bootstrap 主题，官网上有一个现成的网页。而如果要在自己的电脑定制，需要掌握 LESS 或者 Sass（两者都是 CSS 编译器，为编写 CSS 引入了编程语言的变量、复用等特性）。 JavaScript我个人是从机械工程师跨行自学的前端，所以偏重代码的实现、对设计稿的还原程度、更好的页面语义和页面布局、SEO 等，对 JavaScript 的了解并不深。这样的角色，在腾讯的岗位叫 UI 开发或网页重构。小公司的话，不分前端工程师、网页重构工程师、UI 开发工程师。所以遇到以编写 JavaScript 为己任的前端开发工程师，我的 OS 是这样的：没想到你是这种前端工程师。哈哈，开个玩笑。回到正题上来：由于上面提到的缘由，对于 JavaScript，我主张是边用边学。当然首先是要已经看过 W3School 的 JavaScript 文字教程，了解 JavaScript 在浏览器中的能力（操作 DOM、BOM，知道 AJAX 是什么），并知道它拥有什么样的 API，什么效果能实现，什么效果不能实现。当 JavaScript 用于编写程序逻辑时，要知道需要用到什么语法、内置方法、内置 API。再后来，是了解 HTML5 中WebSQL、Web Storage（Local Storage 和 Session Storage）、应用缓存（Application Cache）、Cookie 是怎么回事，能实现什么功能。以上算是接触并使用 JavaScript，还没进入大量实战阶段。 jQuery 与 Zepto.js我的主张是，JavaScript 一开始并不需要学得太深。对于业务型的前端工程师，完成上面提到的 JavaScript 部分，基本就够用了。而基本上，一定要做的一件事是：学习 jQuery、Zepto.js（人称移动端的 jQuery）。两者的实现极其相像，可以只学 jQuery，Zepto 基本就无师自通了。jQuery 和 Zepto.js 之于 JavaScript，就像 Bootstrap 之于 HTML 和 CSS。都是为了简化代码、更高效地完成业务而开发的 JavaScript 类库。它们封装了很多原生 JavaScript 的语法和方法，使之编写代码时更方便，同时保证对旧版浏览器的兼容性。对于两者，建议：了解如何使用 jQuery 操作 DOM 常用的数据处理方法（数组项如何增删查改、对象如何访问及选取、方法如何调用、JSON 数据如何处理及使用）。 4、所谓中级前端工程师所谓中级前端工程师的范畴：学会使用前端工具。工具包括但不限于： Sublime Text、Atom 等代码编辑器（认真记住各种快捷键，好好阅读各大编辑器的插件使用说明）。 方便前端开发的利器：浏览器自动刷新 Browser-sync、调试工具 Chrome 控制台、Fiddler 和 Weinre、模拟请求 Postman、图片压缩 iSparta…… Node.js 平台下的 NPM（一个集合了几乎所有优秀前端开源项目的社区，用来管理项目中用到的开源技术、资源、插件等）。 CSS 预处理器与后处理器：Autoprefixer、PostCSS（一个庞大的社区，提供各种 CSS 处理能力的插件）。由于各大浏览器对标准CSS的支持情况不一样，都或多或少地拥有带自身特殊前缀的私有 CSS 属性，例如 -webkit-border-radius 这个私有 CSS 属性是 Webkit 内核的浏览器所支持的写法。 以前没有 CSS 预处理器与后处理器时，往往需要前端开发人员手写带有各种特殊前缀的私有 CSS 属性。有了这些处理器之后，只需要写标准的 CSS，如 border-radius，再用这些处理器处理一下 CSS，就能自动补齐浏览器私有 CSS 属性，实现前端页面的最大化兼容性，例如兼容 IE9、IE8 等等……当然，这个栗子只是众多CSS预处理器与后处理器最简单的一个应用而已，还有更多高阶属性与使用技巧。 JavaScript 编译器之所以 JavaScript 有编译器，是因为自从 2015 年，JavaScript 的标准制定组织 ECMAScript 委员会决定今后每年都推出新版的 ECMAScript 标准，也就是新版的 JavaScript。而又因为各大浏览器的开发进度不同，对新标准的实现还没完全跟进，而一些喜欢追新的前端开发人员又想早早地开始使用新版的 JavaScript，所以就出现了 Babel 这样的 JavaScript 编译器。Babel 的主要功能是将新版 JavaScript 编译成旧版JavaScript，使得前端工程师既可以编写最新版的JavaScript，而前端页面也可以完美兼容各大浏览器。 前端开发构建工具Gulp前两年还流行 Grunt，这两年流行 Gulp，所以直接学习并使用 Gulp吧。Gulp 的最大一个用处是：打通开发过程中的工作流程。例如开发过程中，自动刷新浏览器、将 SCSS 编译成 CSS、将新版 JavaScript 编译成各大浏览器支持的旧版 JavaScript、项目开发完毕后的性能优化：压缩图片、CSS、JavaScript 等静态资源、合并雪碧图，把项目源码上传服务器等。其实每个小操作都有工具能完成，而像 Gulp 这样的构建工具的作用是：将所有分散的小操作和小流程，通过 Gulp 平台上的插件，集合成一条龙服务，一次编写前端 Workflow，就可以免去很多分散精力的小操作，实现开发流程自动化。上面提到的 CSS 处理器、JavaScript 编译器，都有 Gulp 插件，例如 gulp-autoprefixer、gulp-cssnano、gulp-image…… JavaScript 前端框架Vue.js、Angular.js、React、React Native……JavaScript 前端框架的主要作用是，让前端工程师也能像后端工程师一样，以一个已经验证有效的开发范式来支撑项目，降低耦合度，提高项目可靠性和可维护性。 5、一点补充由于前端刚从刀耕火种的时代，步入前端工程化的初级阶段，此时会出现大量的工具，例如 Grunt 还没开始用，Gulp 就来了，Gulp 还没领略其精粹，Webpack 又款款而至。迷恋工具，每每追新，必然不是前端工程师的修养。对于工具，我们强调使用场景。在什么情况下，需要使用什么工具，帮助提高效率，才应该是前端工程师所要关注的重点。 6、所谓高级前端工程师所谓高级前端工程师的范畴：深入 JavaScript 底层、深入浏览器底层。包括但不限于（由于本人远不及这个层次，下面的罗列可能不正确）： 玩转 SVG 绘图、Canvas 绘图 页面性能调优 玩转 Web Socket、Web Worker 自行开发 JavaScript 插件、工具、框架等 玩转 Chrome V8 引擎 共同进步如有错误，欢迎在下方留言区指正。]]></content>
      <tags>
        <tag>前端学习</tag>
        <tag>html5</tag>
        <tag>CSS3</tag>
        <tag>Bootstrap</tag>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
        <tag>Node.js</tag>
        <tag>Zepto.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白如何选择自己的第一门编程语言]]></title>
    <url>%2F2016%2F05%2F01%2F%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言：大多数人的编程之旅都是从搜索引擎开始的。例如搜索“XX语言入门教程”。但要怎么决定从哪门语言开始呢？或者当我们不知所措的时候，只能搜：”入门学什么编程语言比较好？”初学者顾虑的问题通常就那么几个，下面这张图很好地回答了这些疑惑： 选择第一门编程语言的过程十分有趣，这就好像是个人的信仰选择问题一样。也许因为你像个孩子一样喜欢玩橡皮泥，稀里糊涂都打算开始学 Ruby 。我还是要提醒你，不要草率做决定。想要真正掌握你的第一门编程语言，你需要投入成千上百小时来学习实践。所以你要考虑清楚以下这几个方面： 这门语言的岗位需求大不大； 这门语言有没有发展前景； 语言的学习难度； 在学习过程中你能运用它开发什么样的练手项目（把你的成果分享给周围的朋友才能激励你坚持学习下去）。 主流编程语言的热度每年都会有新的编程语言出现，以及随着而来的学术论文亦或者是搞笑段子：第一门编程语言可选择的范围很广。下面这张图很清晰地显示了过去12年几门语言学习的Google搜索热度变化： Java 有起有落，而 Python 逐渐成为了最受欢迎的入门语言。除此之外，还有最近几年逐步火起来的JavaScript。（新手请注意，Java和JavaScript之间的区别就像是周杰和周杰伦之间的区别。）在我展开讨论之前，先明确几点： 我并不会在这里争论哪门语言要比哪门优越； 我认同一名合格的程序员最终应该掌握不止一门编程语言； 我想说明的是，对于刚入门的初学者来说，还是应该先专注于一门语言的学习。而这门语言，我想你可能早就在文章标签中发现了 —— 就是JavaScript。 高校的编程教学现状我们先来聊聊现在学校里的编程教学是什么情况。 计算机基础教学一般在大学教授编程课程的都是计算机系，而计算机专业一般数学和电子方面的内容又比较多。当然你可能早就听说过： 计算机科学的教育无法使任何人成为专业的程序员，就好像学习怎么使用刷子和颜料无法让任何人成为画家一样 —— Eric S.Raymond（《大教堂与集市》作者） 即使在2016年的今天，许多大学还像教计算机科学一样教编程，像教数学一样教计算机编程。所以许多课程中编排的入门语言是 C 这样底层抽象的语言，或者是专门针对数学的 MATLAB 。一些专业权威的机构也推出了他们的编程语言年度排行榜，例如TIOBE Index，又或者是下面这个来自IEEE的榜单： 大多数这类榜单10年来都没有什么变化。但事实上不是这样的，包括在学术界。早在2014年，Python就超过了Java，成为了最受美国各大 CS (Computer Science)机构欢迎的教学语言。 而在实际上的生产工作中，也发生了和权威机构发布的完全不一样的变化（数据来自49,397开发者参与的 StackOverflow 2016年度调查）： 多一半的开发者都在使用JavaScript。它最早只在前端开发应用，现在也逐步在后端流行开来。甚至开始延伸到游戏开发和物联网领域。工作岗位上对JavaScript的需求也仅次于Java（数据来自Indeed.com）： 所以我推荐初学者将JavaScript作为自己的第一门语言。我再推荐一个免费的JavaScript开源社区FreeCodeCamp，这个社区已经帮助 5k+ 名JavaScript初学者找到了工作。 JavaScript 的市场分析不过，JavaScript是否适合你？它是否值得你为之献出第一次？我们来继续分析： 事实一：岗位需求如果你只是为了好奇好玩而学编程的话，可以忽略这一点。但如果你和大多数人一样，想通过掌握编程技能找到工作的话，这点对你就非常重要了。像我之前提到的，JavaScript是除Java之外需求量最大的编程语言。另外还有一点：JavaScript已经发展了20多年，而直到最近，一些诸如 Netflix , Walmart 和 PayPal 一类的大公司才开始全栈应用JS构建他们的应用。所以就造成了市场上JavaScript开发者供不应求的状况（数据来自Indeed.com）。 从图上来看，每个Java岗位大概有2.7人在竞争， IOS 和 PHP 也平均都有2人以上竞争。而通过计算，每个JavaScript岗位只有0.7，这就成了属于JavaScript开发者的卖家市场。为了更具说服力，特此补充国内的编程语言岗位情况（数据来源2015年8月 中国版的编程语言排行榜）： 事实二：发展前景在 Github 上，平均每个JavaScript的项目收到的 pull requests 要比其他语言多两倍以上。其增长速度也远超别的流行语言。 JavaScript的整个生态体系也因为 Google , Microsoft , Facebook , Netflix 这类大公司的投资而受益匪浅。例如 TypeScript （一种JavaScript的超集，提供更丰富特性，可编译为普通JavaScript）有着超过100名开源贡献者，而这里面大多数都是微软和谷歌的员工。而且这类集团公司很少有使用Java的。因为Java的所有者 Oracle 经常会因为各种有关Java开发的原因起诉别的公司。 事实三：学习难度 大多数的程序员应该都会认同，高级的脚本语言通常比较好学。JavaScript当然属于此类，也包括Ruby和Python。即便很多大学课程教授的都是Java或 C++ ，这类语言也真的很难上手。 事实四：你能实践的练手项目这是JavaScript最大的优势。JavaScript可以运行在任何有浏览器的设备上。你几乎可以用JS开发任何应用，而且很方便就能分享发布到任何地方。正是由于JavaScript无处不在，StackOverflow的联合创始人 Jeff Atwood 才说出他的那句经典定律： 任何可以用JavaScript写成的应用，最终都会使用JavaScript写成。 现实也在不断的佐证，证据在此。Java也曾号称是跨平台语言。可也许你了解到，Oracle官方在今年早些时候终止了Java Applets的支持。 Python也经常会遇到类似的问题： 我怎么才能把我写的这个游戏发给我的朋友？或者能够不安装什么应用就在手机上运行么？ - James Hague in Retiring Python as a TeachingLanguage 相比之下，JavaScript要方便很多。下面的这些应用来自JavaScript开发者的开源项目，你只需要在浏览器里打开链接就能开始玩啦： 1970s style Simon gameConway’s Game of LifeStar Wars-themed Wikipedia SearchA roguelike dungeon crawler game先专注学好一门语言，再去学别的。如果你总是在各个语言之间摇摆不定，你很难取得什么实质上的进步。为了避免在入门阶段止步不前，你需要扎实学好你的第一门语言。之后再学习别的语言你就会感觉到异常轻松。等到那个阶段，你就可以逐步成长为一名掌握许多语言的全面的开发者啦： C 对于你理解计算机原理特别有帮助，例如内存管理之类的。在高性能计算中非常有用； C++ 在游戏开发中运用广泛； Python 在科学研究和数据分析中应用广泛； 如果你想在大型的科技公司中工作，Java就非常重要。 小白的顾虑：Q1：JavaScript运行速度不是很慢么？ 在很多实际运用场景中，JavaScript和一些高性能语言运行一样快。 Node.js 要比Python, Ruby, PHP 快上好几个数量级。甚至已经接近了C++, Java, Go 的性能。下面是一个比较全面的编程语言“跑分评测”： Q2：JavaScript连静态语言都不是！ 和Python/Ruby一样，JavaScript属于动态语言，使用起来也很方便。举个例子，假如我想把变量 exampleArray 设为数组，我会先给它赋值，然后通 length 函数来获取数组中元素的数量。 1234exampleArray = [1, 2]-&gt; [1, 2]exampleArray.length-&gt; 2 但假如我不小心赋值给了它一个字符串，代码照样运行不会报错，可并不是我想要的结果： 1234exampleArray = "text"-&gt; "text"exampleArray.length-&gt; 4 这一类错误在动态类型的语言中经常会遇到。大多数的开发者都会专门写一些检查和测试来避免此类错误的发生。如果你非要学一门静态语言的话，我依旧推荐你学习JavaScript，之后再开始学习TypeScript。 TypeScript是有学习曲线的，但在掌握了JavaScript之后，你的学习会很顺利。— Alex Ewerlöf on TypeScript Q3：我想要学的是怎么开发移动 App 那你也还应该先学JavaScript呀~ JavaScript有一些很棒的工具可以开发原生的移动应用，例如Angular Cordova和React Native。 为了让你的移动App真的像模像样，它至少得有个后端，你用一些合适的Web开发框架可以很轻松地实现，例如 Node.js + Express.js 。 而且移动开发的春天也正是 JavaScript 的流行带来的。在StackOverflow的调查中，有近一半的开发者的岗位都是Web开发，移动开发岗只占了8%。 “为某事专门下一个App”的境况也已不再，大多数的智能手机用户开始趋于不下载新的App了。 当然，人们还在用着App。绝大多数都是大厂的 微信 、 支付宝 一类（原文：Mostly Facebook, Google Maps, and handful of others）。市场对移动开发的需求也越来越小。 移动开发的前景也难以预期。而且在许多方面，使用JavaScript来开发维护和部署移动应用要更加轻松简单。所以像 Facebook 和 Google 这样的公司在研发更好的JavaScript工具上投入的越来越多。 在2016年，几乎所有的开发都和Web开发有关。所有的事情都依附着互联网这个大平台。而且下一波将要崛起的设备 —— 智能家居 、 自动驾驶 汽车等也都需要依附于网络。 Q4：JavaScript不是一个只花10天写着玩的语言么？ JavaScript有一段简史。程序员们也经常会拿JavaScript开各种各样的玩笑。同样人们也喜欢吐槽C++，可不管有多少人吐槽，C++依然很成功。这就和PHP是全世界最好的语言是一个道理。 所以如果再有人在你面前说JavaScript怎么怎么不好的话，请记住C++之父的那句名言： 世界上只有两种编程语言：一种是天天被人喷的，另一种是没人用的。— Bjarne Stroustrup JavaScript 学习：学习方法 在2016年如何学习JavaScript？ 6周学习计划，攻克JavaScript难关(React/Redux/ES6 etc.) 成功案例 科班狗的前端之路 非计算机专业出身的我是如何在两年内成长为前端工程师 平面模特的转行之路(IOS开发) 完整的 Web 开发学习 Come on Baby！你也可以成为Web开发工程师！——Web开发工程师完全成长指南 如何在一年之内通过自学找到Web开发工作 前端学习路径 2016/2017 Web 开发者路线图 FreeCodeCamp 前端学习社区 FreeCodeCamp学习资料 原文链接：What programming language should you learn first?作者：Quincy Larson (FreeCodeCamp 创始人)]]></content>
      <tags>
        <tag>Android</tag>
        <tag>JavaScript</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>ruby</tag>
        <tag>C</tag>
        <tag>Golang</tag>
        <tag>Haskell</tag>
        <tag>PHP</tag>
        <tag>Swift</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程小白的Android自学之路]]></title>
    <url>%2F2016%2F04%2F02%2F%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%99%BD%E7%9A%84Android%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[前期准备自学是一项很苦逼的差事，自学的人很多，但能真正坚持下去的很少，在准备自学 Android 之前你需要具备以下基本能力能帮助你坚持到最后。 对Android开发、对互联网感兴趣，兴趣是最好的老师，只有发自内心的感兴趣才能真正坚持下去； 强大的学习能力，既然自学那学习能力肯定是必备，要有很强的求知欲，持续不断的学习能力才有机会走的更远，注意，是持续不断的学习能力； 解决问题的能力，自学过程中肯定会遇到各种各样的坑，这个时候不要急躁，不要气馁，不要怕耗时间，一步一个脚印去解决问题，这会为你今后走上工作岗位带来极大的优势； 设定一个目标，比如我是从机械转行编程，自学Android的目标简单直接，因为搞编程比搞机械工资高，我转行就是为了多挣钱。我想大部分人的目标应该都跟我同感。 Android开发要学的技能非常多，技术更新速度还快，但是总的来说：掌握最核心的技术，最规范的开发流程，成为专业、出色的安卓开发工程师也不是遥不可及。为了解决大家的疑问，我专门整理了一张思维导图，用来梳理合格的安卓开发工程师应该具备的开发知识体系。 Java基础Android开发是基于 Java 语言的，所以毫无疑问的是必须要掌握Java基础，如果你完全没有任何Java基础，这步是必须要好好学习的，如果已经有Java基础的，这步可略过。 对于很多初学者来说入门往往是最难的，如果只看书完全看不下去，也很难理解，所以强烈推荐初学者以书籍结合视频的方式学习Java基础，所以给你推荐：《Java语言程序设计》，优点是非常基础，适合初学者，建议只要看到前十四章就ok了，第十二章也可以略过。 Mars老师 的Java4Android视频课程结合学习，便于初学者很好的理解与入门。如果每天至少坚持学习3-4小时的话，这一阶段差不多花费1～2个月之间都算正常，范围因人以及花费的时间而异。 Android入门资料经过上面的学习相信你已经掌握了Java基础了，是时候开始正式进入Android学习的阶段了。 Android学习之路《第一行代码》郭霖大神的最新力作，全书由浅入深、系统全面地讲解了Android软件开发的方方面面，而且是针对Android 7.0进行讲解的，非常适合Android入门。Mars老师的Android开发视频教程极客学院Android开发视频教程慕课网的Android开发视频教程至于入门书籍我认为推荐一本适合你的就够了，而且大部分书籍内容大同小异，但是视频教程就不一定讲解的内容都一样了，同学们可自行选择视频教程。 Android开发工具科学上网科学上网可以说是程序员必备技能，身为Android开发者那更得会这项技能，不管你是使用 Google 也好，还是到Android官网查找资料，下载SDK都必须要翻墙。可以使用goagent也好，修改host，购买vps、 vpn 等等方式，这个技能不是本文重点，大家可自行搜索去配置。可以告诉大家的是对于新手来说最简单有效的方式是购买VPN，可以节省不少精力，至于哪个vpn比较好用不敢保证，我使用了两年的vpn NTFITS 个人感觉相对较稳定，感兴趣的同学可自行下载。 Android Studio虽然目前的很多学习资料与书籍都是 Android Studio 为主，这是一款Google官方推出的Android开发环境，所以强烈建议大家使用Android Studio进行Android开发，学习的初期花点时间熟悉使用，上手很快。想了解更多有关Android Studio的技巧可以访问 Android Studio的中文社区 。 AndroidDevTools我是强烈建议Android开发者一定要学会科学上网的，但是如果你觉得暂时还不需要接触外面的世界，那我就向你推荐一个国内的镜像网站，可以让你们无须翻墙即可下载使用官方SDK。 模拟器 Genymotion首先建议大家能不用模拟器都不要用，模拟器的启动速度简直是龟速，现在市面上安卓手机很便宜，打算做Android开发没个安卓手机真是说不过去。如果你非要用模拟器那就推荐你用 Genymotion，目前来说最快的模拟器。 Google问任何问题之前都要先去搜索引擎查一下，这会训练你的解决问题的能力，而等你以后工作，实际开发中可以知道，有一大半的时间你是在搜索度过的，很多问题都已经是前人遇到并总结的方案。对于新手来说可能百度勉强够用，但是建议一开始就养成使用Google的习惯，百度在娱乐八卦方面确实靠谱，但是技术方面查出来的东西基本千篇一律，有些答案甚至还会起到误导作用，所以一定要用Google！一定要用Google！一定要用Google！！！（重要的事说三遍） StackOverFlow用Google之后搜索出来的东西还是习惯性的点击中文结果，直到有一天我发现基本每次搜索排名第一的都是这个网站，于是尝试着点进去用我蹩脚的英语阅读，之后真是相见恨晚的感觉啊，上面几乎能搜到你遇到的绝大部分问题，某种程度上来说推荐用Google搜索的原因之一是因为排名靠前的答案基本都在 StackOverFlow 上。 GitHub现在是全球最知名的程序员开源社区，程序员几乎人手一个 GitHub 账号，在上面你可以找到各种各样牛人分享的开源项目，包括Google、Facebook、Twitter等开源的代码，简直是号称进阶必备，某种意义上看大牛的代码是最好的学习进阶方式。 Android开发资源了解这些资源你绝对会接触另一个世界，这些资源大部分都是我圈中好友总结分享的项目，绝对干货！Google Android官方教程中文版Android 开发最佳实践一些优秀Android开发者总结留下来的经验，了解这些能让你的学习之路事半功倍。Android开源汇总GitHub上总结的最全的Android各大开源项目，让你大开眼界！Android Weekly了解最新的Android相关的技术有哪些，时刻了解紧跟技术趋势，建议加入邮箱订阅。Android开发技术周报国内版的Android Weekly，更符合国情。Android源码解析一个专注于开源项目源码解析及优秀开源项目的分享的网站。stormzhang该博主可以算作是 Android自学界 的鼻祖了，他自学Android的故事与分享的知识、经验影响了无数人，当然也包括我。 国内优秀的Android开发者的博客这里筛选一些有质量的博客给大家，大都是你们的前辈，绝对一线的博客。stormzhang的博客郭霖的博客Trinea的博客魏祝林的博客恺风（Wei）之Android专栏张鸿洋的博客张兴业的博客更多国内优秀开发者的博客国外著名优秀开发者博客 国内外优秀的Andorid团队博客Android Developers Blog （Android开发者官方博客，须翻墙）美团点评技术团队腾讯全端 AlloyTeam 团队 Blog Android进阶书籍当你Android开发已经上手之后，突然发现一直进步很慢，处于一个瓶颈了，这个时候你需要这些书籍。《Java编程思想》Java经典书籍，有中文版的，可能为了学习Android，你只掌握了Java基础，但是远远不够，你需要再重新系统的学习一下Java，这是一本值得反复看的书籍，针对有一定Java基础的人，会让你重新认识下Java。《Effective Java》这是一本实用至上的书，78条建议，满满的干货。每一条都说明了为什么最好这样，Java进阶必备，目前为止看过这本书评价最好的一本。《App研发录》从App架构的角度，重点总结了Android应用开发中常见的实用技巧和疑难问题解决方法，为打造高质量App提供有价值的实践指导，避免你在实际项目中踩坑，读完绝对有收获。Android开发艺术探索这是一本Android进阶类书籍，采用理论、源码和实践相结合的方式来阐述高水准的Android应用开发要点，Android开发进阶值得拥有。 Android UI设计Material Design在开发一款Android App之前，你需要了解下Android平台的设计规范，这里有Google最新推出的Material Design中文翻译版。并且 Google 官方出了一个支持库 Android Design Support Library，具体用法见链接。Sketch 3这个工具只推荐给对UI感兴趣的开发者，这是一个专为设计移动端 UI 的设计工具，作为开发者，不用懂那么复杂的 PS 使用，也可以做非常专业设计。 Android App源码推荐当你已经做Android开发一段时间，并苦于进入瓶颈，这个时候阅读一些优秀App的源码是最好的学习进阶方式，借鉴一些优秀App源码的设计能获益很大。ioschediosched项目是Google I/O的官方app，绝佳的学习项目。android-UniversalMusicPlayer也是Google官方作品，代码量不大、注释清晰，简单但全功能的音乐播放器。android-topeka这个项目是Google前段时间刚发出来，通过这个app，你还可以学到如何设计你app的交互和视觉以更好的和MaterialDesign搭配。Google的项目有些时候对于初学者有点困难，下面就推荐两个完整的轻量的学习项目。9GAG9GAG是教你使用Studio、Gradle以及一些流行的开源库快速开发一个不错的Android客户端。AnimeTaste代码家开源的一个线上关注动画的一个App，同样适合初学者学习。 Android新技术你需要了解Android有以下新兴的技术与框架，有些也许还不成熟，但是你应该去了解下，也许就是未来的方向。Kotlin作为 Android 领域的 Swift，绝对让你如沐新风。抛弃沉重的 Java 语法，Kotlin 融入了很多现代编程语言的思想，作为开发者，接受新的语言，了解新语言的发展趋势，更有利于开阔你的思路和加深对语言的理解。React NativeFacebook推出的针对移动应用的跨平台解决方案，目前还不成熟，但是由于Facebook推出，光环效应引起不少目光，这是不是未来暂且还没结论，但是有必要了解学习下。MVPMVP越来越多的被Android社区所讨论，有点是能够让代码更清晰，但同时也会增加很多类，写起来更麻烦，不过对于一些不是很庞大的项目却是非常适合的。这里提供一个最先采用MVP模式的开源项目：MVVM因为官方支持 DataBinding，把 MVVM 直接带到 Android 中。它非常高效的开发效率，让你只关心你的数据和业务，从此数据绑定会更加常见。插件化一般App上线之后出现bug需要重新提交新版本才能解决，这个就太慢了，由于iOS的审核原因，插件化在iOS开发常见，阿里业务方面这个特别需要，比如双十一出了bug，不能眼睁睁的看着bug出现不管吧，所以阿里系衍生出了一系列热修复的框架，dexposed、AndFix，具体可以见这里详解。RxJava最近响应式编程框架RxJava越来越受大家待见，RxJava让你异步任务更简洁方便，以我对技术的敏感性认为RxJava可能会越来越普遍，推荐大家学习。这里有一系列详细的资料教你学习。 当你下定决心，准备前行的时候，剩下的只有坚持了！]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>Java</tag>
        <tag>Gradle</tag>
        <tag>github</tag>
        <tag>StackOverFlow</tag>
        <tag>Material Design</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础14-开发一个简单的天气软件]]></title>
    <url>%2F2016%2F02%2F11%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8014-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%A9%E6%B0%94%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 实现一个简单的天气应用 仿小米天气界面效果 本篇文章主要来实现一个天气应用 —— 必应天气。具备以下功能： 定位城市，查看城市天气信息 播报语音天气 切换城市 后台自动更新天气 效果如下： 天气 api 接口来自和风天气，数据相对简单，返回的数据有限（只返回3条未来几天天气预报和每小时预报的数据）： http://docs.heweather.com/224489 它提供了天气预报集合接口、城市查询等接口。 全国省市县数据 api 接口来自郭神提供的： http://guolin.tech/api/china 必应图片 api 接口也是来自郭神提供的： http://guolin.tech/api/bing_pic 本项目结构比较简单，如下： 用到的第三方开源库有： 123456789compile 'com.android.support:design:25.1.1'compile 'com.jakewharton:butterknife:8.5.1'compile 'org.litepal.android:core:1.4.1' compile 'com.squareup.okhttp3:okhttp:3.5.0'compile 'com.google.code.gson:gson:2.8.0'compile 'com.github.bumptech.glide:glide:3.7.0'compile 'com.yalantis:contextmenu:1.0.7'compile 'com.liaoinstan.springview:library:1.2.7' // 下拉刷新compile 'com.github.lecho:hellocharts-android:v1.5.8' 界面设计参照小米天气，Material Design 风格；代码开发基于郭神在文章中涉及到的代码，定位采用百度定位（模拟器上貌似定位不了），语音合成采用科大讯飞的。 总的来说，项目完成了天气信息展示、切换城市、下拉刷新等一些基本功能，还有很多功能不完善，整体界面也不够美观，仅供练习用。 app传送门： 必应天气 app 下载 源码传送门： https://github.com/KXwonderful/BingWeather]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础13-Android 中的一些高级技巧]]></title>
    <url>%2F2016%2F01%2F28%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8013-Android%20%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以几下个知识点： 获取全局 Context 使用 Intent 传递对象 定制日志工具 创建定时任务 多窗口模式编程 13.1 全局获取 Context 的技巧 在某些情况下，获取 Context 并非是一件容易事，下面就来学习让你在项目的任何地方都能轻松获取到 Context 的一种技巧。 Android 提供了一个 Application 类，每当应用程序启动时，系统就会自动将这个类进行初始化。我们可以定制一个自己的 Application 类，以便管理程序内一些全局的状态信息，比如全局的 Context。 定制一个自己的 Application 并不复杂，首先需要创建一个 MyApplication 类继承自 Application，如下： 12345678910111213public class MyApplication extends Application &#123; private static Context context; @Override public void onCreate() &#123; context = getApplicationContext(); &#125; public static Context getContext()&#123; return context; &#125;&#125; 接下来在 AndroidManifest.xml 文件的标签下进行指定就可以了，如下： 123456789 &lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; . . .&lt;/application&gt; 这样就实现了一种全局获取 Context 的机制，之后在项目的任何地方想要获取 Context，只需调用 MyApplication.getContext() 就可以了，如弹吐司： 1Toast.makeText(MyApplication.getContext(),"提示内容",Toast.LENGTH_SHORT).show(); 任何一个项目都只能配置一个 Application，当引用第三方库如 LitePal 时要配置 LitePalApplication 就会起冲突了，这种情况就要在自己的 Application 中去调用 LitePal 的初始化方法，如下： 123456789101112131415public class MyApplication extends Application &#123; private static Context context; @Override public void onCreate() &#123; context = getApplicationContext(); // 调用 LitePal 的初始化方法 LitePal.initialize(context); &#125; public static Context getContext()&#123; return context; &#125;&#125; 使用上面的写法，把 Context 对象通过参数传递给 LitePal，效果和在 AndroidManifest.xml 中配置 LitePalApplication 是一样的。 当然，我个人是更习惯于通过获取全局类实例的方法来定制自己的 Application 类，如下： 1234567891011121314151617181920public class MyApplication extends Application &#123; private static MyApplication mInstance; @Override public void onCreate() &#123; super.onCreate(); mInstance = this; // 调用 LitePal 的初始化方法 LitePal.initialize(this); &#125; /** * Singleton main method. Provides the global static instance of the helper class. * @return The MyApplication instance. */ public static synchronized MyApplication getInstance() &#123; return mInstance; &#125;&#125; 13.2 使用 Intent 传递对象 使用 Intent 时，可以在 Intent 中添加一些附加数据，以达到传值的效果，如在第一个活动中添加如下代码： 1234Intent intent = new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra("string_data","hello");intent.putExtra("int_data",100);startActivity(intent); 然后在第二个活动中就可以获得这些值了，如下： 12getIntent().getStringExtra("string_data");getIntent().getIntExtra("int_data",0); 但上面的 putExtra() 方法中所支持的数据类型是有限的，若要传递一些自定义对象时就无从下手了，下面就来学习下用 Intent 来传递对象的技巧：Serializable 和 Parcelable。 13.2.1 Serializable 方式 Serializable 是序列化的意思，表示将一个对象转化成可储存或可传输的状态。序列化的对象可在网络上传输也可存储到本地。将一个类序列化只要去实现 Serializable 接口就可以了。 比如一个 Person 类，将它序列化可以这样写： 12345678910111213141516171819202122public class Person implements Serializable&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 接下来在第一个活动中的写法非常简单： 123456Person person = new Person();person.setName("Tom");person.setAge(18);Intent intent = new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra("person_data",person);startActivity(intent); 然后在第二个活动中获取对象也非常简单： 1Person person = (Person) getIntent().getSerializableExtra("person_data"); 这样就实现了使用 Intent 传递对象了。 13.2.2 Parcelable 方式 Parcelable 方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了。 Parcelable 的实现方式要稍微复杂一些，修改 Person 中的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Person implements Parcelable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; // 写出数据：将 Person 类中的字段一一写出 dest.writeString(name);// 写出 name dest.writeInt(age);// 写出 age &#125; public static final Parcelable.Creator&lt;Person&gt;CREATOR = new Parcelable.Creator&lt;Person&gt;()&#123; @Override public Person createFromParcel(Parcel source) &#123; // 读取数据：读取的顺序要和写出的顺序完全相同 Person person = new Person(); person.name = source.readString();//读取 name person.age = source.readInt();//读取 age return person; &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;;&#125; 接下来在第一个活动中的写法不变，在第二个活动中获取对象稍加改动： 1Person person = (Person)getIntent().getParcelableExtra("person_data"); 这样就也实现使用 Intent 传递对象了。 对比一下，Serializable 的方式较为简单，但由于把整个对象进行序列化，效率会比 Parcelable 方式低。一般推荐使用 Parcelable 的方式来实现 Intent 传递对象的功能。 13.3 定制自己的日志工具 开发一个项目时，定制一个自己的日志工具能够自由的控制日志的打印，当程序处于开发阶段时让日志打印出来，当程序上线后把日志屏蔽。 新建日志工具类 LogUtils 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LogUtils &#123; public static final int VERBOSE = 1; public static final int DEBUG = 2; public static final int INFO = 3; public static final int WARN = 4; public static final int ERROR = 5; public static final int NOTHING = 6; public static int level = VERBOSE; public static void v(String tag,String msg)&#123; if (level &lt;= VERBOSE)&#123; Log.v(tag,msg); &#125; &#125; public static void d(String tag,String msg)&#123; if (level &lt;= DEBUG)&#123; Log.d(tag,msg); &#125; &#125; public static void i(String tag,String msg)&#123; if (level &lt;= INFO)&#123; Log.i(tag,msg); &#125; &#125; public static void w(String tag,String msg)&#123; if (level &lt;= WARN)&#123; Log.w(tag,msg); &#125; &#125; public static void e(String tag,String msg)&#123; if (level &lt;= ERROR)&#123; Log.e(tag,msg); &#125; &#125;&#125; 上述代码提供了5个自定义的日志方法，其内部分别调用了 Android 自带的打印日志方法，在项目里使用就像使用普通日志工具一样，如打印一行 DEBUG 级别的日志可以这样写： 1LogUtils.d("TAG","debug log"); 值得注意的是，LogUtils 定义了一个静态变量 level，在开发阶段将 level 指定成 VERBOSE，当项目正式上线时将 level 指定成 NOTHING，将所有日志屏蔽。 13.4 创建定时任务 Android 中的定时任务一般有两种实现方式，一种是使用 Java API 里提供的 Timer 类（不太适用于需要长期在后台运行的定时任务），一种是使用 Android 的 Alarm 机制（具有唤醒 CPU 功能，可以保证大多数情况下执行定时任务时 CPU 能正常工作）。 13.4.1 Alarm 机制 Alarm 机制的用法不复杂，主要是借助 AlarmManager 类来实现的。比如想要设定一个任务在 10 秒钟后执行，可写成： 123456789101112131415// 获取 AlarmManager 的实例AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);// 设置触发时间// SystemClock.elapsedRealtime() 获取系统开机至今所经历时间的毫秒数// SystemClock.currentTimeMillis() 获取1970年1月1日0点至今所经历时间的毫秒数long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;// 3个参数：指定 AlarmManager 的工作类型、定时任务的触发时间、PendingIntent// 其中AlarmManager 的工作类型有四种：// ELAPSED_REALTIME 定时任务的触发时间从系统开机开始时算起，不会唤醒 CPU// ELAPSED_REALTIME_WAKEUP 系统开机开始时算起，会唤醒 CPU// RTC 从1970年1月1日0点开始算起，不会唤醒 CPU// RTC_WAKEUP 从1970年1月1日0点开始算起，会唤醒 CPUmanager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pandingIntent); 举个例子，实现一个长时间在后台定时运行的服务，首先新建一个普通的服务 LongRunningService，将触发定时任务的代码写到 onStartCommand() 方法中，如下： 1234567891011121314151617181920212223242526public class LongRunningService extends Service &#123; public LongRunningService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException("Not yet implemented"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 在这里执行具体的逻辑操作 &#125; &#125;).start(); AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE); int anHour = 60 * 60 * 1000;//1小时的毫秒数 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; Intent i = new Intent(this,LongRunningService.class); PendingIntent pi = PendingIntent.getService(this,0,i,0); manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pi); return super.onStartCommand(intent, flags, startId); &#125;&#125; 然后，要启动定时服务时调用如下代码即可： 12Intent intent = new Intent(context,LongRunningService.class);context.startService(intent); 值得注意的是，从 Android 4.4开始，由于系统在耗电方面的优化，Alarm 任务的触发时间变得不准确，可能会延迟一段时间后再执行。当然，使用 AlarmManager 的 setExact() 方法来替代 set() 方法，基本上可以保证任务准时执行。 13.4.2 Doze 模式 在 Android 6.0中，谷歌加入了一个全新的 Doze 模式，可以极大幅度地延长电池的使用寿命。下面就来了解下这个模式，掌握一些编程时注意事项。 在 6.0 及以上系统的设备上，若未插接电源，处于静止状态（7.0中删除了这一条件），且屏幕关闭了一段时间之后，就会进入到 Doze 模式。在 Doze 模式下，系统会对 CPU、网络、Alarm 等活动进行限制，从而延长电池的使用寿命。 当然，系统不会一直处于 Doze 模式，而是会间歇性的退出一小段时间，在这段时间应用可以去完成它们的同步操作、Alarm 任务等，其工作过程如下： Doze 模式下受限的功能有： （1）网络访问被禁止 （2）系统忽略唤醒CPU或屏幕操作 （3）系统不再执行WIFI扫描 （4）系统不再执行同步任务 （5）Alarm 任务将会在下次退出 Doze 模式时执行 特殊需求，要 Alarm 任务在 Doze 模式下也必须正常执行，则可以调用 AlarmManager 的 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle() 方法。 13.5 多窗口模式编程 Android 7.0中引入了一个非常有特色的功能——多窗口模式，允许在同一个屏幕中同时打开两个应用程序。 13.5.1 进入多窗口模式 手机的导航栏上有3个按钮：左边 Back 按钮、中间 Home 按钮、右边 OverView 按钮，如下所示： OverView 按钮的作用是打开一个最近访问过的活动或任务的列表界面，进入多窗口模式需要用到 OverView 按钮，并且有两种方式： 在 OverView 列表界面长按任意一个活动的标题，将该活动拖到屏幕突出显示的区域，则可以进入多窗口模式。 打开任意一个程序，长按 OverView 按钮，也可以进入多窗口模式。 多窗口模式效果如下： 可以看出多窗口模式下，应用界面缩小很多，编写程序时要多考虑使用 match_parent 属性、RecyclerView、ScrollView 等控件，适配各种不同尺寸的屏幕。 13.5.2 多窗口模式下的生命周期 多窗口模式并不会改变活动原有的生命周期，只是会将用户最近交互过的那个活动设置为运行状态，而将多窗口模式下另外一个可见的活动设置为暂停状态。若这时用户又去和暂停的活动进行交互，那么该活动就变成运行状态，之前处于运行状态的活动变成暂停状态。 进入多窗口模式时活动会被重新创建，若要改变这一默认行为，可以在 AndroidManifest.xml 中对活动添加如下配置： 1android:configChanges="orientation|keyboardHidden|screenSize|screenLayout" 添加这行配置后，不管是进入多窗口模式还是横竖屏切换，活动都不会被重新创建，而是会将屏幕发生变化的事件通知到 Activity 的 onConfigurationChanged() 方法中。因此，若要在屏幕发生变化时进行相应的逻辑处理，那么在活动中重写 onConfigurationChanged() 方法即可。 13.5.3 禁用多窗口模式 禁用多窗口模式的方法很简单，只需在 AndroidManifest.xml 的或标签中加入如下属性即可： 1android:resizeableActivity=["true"|"false"] 其中，true 表示支持多窗口模式，false 表示不支持，若不配置这属性默认是 true。 虽说 android:resizeableActivity 这个属性的用法简单，但这个属性只适用于 targetSdkVersion 24 或更高的时候，若低于24则无效，可能会被告知此应用在多窗口模式下可能无法正常工作，并进入多窗口模式。 Android 规定，若项目指定的 targetSdkVersion 低于24，并且活动是不允许横竖屏切换时是不支持多窗口模式的。因此针对上面的情况，就需要在 AndroidManifest.xml 的标签中配置如下属性： 1android:screenOrientation=["portrait"|"landscape"] 其中，portrait 表示只支持竖屏，landscape 表示只支持横屏。 本篇文章就介绍到这。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础12-Material Design 实战]]></title>
    <url>%2F2016%2F01%2F14%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8012-Material%20Design%20%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： Toolbar 滑动菜单 悬浮按钮 卡片式布局 下拉刷新 可折叠式标题栏 Material Design 是由谷歌的设计工程师基于优秀的设计原则，结合丰富的创意和科学技术所发明的一套全新的界面设计语言，包含了视觉、运动、互动效果等特性。 在2015年的 Google I/O 大会上推出了一个 Design Support 库，这个库将 Material Design 中最具代表性的一些控件和效果进行了封装，使开发者能轻松地将自己的应用 Material 化。本篇文章就来学习下 Design Support 这个库，实现以下效果： 12.1 Toolbar 相信大家熟悉控件 ActionBar，由于其设计的原因，被限定只能位于活动的顶部，从而不能实现一些 Material Design 的效果，因此官方已不建议使用 ActionBar 了，而推荐使用 Toolbar。 Toolbar 不仅继承了 ActionBar 的所有功能，而且灵活性很高。下面来具体学习下。 首先，修改一下项目的默认主题，指定为不带 ActionBar 的主题，打开 values 文件下的 styles.xml，修改如下： 1234567891011&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 观察下 AppTheme 中的属性重写，3个属性代表的颜色位置如下： 把 ActionBar 隐藏起来后，用 ToolBar 来替代 ActionBar，修改布局中的代码如下： 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt;&lt;/FrameLayout&gt; 上述代码指定一个 xmlns:app 的命名空间是由于很多 Meterial 属性在5.0之前的系统中并不存在，为了能够兼容之前的老系统，应该使用 app:attribute 这样的写法，从而就可以兼容 Android 5.0 以下的系统了。 接下来修改活动中的代码如下： 1234567891011public class MaterialDesignActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);// 将 Toolbar 的实例传入 &#125;&#125; 运行效果如下： 上面效果和之前的标题栏差不多，接下来学习一下 Toolbar 常用的功能，比如修改标题栏上显示的文字内容。这文字内容是在 AndroidManifest.xml 中指定的，如下： 123&lt;activity android:name=".chapter12.MaterialDesignActivity" android:label="Fruits"/&gt; 上面给 activity 增加了一个 android:label 属性，指定在 Toolbar 中显示的文字内容，若没指定的话，默认使用 application 中指定的 label 内容，即应用名称。 接下来再添加一些 action 按钮使 Toolbar 更加丰富一些。右击 res 目录→New→Directory，创建一个 menu 文件夹。然后右击 menu 文件夹→New→Menu resource file，创建一个toolbar.xml 文件，编写代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;!-- 通过&lt;item&gt;标签定义 action 按钮 android:id 按钮id；android:icon 按钮图标；android:title 按钮文字 app:showAsAction 按钮的显示位置： always 永远显示在Toolbar中，若屏幕不够则不显示 ifRoom 屏幕空间足够时显示在Toolbar中，不够时显示在菜单中 never 永远显示在菜单中 （Toolbar中的action只显示图标，菜单中的action只显示文字）--&gt; &lt;item android:id="@+id/backup" android:icon="@mipmap/backup" android:title="Backup" app:showAsAction="always"/&gt; &lt;item android:id="@+id/delete" android:icon="@mipmap/delete" android:title="Delete" app:showAsAction="ifRoom"/&gt; &lt;item android:id="@+id/settings" android:icon="@mipmap/settings" android:title="Settings" app:showAsAction="never"/&gt;&lt;/menu&gt; 然后修改活动中的代码如下： 1234567891011121314151617181920212223242526272829303132333435public class MaterialDesignActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);// 将 Toolbar 的实例传入 &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // 加载菜单 getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // 设置点击事件 switch (item.getItemId())&#123; case R.id.backup: ToastUtils.showShort("点击了备份"); break; case R.id.delete: ToastUtils.showShort("点击了删除"); break; case R.id.settings: ToastUtils.showShort("点击了设置"); break; &#125; return true; &#125;&#125; 运行效果如下： 好了，关于 Toolbar 的内容就先讲到这。当然 Toolbar 的功能远远不只这些，更多功能以后再挖掘。 12.2 滑动菜单 滑动菜单可以说是 Meterial Design 中最常见的效果之一，将一些菜单项隐藏起来，而不是放置在主屏幕上，通过滑动的方式将菜单显示出来。 12.2.1 DrawerLayout 谷歌提供了一个 DrawerLayout 控件，借助这个控件，实现滑动菜单简单又方便。下面介绍下它的用法。 首先它是一个布局，在布局中允许放入两个直接子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单显示的内容。因此，可以修改布局代码如下所示： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--********** 第一个子控件 主屏幕显示 ***********--&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; &lt;/FrameLayout&gt; &lt;!--********** 第二个子控件 滑动菜单显示 **********--&gt; &lt;!-- 注意：属性 android:layout_gravity 是必须指定的 --&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" android:text="这是滑动菜单" android:background="#fff"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 接下来在 Toolbar 的最左边加入一个导航按钮，提示用户屏幕左侧边缘是可以拖动的，点击按钮将滑动菜单的内容展示出来。修改活动中的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class MaterialDesignActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);// 将 Toolbar 的实例传入 mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBar actionBar = getSupportActionBar(); if (actionBar != null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); //让导航按钮显示出来 actionBar.setHomeAsUpIndicator(R.mipmap.menu);//设置导航按钮图标 &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // 加载菜单 getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // 设置点击事件 switch (item.getItemId())&#123; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START);//打开抽屉 break; . . . &#125; return true; &#125;&#125; 上述代码值得注意的是在 onOptionItemSelected() 方法中对 HomeAsUp 按钮的点击事件进行处理，HomeAsUp 按钮的 id永远是 android.R.id.home。现在重新运行程序，效果如下： 12.2.2 NavigationView 上面已经成功实现了滑动菜单功能，但界面不美观，谷歌给我们提供了一种更好的方法——使用 NavigationView，在滑动菜单页面定制任意布局。 NavigationView 是 Design Support 库中提供的一个控件，严格按照 Material Design 的要求来设计的，并且将滑动菜单页面的实现变得非常简单。下面一起来学习下。 首先，将 Design Support 库以及开源项目 CircleImageView（实现图片圆形化，项目主页地址：https://github.com/hdodenhof/CircleImageView ）引入到项目中： 12compile 'com.android.support:design:24.2.1'compile 'de.hdodenhof:circleimageview:2.1.0' 在使用 NavigationView 之前，还需要准备两个东西：在 NavigationView 中用来显示具体菜单项的 menu 和显示头部布局的 headerLayout。 （1）准备 menu。在 menu 文件夹下创建一个 nav_menu.xml 文件，编写代码如下： 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--checkableBehavior指定为single表示组中的所有菜单项只能单选 --&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_call" android:icon="@mipmap/call" android:title="Call"/&gt; &lt;item android:id="@+id/nav_friends" android:icon="@mipmap/friends" android:title="Friends"/&gt; &lt;item android:id="@+id/nav_location" android:icon="@mipmap/location" android:title="Location"/&gt; &lt;item android:id="@+id/nav_mail" android:icon="@mipmap/mail" android:title="Mail"/&gt; &lt;item android:id="@+id/nav_task" android:icon="@mipmap/task" android:title="Task"/&gt; &lt;/group&gt;&lt;/menu&gt; （2）准备 headerLayout。在 layout 文件夹下创建一个布局文件 nav_header.xml，编写代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="180dp" android:padding="10dp" android:background="?attr/colorPrimary"&gt; &lt;!--*************** 头像 ****************--&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id="@+id/icon_image" android:layout_width="70dp" android:layout_height="70dp" android:src="@mipmap/nav_icon" android:layout_centerInParent="true"/&gt; &lt;!--*************** 邮箱 ****************--&gt; &lt;TextView android:id="@+id/mail" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:gravity="center" android:text="KXwonderful@gmail.com" android:textColor="@color/white" android:textSize="14sp"/&gt; &lt;!--*************** 用户名 ****************--&gt; &lt;TextView android:id="@+id/username" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_above="@+id/mail" android:gravity="center" android:text="开心wonderful" android:textColor="@color/white" android:textSize="14sp"/&gt;&lt;/RelativeLayout&gt; 准备好 menu 和 headerLayout 后，可以使用 NavigationView 了，修改布局代码，将之前的 TextView 替换成 NavigationView，如下： 1234567891011121314151617181920212223242526272829303132&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; &lt;/FrameLayout&gt; &lt;!--******** 第二个子控件 滑动菜单显示 ********--&gt; &lt;!-- 注意：属性 android:layout_gravity 是必须指定的 --&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 最后，修改活动中的代码，添加处理菜单项的点击事件，如下： 1234567891011121314151617181920212223242526272829303132public class MaterialDesignActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar);// 将 Toolbar 的实例传入 mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); NavigationView navView = (NavigationView) findViewById(R.id.nav_view); ActionBar actionBar = getSupportActionBar(); if (actionBar != null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); //让导航按钮显示出来 actionBar.setHomeAsUpIndicator(R.mipmap.menu);//设置导航按钮图标 &#125; navView.setCheckedItem(R.id.nav_call);//设置默认选中项 navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; mDrawerLayout.closeDrawers();//关闭抽屉 ToastUtils.showShort("点击了"+item.getTitle()); return true; &#125; &#125;); &#125; . . .&#125; 现在重新运行下程序，效果如下： 上面效果相对之前的美观了许多，但不要满足现状，跟紧脚步，继续学习。 12.3 悬浮按钮和可交互提示 立体设计是 Material Design 中一条非常重要的思想，即应用程序的界面不仅仅是一个平面，而应该是有立体效果的。 12.3.1 FloatingActionButton FloatingActionButton 是 Design Support 库中提供的一个控件，可以比较轻松地实现悬浮按钮地效果。它默认使用 colorAccent 作为按钮的颜色。下面来具体实现下。 首先，在主屏幕布局加入一个 FloatingActionButton，修改布局代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; &lt;!-- app:elevation属性是给FloatingActionButton指定高度， 值越大，投影范围越大，效果越淡，反之 --&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/done" app:elevation="8dp"/&gt; &lt;/FrameLayout&gt; . . .&lt;/android.support.v4.widget.DrawerLayout&gt; 接着，设置 FloatingActionButton 的点击事件，在活动中添加代码如下： 12345678910111213141516171819public class MaterialDesignActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); . . . FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ToastUtils.showShort("点击了悬浮按钮"); &#125; &#125;); &#125; . . .&#125; 现在重新运行下程序，效果如下： 12.3.2 Snackbar 接下来学习下 Design Support 库提供的比 Toast 更加先进的提示工具——Snackbar。 当然，Snackbar 并不是 Toast 的替代品，它们两者之间有着不同的应用场景。Snackbar 在提示当中加入了一个可交互按钮，点击时可以执行一些额外的操作。 Snackbar 的用法非常简单，修改活动中的代码如下： 1234567891011121314151617181920212223242526public class MaterialDesignActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); . . . FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //ToastUtils.showShort("点击了悬浮按钮"); Snackbar.make(v,"删除数据",Snackbar.LENGTH_SHORT) .setAction("取消", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ToastUtils.showShort("数据恢复"); &#125; &#125;).show(); &#125; &#125;); &#125; . . .&#125; 现在重新运行下程序，效果如下： 可以看到，Snackbar 从屏幕底部出现，上面有设置的提示文字和设置的取消按钮。但存在个 bug，这个 Snackbar 把悬浮按钮给遮挡住了，解决这个 bug 就要借助 CoordinatorLayout 了。 12.3.3 CoordinatorLayout CoordinatorLayout 是 Design Support 库提供的一个加强版的 FrameLayout 布局，它可以监听其所有子控件的各种事件，然后自动帮我们做出最为合理的响应。 CoordinatorLayout 的使用也非常简单，只需将原来的 FrameLayout 替换一下就可以了。修改布局代码如下： 123456789101112131415161718192021222324252627282930313233&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/done" app:elevation="8dp"/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; . . .&lt;/android.support.v4.widget.DrawerLayout&gt; 现在重新运行下程序，效果如下： 可以看到悬浮按钮自动向上移，从而不会被遮住。 上面 Snackbar 好像并不是 CoordinatorLayout 的子控件，却也能被监听到，是因为在 Snackbar 中传入的第一个参数是用来指定 Snackbar 是基于哪个 View 来触发的，上面传入的是 FloatingActionButton 本身，而 FloatingActionButton 是 CoordinatorLayout 的子控件。 12.4 卡片式布局 卡片式布局是 Material Design 中提出的一个新概念，它可以让页面中的元素看起来就像在卡片中一样，并且还能拥有圆角和投影。 12.4.1 CardView CardView 是 appcompat-v7 库提供的用于实现卡片式布局效果的重要控件，它也是一个 FrameLayout，只是额外提供了圆角和阴影等效果，有立体感。 CardView 的基本用法非常简单，如下： 123456789101112&lt;!-- app:cardCornerRadius 指定卡片圆角的弧度，值越大弧度越大 app:elevation 指定卡片的高度，值越大投影范围越大，效果越淡--&gt;&lt;android.support.v7.widget.CardView android:layout_width="wrap_content" android:layout_height="wrap_content" app:cardCornerRadius="4dp" app:elevation="5dp"&gt; &lt;TextView android:id="@+id/info_text" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/android.support.v7.widget.CardView&gt; 上面代码在 CardView 中放了一个 TextView，这个 TextView 就会显示在一张卡片上。 接下来，综合运用第3章的知识，用RecyclerView 来填充项目的主界面部分，实现 OnePiece（海贼王） 列表。 首先，添加如下要用到的依赖库： 123compile 'com.android.support:recyclerview-v7:24.2.1'compile 'com.android.support:cardview-v7:24.2.1'compile 'com.github.bumptech.glide:glide:3.7.0' 上面的 Glide 库是一个图片加载库，其项目主页地址是：https://github.com/bumptech/glide 。 接着，在布局文件中添加 RecyclerView，如下： 1234567891011121314151617181920212223242526272829&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" . . . /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_one_piece" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" . . . /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; . . .&lt;/android.support.v4.widget.DrawerLayout&gt; 接着，定义一个实体类 Partner，如下： 1234567891011121314151617181920212223242526public class Partner &#123; private String name; // 伙伴名称 private int imageId; // 伙伴对应头像的资源id private int profileId; // 人物简介的资源id public Partner(String name, int imageId, int profileId) &#123; this.name = name; this.imageId = imageId; this.profileId = profileId; &#125; public String getName()&#123; return name; &#125; public int getImageId()&#123; return imageId; &#125; public int getProfileId() &#123; return profileId; &#125;&#125; 然后为 RecyclerView 的子项指定一个自定义布局，新建 partner_item.xml，使用 CardView 作为最外层布局，如下： 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="5dp" app:cardCornerRadius="4dp"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;!--******** 显示头像********--&gt; &lt;ImageView android:id="@+id/partner_image" android:layout_width="match_parent" android:layout_height="100dp" android:scaleType="centerCrop"/&gt; &lt;!--******** 显示名称********--&gt; &lt;TextView android:id="@+id/partner_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_margin="5dp" android:textSize="16sp"/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 接下来为 RecyclerView 准备一个适配器，新建 PartnerAdapter 类如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PartnerAdapter extends RecyclerView.Adapter&lt;PartnerAdapter.ViewHolder&gt;&#123; private Context mContext; private List&lt;Partner&gt; mPartnerList; static class ViewHolder extends RecyclerView.ViewHolder&#123; CardView cardView; ImageView partnerImage; TextView partnerName; public ViewHolder(View itemView) &#123; super(itemView); cardView = (CardView) itemView; partnerImage = (ImageView) itemView.findViewById(R.id.partner_image); partnerName = (TextView) itemView.findViewById(R.id.partner_name); &#125; &#125; public PartnerAdapter(List&lt;Partner&gt; partnerList)&#123; mPartnerList = partnerList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (mContext == null)&#123; mContext = parent.getContext(); &#125; View view = LayoutInflater.from(mContext).inflate(R.layout.partner_item,parent,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Partner partner = mPartnerList.get(position); holder.partnerName.setText(partner.getName()); Glide.with(mContext).load(partner.getImageId()).into(holder.partnerImage); &#125; @Override public int getItemCount() &#123; return mPartnerList.size(); &#125;&#125; 上述代码中用到 Glide 加载本地图片，它会帮我们把图片压缩，因此不用担心内存溢出。 适配器准备好了，最后修改活动中的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MaterialDesignActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; private Partner[] partners = &#123; new Partner("路飞",R.mipmap.partner_luffy,R.string.partner_luffy), new Partner("索隆",R.mipmap.partner_zoro,R.string.partner_zoro), new Partner("山治",R.mipmap.partner_sanji,R.string.partner_sanji), new Partner("艾斯",R.mipmap.partner_ace,R.string.partner_ace), new Partner("罗",R.mipmap.partner_law,R.string.partner_law), new Partner("娜美",R.mipmap.partner_nami,R.string.partner_nami), new Partner("罗宾",R.mipmap.partner_robin,R.string.partner_robin), new Partner("薇薇",R.mipmap.partner_vivi,R.string.partner_vivi), new Partner("蕾贝卡",R.mipmap.partner_rebecca,R.string.partner_rebecca), new Partner("汉库克",R.mipmap.partner_hancock,R.string.partner_hancock)&#125;; private List&lt;Partner&gt; partnerList = new ArrayList&lt;&gt;(); private PartnerAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); . . . initPartner(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.rv_one_piece); GridLayoutManager layoutManager = new GridLayoutManager(this,2); recyclerView.setLayoutManager(layoutManager); adapter = new PartnerAdapter(partnerList); recyclerView.setAdapter(adapter); &#125; /** * 初始化数据，随机挑选50条数据 */ private void initPartner() &#123; partnerList.clear(); for (int i = 0;i &lt; 50 ;i++)&#123; Random random = new Random(); int index = random.nextInt(partners.length); partnerList.add(partners[index]); &#125; &#125; . . .&#125; 现在重新运行下程序，效果如下： 可以看到，精美的图片成功展示出来了，但 Toolbar 却被挡住了，这是由于 RecyclerView 和 Toolbar 都是放置在 CoordinatorLayout 中，而 CoordinatorLayout 是一个增强版的 FrameLayout，其控件在不进行明确定位时默认放在布局的左上角，从而产生了遮挡的现象。解决这个 bug 就要借助到另外一个工具了——AppBarLayout。 12.4.2 AppBarLayout AppBarLayout 是 Design Support 库提供的一个垂直方向的 LinearLayout，它在内部做了很多滚动事件的封装，并应用了一些 Meterial Design 的设计理念。 只需两步就可以解决前面的遮挡问题，第一步是将 Toolbar 嵌套到 AppBarLayout 中，第二步给 RecyclerView 指定一个布局行为。修改布局代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;android.support.v4.widget.DrawerLayout . . .&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_one_piece" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; . . . &lt;/android.support.design.widget.CoordinatorLayout&gt; . . .&lt;/android.support.v4.widget.DrawerLayout&gt; 现在重新运行下程序，效果如下: 当 AppBarLayout 接收到滚动事件时，它内部的子控件其实是可以指定如何取影响这些事件的，下面就来进一步优化，使当 RecyclerView 向上滚动时，Toolbar 隐藏，向下滚动时显示。修改布局代码如下所示： 1234567891011121314151617181920212223242526272829303132&lt;android.support.v4.widget.DrawerLayout . . .&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:layout_scrollFlags="scroll|enterAlways|snap"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView . . ./&gt; . . . &lt;/android.support.design.widget.CoordinatorLayout&gt; . . .&lt;/android.support.v4.widget.DrawerLayout&gt; 在 Toolbar 中添加了一个 app:layout_scrollFlags 属性，并指定成 scroll|enterAlways|snap。其中 scroll 指当 RecyclerView 向上滚动时，Toolbar 会跟着一起向上滚动并隐藏；enterAlways 指向下滚动时一起向下滚动并显示；snap 指当 Toolbar 还没有完全隐藏或显示时，会根据当前滚动的距离自动选择隐藏还是显示。 现在重新运行下程序，效果如下: 12.5 下拉刷新 在 Meterial Design 中，SwipeRefreshLayout 是用于实现下拉刷新的核心类，它由 support-v4 库提供，把要实现下拉刷新功能的控件放置到 SwipeRefreshLayout 中，就能让这个控件支持下拉刷新。 SwipeRefreshLayout 用法比较简单，修改布局，在 RecyclerView 的外面嵌套一层 SwipeRefreshLayout，如下： 123456789101112131415161718192021222324252627282930313233343536&lt;android.support.v4.widget.DrawerLayout . . .&gt; &lt;!--******** 第一个子控件 主屏幕显示 ********--&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar . . ./&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id="@+id/swipe_refresh" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_one_piece" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; . . . &lt;/android.support.design.widget.CoordinatorLayout&gt; . . .&lt;/android.support.v4.widget.DrawerLayout&gt; 上述代码值得注意的是，由于 RecyclerView 变成了 SwipeRefreshLayout 的子控件，因此之前用 app:layout_behavior 声明布局行为要移到 SwipeRefreshLayout 中才行。 接着还要在代码中处理具体的刷新逻辑，在活动中添加如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MaterialDesignActivity extends AppCompatActivity &#123; . . . private SwipeRefreshLayout swipeRefresh;// 刷新 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_material_design); . . . // 下拉刷新 swipeRefresh = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh); swipeRefresh.setColorSchemeResources(R.color.colorPrimary);//设置刷新进度条颜色 swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; // 处理刷新逻辑 refreshPartner(); &#125; &#125;); &#125; /** * 下拉刷新数据（为简单起见没和网络交互） */ private void refreshPartner() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; initPartner();//重新生成数据 adapter.notifyDataSetChanged();//通知数据变化 swipeRefresh.setRefreshing(false);//隐藏刷新进度条 &#125; &#125;); &#125; &#125;).start(); &#125; . . .&#125; 现在重新运行下程序，效果如下: 12.6 可折叠式标题栏 作为本章的尾声，最后来实现一个震撼的 Material Design 效果——可折叠式标题栏。 12.6.1 CollapsingToolbarLayout CollapsingToolbarLayout 是 Design Support 库提供的一个作用于 Toolbar 基础之上的布局，它可让 Toolbar 的效果变得更加丰富。 不过，CollapsingToolbarLayout 是不能独立存在的，只能作为 AppBarLayout 的直接子布局来使用。而 AppBarLayout 又必须是 CoordinatorLayout 的子布局。话不多说，开始吧。 首先创建一个额外的活动 PartnerActivity 来作为海贼的简介界面，编写其对应的布局文件 activity_partner.xml 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--******************* 标题栏的界面 ****************--&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp"&gt; &lt;!-- android:theme 指定主题 app:contentScrim 指定CollapsingToolbarLayout在趋于折叠以及折叠之后的背景色 exitUntilCollapsed 指CollapsingToolbarLayout随着滚动完成折叠后就保留在界面上，不再移出界面--&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;!-- app:layout_collapseMode 指定当前控件在在CollapsingToolbarLayout折叠过程中的折叠模式 parallax 指折叠过程中会产生一定的错位偏移 pin 指在折叠过程中位置始终保持不变--&gt; &lt;ImageView android:id="@+id/partner_image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" app:layout_collapseMode="parallax"/&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin"/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!--******************* 伙伴的简介内容 ****************--&gt; &lt;!--NestedScrollView 在 ScrollView 基础上增加了嵌套响应滚动事件的功能，内部只能放一个直接子布局 --&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;android.support.v7.widget.CardView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="15dp" android:layout_marginStart="15dp" android:layout_marginEnd="15dp" android:layout_marginTop="35dp" app:cardCornerRadius="4dp"&gt; &lt;TextView android:id="@+id/partner_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="10dp" android:lineSpacingMultiplier="2"/&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;!--******************* 悬浮按钮 ****************--&gt; &lt;!-- app:layout_anchor 指定一个瞄点--&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="16dp" android:src="@mipmap/comment" app:layout_anchor="@id/appBar" app:layout_anchorGravity="bottom|end"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 编写完布局 activity_partner.xml 后，开始编写功能逻辑，修改活动 PartnerActivity 的代码如下： public class PartnerActivity extends AppCompatActivity { public static final String PARTNER_NAME = &quot;partner_name&quot;; public static final String PARTNER_IMAGE_ID = &quot;partner_image_id&quot;; public static final String PARTNER_PROFILE_ID = &quot;partner_profile_id&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_partner); Intent intent = getIntent(); String partnerName = intent.getStringExtra(PARTNER_NAME); //海贼名称 int partnerImageId = intent.getIntExtra(PARTNER_IMAGE_ID,R.mipmap.partner_luffy);//海贼图片id int partnerProfileId = intent.getIntExtra(PARTNER_PROFILE_ID,R.string.partner_luffy);//海贼资料id Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar); ImageView partnerImageView = (ImageView) findViewById(R.id.partner_image_view); TextView partnerProfile = (TextView) findViewById(R.id.partner_profile); setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (actionBar != null){ actionBar.setDisplayHomeAsUpEnabled(true); } collapsingToolbar.setTitle(partnerName); //设置标题 Glide.with(this).load(partnerImageId).into(partnerImageView);//设置图片 partnerProfile.setText(getString(partnerProfileId));//设置内容 } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()){ case android.R.id.home: // 返回上一个活动 finish(); return true; } return super.onOptionsItemSelected(item); } }123456789101112131415161718192021222324252627282930313233 最后，为实现点击 RecyclerView 跳转到海贼详情界面，还需修改适配器 PartnerAdapter 的代码，添加点击事件如下：```bashpublic class PartnerAdapter extends RecyclerView.Adapter&lt;PartnerAdapter.ViewHolder&gt;&#123; . . . @Override public ViewHolder onCreateViewHolder(final ViewGroup parent, int viewType) &#123; if (mContext == null)&#123; mContext = parent.getContext(); &#125; View view = LayoutInflater.from(mContext).inflate(R.layout.partner_item,parent,false); final ViewHolder holder = new ViewHolder(view); holder.cardView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Partner partner = mPartnerList.get(position); Intent intent = new Intent(mContext,PartnerActivity.class); intent.putExtra(PartnerActivity.PARTNER_NAME,partner.getName()); intent.putExtra(PartnerActivity.PARTNER_IMAGE_ID,partner.getImageId()); intent.putExtra(PartnerActivity.PARTNER_PROFILE_ID,partner.getProfileId()); mContext.startActivity(intent); &#125; &#125;); return holder; &#125; . . .&#125; 好了，现在重新运行下程序，效果如下: 上面展示的界面虽说已经很华丽了，但海贼背景图片和系统的状态栏总感觉有些不搭。下面就进一步提升一下。 12.6.2 充分利用系统状态栏控件 为改善上面的不搭，接下来将海贼王背景图和状态栏融合到一起。这边提供两个方法： 方案 1 借助 android:fitsSystemWindows 这个属性实现。将 ImageView 布局结构中的所有父控件都设置上这个属性并且指定为 True，修改 activity_partner.xml 如下： 12345678910111213141516171819202122232425262728&lt;android.support.design.widget.CoordinatorLayout . . . android:fitsSystemWindows="true"&gt; &lt;!--******************* 标题栏的界面 ****************--&gt; &lt;android.support.design.widget.AppBarLayout . . . android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout . . . android:fitsSystemWindows="true"&gt; &lt;ImageView android:id="@+id/partner_image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" app:layout_collapseMode="parallax" android:fitsSystemWindows="true"/&gt; . . . &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; . . .&lt;/android.support.design.widget.CoordinatorLayout&gt; 然后还要在程序的主题中将状态栏颜色指定为透明色才行，即在主题中将属性 android:statusBarColor 的值指定为 @android:color/transparent 就可以了，但问题是这个属性在 Android 5.0 系统开始才有的，因此需要准备两个同名不同内容的主题来实现。 针对5.0及以上的系统，在 res 目录下创建一个 values-v21 目录，然后在此目录创建一个 styles.xml 文件如下： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;style name="PartnerActivityTheme" parent="AppTheme"&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 针对5.0以下的系统，还需要在 value/styles.xml 文件定义一个同名主题，但内容为空，如下： 12345678910111213&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;!-- 5.0以下使用主题 --&gt; &lt;style name="PartnerActivityTheme" parent="AppTheme"&gt; &lt;/style&gt;&lt;/resources&gt; 最后修改 AndroidManifest.xml 中的代码，让 PartnerActivity 使用这个主题，如下： 1234&lt;activity android:name=".chapter12.PartnerActivity" android:theme="@style/PartnerActivityTheme"&gt;&lt;/activity&gt; 这样就大功告成了，只要在 5.0 及以上系统运行程序，效果如下：方案 2 方案1虽然实现了融合效果，但在低于5.0的系统上还是不搭，方案2就来稍微改善一下。 方案2也要在 values-v21 目录下的 styles.xml 中新建一个主题 AppTheme.NoActionBar，如下： 123456&lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 在 value/styles.xml 中也新建一个主题 AppTheme.NoActionBar，如下： 1234&lt;style name="AppTheme.NoActionBar" &gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 接下来修改 AndroidManifest.xml 中的代码，让 PartnerActivity 使用这个主题，如下： 1234&lt;activity android:name=".chapter12.PartnerActivity" android:theme="@style/AppTheme.NoActionBar"&gt;&lt;/activity&gt; 最后在 PartnerActivity 中添加如下代码： 12345678910111213141516171819202122232425262728public class PartnerActivity extends AppCompatActivity &#123; . . . @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_partner); translucentStatusBar(); . . . &#125; /** * 状态栏着色 */ private void translucentStatusBar() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;//5.0及以上 View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE; decorView.setSystemUiVisibility(option); getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;//4.4到5.0 WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; &#125; . . .&#125; 现在只要在 4.4 及以上系统运行程序就能有如下效果了： 好了，本篇文章就介绍到这。代码传送门： https://github.com/KXwonderful/MyFirstCode 更多关于 Meterial Design 的内容可以参考官方文章： https://material.google.com]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础11-基于位置的服务]]></title>
    <url>%2F2016%2F01%2F07%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8011-%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 百度定位。 百度地图。 11.1 基于位置的服务简介 基于位置的服务简称 LBS（Location Based Service），主要的工作原理是利用无线电通讯网络或 GPS 等定位方式来确定出移动设备所在的位置。 LBS 所围绕的核心就是要确定出用户所在的位置。通常有两种技术： GPS 定位： 基于手机内置的 GPS 硬件直接和卫星交互来获取当前的经纬度信息，精确度高，但只能室外使用，室内基本无法接收到卫星的信号。 网络定位： 根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定一个大概位置，精确度一般，但室内外均可使用。 本章主要学习百度在 LBS 方面提供的一些功能。 11.2 使用百度定位 要想在自己的应用程序里使用百度的 LBS 功能，首先必须申请一个 API Key，有了 API Key 就可以进行后续的 LBS 开发工作了。 11.2.1 准备 LBS SDK 在编码之前，先将百度 LBS 开放平台的 SDK 准备好，下载地址：http://lbsyun.baidu.com/sdk/download 本章会用到基础地图和基础定位这两个 SDK，下载完后对该压缩包解压，libs 目录里就有我们所需要的一切了： 下面把 libs 目录里的内容拷贝到我们的项目中： （1）把 BaiduLBS_Android.jar 拷贝到项目 app 模块中的 libs 目录： （2）展开 src/main 目录，右击该目录→New→Directory，创建一个名为 jniLibs 的目录，用来存放 so 包，然后把压缩包里的其他所以目录直接复制到这里： 另外，记得点击顶部工具栏中的 Sync 按钮（下图中最左边的按钮）将 BaiduLBS_Android.jar 添加到当前项目的引用中。 以上就把 LBS 的 SDK 都准备好了。 11.2.2 确定自己位置的经纬度 首先在 AndroidManifest 中添加开发密钥、所需权限等信息： （1）在 application 中添加开发密钥 12345&lt;application&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="开发者 key" /&gt; &lt;/application&gt; （2）添加所需权限 1234567891011&lt;!-- 百度 LBS 相关权限 --&gt;&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" /&gt;&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt; （3）再注册一个百度 LBS SDK 中的服务 12345&lt;service android:name="com.baidu.location.f" android:enabled="true" android:process=":remote"&gt;&lt;/service&gt; 接下来在布局添加个 TextView 来显示当前位置的经纬度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LocationActivity extends AppCompatActivity &#123; private LocationClient mLocationClient; private TextView tv_show_location;// 显示当前位置信息 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 构建 LocationClient 实例 mLocationClient = new LocationClient(getApplicationContext()); // 注册一个定位监听器 mLocationClient.registerLocationListener(new MyLocationListener()); setContentView(R.layout.activity_location); tv_show_location = (TextView) findViewById(R.id.tv_show_location); // 声明权限，将权限添加到list集合中再一次性申请 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); if (ActivityCompat.checkSelfPermission(LocationActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ActivityCompat.checkSelfPermission(LocationActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ActivityCompat.checkSelfPermission(LocationActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (!permissionList.isEmpty()) &#123; String[] permissions = permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(LocationActivity.this,permissions,1); &#125;else &#123; requestLocation(); &#125; &#125; /** * 开始地理位置定位 */ private void requestLocation() &#123; mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 )&#123; for (int result : grantResults)&#123; if (result != PackageManager.PERMISSION_GRANTED)&#123; ToastUtils.showShort("必须同意所有权限才能使用本程序"); finish(); return; &#125; &#125; requestLocation(); &#125;else &#123; ToastUtils.showShort("发生未知错误"); finish(); &#125; break; default: break; &#125; &#125; // 监听器 public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; StringBuilder currentLocation = new StringBuilder(); currentLocation.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentLocation.append("经线：").append(bdLocation.getAltitude()).append("\n"); currentLocation.append("定位方式："); if (bdLocation.getLocType() == BDLocation.TypeGpsLocation)&#123; currentLocation.append("GPS"); &#125; else if (bdLocation.getLocType() == BDLocation.TypeNetWorkLocation)&#123; currentLocation.append("网络"); &#125; tv_show_location.setText(currentLocation); &#125; &#125;&#125; 运行程序，效果如下： 在默认情况下，调用 LocationClient 的 start() 的方法只会定位一次，若要实时更新当前的位置，还需添加如下代码： 12345678910111213141516171819202122232425public class LocationActivity extends AppCompatActivity &#123; . . . /** * 开始地理位置定位 */ private void requestLocation() &#123; initLocation(); mLocationClient.start(); &#125; private void initLocation() &#123; // 创建LocationClientOption 对象 LocationClientOption option = new LocationClientOption(); option.setScanSpan(5000); //5秒钟更新下当前位置 mLocationClient.setLocOption(option); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop();//停止定位 &#125;&#125; 这样界面上的经纬度信息就会跟着位置变化一起变化。 11.2.3 选择定位模式 上一小节是使用网络定位的，那要如何使用 GPS 定位呢？ GPS 定位功能必须由用户主动去启用才行，开启后可以在 initLocation() 方法中对百度 LBS SDK 的定位模式进行指定，共有3种模式： Hight_Accuracy 高精度模式（默认模式），会在GPS信号正常的情况下优先使用GPS定位，在无法接收GPS信号时用网络定位。 Battery_Saving 节电模式，只会使用网络定位。 Device_Sensors 传感器模式，只会使用GPS定位。 当然，也可以调用 setLocationMode() 方法来强制指定只使用GPS定位，如下： 1option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); 重新运行程序，效果如下： 11.2.4 看得懂的位置信息 经纬度一般人是看不懂，为了更加直观点，还需要进行一些简单的接口调用，如下： 12345678910111213141516171819202122232425262728293031323334public class LocationActivity extends AppCompatActivity &#123; . . . private void initLocation() &#123; LocationClientOption option = new LocationClientOption(); option.setScanSpan(5000); //需要获取当前位置的详细信息 option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; // 监听器 public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; StringBuilder currentLocation = new StringBuilder(); currentLocation.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentLocation.append("经线：").append(bdLocation.getAltitude()).append("\n"); currentLocation.append("国家：").append(bdLocation.getCountry()).append("\n"); currentLocation.append("省：").append(bdLocation.getProvince()).append("\n"); currentLocation.append("市：").append(bdLocation.getCity()).append("\n"); currentLocation.append("区：").append(bdLocation.getDistrict()).append("\n"); currentLocation.append("街道：").append(bdLocation.getStreet()).append("\n"); currentLocation.append("定位方式："); if (bdLocation.getLocType() == BDLocation.TypeGpsLocation)&#123; currentLocation.append("GPS"); &#125; else if (bdLocation.getLocType() == BDLocation.TypeNetWorkLocation)&#123; currentLocation.append("网络"); &#125; tv_show_location.setText(currentLocation); &#125; &#125; &#125; 重新运行程序，效果如下： 11.3 使用百度地图11.3.1 让地图显示出来 要让地图显示出来，需要用到百度提供的自定义控件 MapView，在布局中添加如下： 123456789101112131415&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_map" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.wonderful.myfirstcode.chapter11.MapActivity"&gt; &lt;!-- 显示地图控件 --&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/map_view" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true"/&gt;&lt;/RelativeLayout&gt; 接下来，编写活动中的代码如下： 1234567891011121314151617181920212223242526272829303132public class MapActivity extends AppCompatActivity &#123; private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 初始化操作，在 setContentView() 方法前调用 SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_map); mapView = (MapView) findViewById(R.id.map_view); &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mapView.onDestroy(); &#125;&#125; 上述代码，需要重写 onResume()、onPause()、onDestroy() 这3个方法，保证资源能够及时释放。 运行效果如下： 11.3.4 移动到我的位置 百度 LBS SDK 的 API 中提供了一个 BaiduMap 类，是地图的总控制器，有了它就能对地图进行各种各样的操作了。获取其实例如下： 1BaiduMap baiduMap = mapView.getMap(); 百度地图将缩放级别的取值范围限定在3到19之间，也可取小数点位，值越大地图显示信息越精细，如把缩放级别设置成12.5，可以这样写： 12MapStatusUpdate update = MapStatusUpdateFactory.zoomTo(12.5f);baiduMap.animateMapStatus(update); 若要让地图移动到某个经纬度上，可以借助 LatLng 类，如将地图移动到北纬39.915°、东经116.404°，可以这样写： 123LatLng ll = new LatLng(39.915,116.404);MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);baiduMap.animateMapStatus(update); 接下来实现下 “移动到我的位置” 这个功能，修改活动中代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MapActivity extends AppCompatActivity &#123; private LocationClient mLocationClient; private MapView mapView; private BaiduMap baiduMap; // 避免多次调用animateMapStatus() 方法 private boolean isFirstLocate = true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient = new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_map); mapView = (MapView) findViewById(R.id.map_view); baiduMap = mapView.getMap(); . . . &#125; /** * 把地图移动到当前位置 * @param location */ private void navigateTo(BDLocation location)&#123; if (isFirstLocate)&#123; LatLng ll = new LatLng(location.getLatitude(),location.getLongitude()); MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll); baiduMap.animateMapStatus(update); update = MapStatusUpdateFactory.zoomTo(16f); baiduMap.animateMapStatus(update); isFirstLocate = false; &#125; &#125; // 监听器 public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; if (bdLocation.getLocType() == BDLocation.TypeGpsLocation || bdLocation.getLocType() == BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; &#125; &#125; . . .&#125; 11.3.3 让“我”显示在地图上 百度 LBS SDK 当中提供了一个 MyLocationData.Builder 类，这个类是用来封装设备当前所在位置的，只需将经纬度信息传入到它相应的方法就可以，如下： 123MyLocationData.Builder locationBuilder = new MyLocationData.Builder();locationBuilder.latitude(39.915);locationBuilder.longitude(116.404); 设置完要封装的信息后调用 MyLocationData.Builder 类中的 build() 方法，就会生成一个 MyLocationData 实例，把这个实例传入到 BaiduMap 的 setMyLocationData() 方法中，就可以让设备当前位置显示在地图上了，如下： 12MyLocationData locationData = locationBuilder.build();baiduMap.setMyLocationData(locationData); 下面贴上完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class MapActivity extends AppCompatActivity &#123; private LocationClient mLocationClient; private MapView mapView; private BaiduMap baiduMap; private boolean isFirstLocate = true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient = new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_map); mapView = (MapView) findViewById(R.id.map_view); baiduMap = mapView.getMap(); baiduMap.setMyLocationEnabled(true); // 声明权限，将权限添加到list集合中再一次性申请 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); if (ActivityCompat.checkSelfPermission(MapActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ActivityCompat.checkSelfPermission(MapActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ActivityCompat.checkSelfPermission(MapActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (!permissionList.isEmpty()) &#123; String[] permissions = permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MapActivity.this,permissions,1); &#125;else &#123; requestLocation(); &#125; &#125; /** * 开始地理位置定位 */ private void requestLocation() &#123; initLocation(); mLocationClient.start(); &#125; private void initLocation() &#123; LocationClientOption option = new LocationClientOption(); option.setScanSpan(5000); //5秒钟更新下当前位置 option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 )&#123; for (int result : grantResults)&#123; if (result != PackageManager.PERMISSION_GRANTED)&#123; ToastUtils.showShort("必须同意所有权限才能使用本程序"); finish(); return; &#125; &#125; requestLocation(); &#125;else &#123; ToastUtils.showShort("发生未知错误"); finish(); &#125; break; default: break; &#125; &#125; /** * 把地图移动到当前位置 * @param location */ private void navigateTo(BDLocation location)&#123; if (isFirstLocate)&#123; LatLng ll = new LatLng(location.getLatitude(),location.getLongitude()); MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll); baiduMap.animateMapStatus(update); update = MapStatusUpdateFactory.zoomTo(16f); baiduMap.animateMapStatus(update); isFirstLocate = false; &#125; MyLocationData.Builder locationBuilder = new MyLocationData.Builder(); locationBuilder.latitude(location.getLatitude()); locationBuilder.longitude(location.getLongitude()); MyLocationData locationData = locationBuilder.build(); baiduMap.setMyLocationData(locationData); &#125; // 监听器 public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; if (bdLocation.getLocType() == BDLocation.TypeGpsLocation || bdLocation.getLocType() == BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; &#125; &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125;&#125; 关于百度 LBS SDK 的用法入门就介绍到这，更多用法参考官方网站：http://lbsyun.baidu.com/ 。建议根据官网开发指南来进行学习。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础10-探究服务（下）]]></title>
    <url>%2F2015%2F12%2F31%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8010-%E6%8E%A2%E7%A9%B6%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[**本篇文章主要介绍以下几个知识点： 服务的实践应用。 10.5 服务的最佳实践——完整版的下载示例 本节来综合运用一下，实现一个在服务中经常使用到的功能——下载。效果如下： 首先添加网络请求依赖库： 1compile 'com.squareup.okhttp3:okhttp:3.5.0' 接下来需要定义一个回调接口，用于对下载过程中的各种状态进行监听和回调，新建 DownloadListener 接口： 123456789101112131415161718/** * Function：回调接口，对下载过程中的各种状态进行监听和回调 * Author：kxwon on 2017/1/22 19:09 * Email：kxwonder@163.com */public interface DownloadListener &#123; void onProgress(int progress); // 下载进度 void onSuccess(); // 下载成功 void onFailed(); // 下载失败 void onPaused(); // 下载暂停 void onCanceled(); // 下载取消&#125; 回调接口定义好后，下面就开始编写下载功能了，这里用 AsyncTask 来实现，新建一个 DownloadTask 继承自 AsyncTask： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167public class DownloadTask extends AsyncTask&lt;String,Integer,Integer&gt;&#123; public static final int TYPE_SUCCESS = 0; // 下载成功 public static final int TYPE_FAILED = 1; // 下载失败 public static final int TYPE_PAUSED = 2; // 下载暂停 public static final int TYPE_CANCELED = 3; // 下载取消 private DownloadListener listener; private boolean isCanceled = false; private boolean isPaused = false; private int lastProgress;//上一次的下载进度 public DownloadTask(DownloadListener listener)&#123; this.listener = listener; &#125; /** * 用于在后台执行具体的下载逻辑 * @param params * @return */ @Override protected Integer doInBackground(String... params) &#123; InputStream is = null; RandomAccessFile savedFile = null; File file = null; try&#123; long downloadedLength = 0;// 记录已下载的文件长度 String downloadUrl = params[0];//获取到下载的URL地址 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/"));//下载的文件名 String directory = Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_DOWNLOADS).getPath();//将文件下载到指定目录 file = new File(directory + fileName); if (file.exists())&#123; downloadedLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl);//获取待下载文件的总长度 if (contentLength == 0)&#123; return TYPE_FAILED; &#125;else if (contentLength == downloadedLength)&#123; // 已下载字节和文件总字节相等，说明已经下载完成了 return TYPE_SUCCESS; &#125; // 发送网络请求，从网络读取数据写入到本地，直到文件下载完 OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 断点下载，指定从哪个字节开始下载 .addHeader("RANGE","bytes=" + downloadedLength + "-") .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null)&#123; is = response.body().byteStream(); savedFile = new RandomAccessFile(file,"rw"); savedFile.seek(downloadedLength);//跳过已下载的字节 byte[] b = new byte[1024]; int total = 0; int len; while ((len = is.read(b)) != -1)&#123; if (isCanceled)&#123; return TYPE_CANCELED; &#125;else if (isPaused)&#123; return TYPE_PAUSED; &#125;else &#123; total += len; savedFile.write(b,0,len); // 计算已下载的百分比 int progress = (int)((total + downloadedLength) * 100/contentLength); publishProgress(progress);//通知当前的下载进度 &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (is != null)&#123; is.close(); &#125; if (savedFile != null)&#123; savedFile.close(); &#125; if (isCanceled &amp;&amp; file != null)&#123; file.delete(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; return TYPE_FAILED; &#125; /** * 用于在界面上更新当前的下载速度 * @param values */ @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0];//当前的下载进度 if (progress &gt; lastProgress)&#123; listener.onProgress(progress);//通知下载进度更新 lastProgress = progress; &#125; &#125; /** * 用于通知最终的下载结果 * @param integer */ @Override protected void onPostExecute(Integer integer) &#123; switch (integer)&#123; case TYPE_SUCCESS: listener.onSuccess();//下载成功 break; case TYPE_FAILED: listener.onFailed();//下载失败 break; case TYPE_PAUSED: listener.onPaused();//下载暂停 break; case TYPE_CANCELED: listener.onCanceled();//下载取消 break; default: break; &#125; &#125; /** * 暂停 */ public void pauseDownload()&#123; isPaused = true; &#125; /** * 取消 */ public void cancelDownload()&#123; isCanceled = true; &#125; /** * 获取待下载文件的总长度 * @param downloadUrl * @return */ private long getContentLength(String downloadUrl) throws IOException&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful())&#123; long contentLength = response.body().contentLength(); response.close(); return contentLength; &#125; return 0; &#125;&#125; 以上就把具体的下载功能完成了，下面为了保证 DownloadTask 可以一直在后台运行，还需创建一个下载的服务。新建 DownloadService 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class DownloadService extends Service &#123; private DownloadTask downloadTask; private String downloadUrl; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification("Downloading ...",progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1,getNotification("Download Success",-1)); ToastUtils.showShort("下载成功"); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1,getNotification("Download Failed",-1)); ToastUtils.showShort("下载失败"); &#125; @Override public void onPaused() &#123; downloadTask = null; ToastUtils.showShort("下载暂停"); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); ToastUtils.showShort("下载取消"); &#125; &#125;; public DownloadService() &#123; &#125; private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder&#123; /** * 开始下载 * @param url */ public void startDownload(String url)&#123; if (downloadTask == null)&#123; downloadUrl = url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification("Downloading ...",0)); ToastUtils.showShort("Downloading ..."); &#125; &#125; /** * 暂停下载 */ public void pauseDownload()&#123; if (downloadTask != null)&#123; downloadTask.pauseDownload();; &#125; &#125; /** * 取消下载 */ public void cancelDownload()&#123; if (downloadTask != null)&#123; downloadTask.cancelDownload(); &#125;else &#123; if (downloadUrl != null)&#123; // 取消下载时需要将文件删除，并且通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/")); String directory = Environment.getExternalStoragePublicDirectory (Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if (file.exists())&#123; file.delete(); &#125; &#125; &#125; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; /** * 构建通知方法 */ private Notification getNotification(String title,int progress)&#123; Intent intent = new Intent(this,DownloadActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if (progress &gt; 0)&#123; // 当progress大于或等于0时才需要显示下载进度 builder.setContentText(progress + "%"); // 三个参数：通知的最大进度、通知的当前进度、是否使用模糊进度条 builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; 现在下载的服务已实现，后端的工作基本完成，接下来就开始编写前端的部分。在布局中放置3个按钮，分别用于开始下载、暂停下载、取消下载，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class DownloadActivity extends AppCompatActivity implements View.OnClickListener &#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (DownloadService.DownloadBinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_download); Button start_download = (Button) findViewById(R.id.start_download); Button pause_download = (Button) findViewById(R.id.pause_download); Button cancel_download = (Button) findViewById(R.id.cancel_download); start_download.setOnClickListener(this); pause_download.setOnClickListener(this); cancel_download.setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent);//启动服务 bindService(intent,connection,BIND_AUTO_CREATE);//绑定服务 if (ContextCompat.checkSelfPermission(DownloadActivity.this, android.Manifest. permission.WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(DownloadActivity.this,new String[]&#123;android.Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125; &#125; @Override public void onClick(View v) &#123; if (downloadBinder == null)&#123; return; &#125; switch (v.getId())&#123; // 开始下载 case R.id.start_download: String url = "https://raw.githubusercontent.com/guolindev/eclipse/" + "master/eclipse-inst-win64.exe"; downloadBinder.startDownload(url); break; // 暂停下载 case R.id.pause_download: downloadBinder.pauseDownload(); break; // 取消下载 case R.id.cancel_download: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED)&#123; ToastUtils.showShort("拒绝权限将无法使用程序"); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection);//解绑服务 &#125;&#125; 最后，别忘了声明权限： 1234&lt;!-- 访问SD卡权限 --&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;&lt;!-- 访问网络权限 --&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 以上，就是整个的下载示例。 本章完结。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础10-探究服务（中）]]></title>
    <url>%2F2015%2F12%2F21%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8010-%E6%8E%A2%E7%A9%B6%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 服务的基本用法 服务的生命周期 服务的其他用法 10.2 服务的基本用法 服务（Service）是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求长期运行的任务。 服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。 服务并不会自动开启线程，所有代码默认运行在主线程中。 10.2.1 定义一个服务 在项目中定义一个服务：在 Android Studio 中右击 com.wonderful.myfirstcode.chapter10.service包（你项目所在的包名）→New→Service→Service，会弹出如下窗口： 上面将服务命名为 MyService，Exported 表示是否允许除了当前程序之外的其他程序访问这个服务，Enabled 表示是否启用这个服务。完成创建后的 MyService 如下： 12345678910public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125;&#125; 可以看到，onBind() 方法是 Service 中唯一的一个抽象方法，必须在子类中实现。在服务中添加处理事情的逻辑还要重写 Service 中的另外一些方法，如下： 1234567891011121314151617181920212223242526272829303132public class MyService extends Service &#123; . . . /** * 在服务创建时调用 */ @Override public void onCreate() &#123; super.onCreate(); Log.d("------MyService------", "onCreate: "); &#125; /** * 在每次服务启动时调用 * 若服务一旦启动就立刻执行某个动作，可以将逻辑写在此方法中 */ @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d("------MyService------", "onStartCommand: "); return super.onStartCommand(intent, flags, startId); &#125; /** * 在服务销毁时调用，回收不再使用的资源 */ @Override public void onDestroy() &#123; super.onDestroy(); Log.d("------MyService------", "onDestroy: "); &#125;&#125; 另外需注意的是，每一个服务都需要在 AndroidManifest.xml 文件中进行注册才能生效（安卓四大组件的共有特点）。当然，刚才创建服务时 AS 已经自动帮我们注册好了： 1234567891011121314151617181920&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.wonderful.myfirstcode"&gt; &lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; . . . &lt;service android:name=".chapter10.service.MyService" android:enabled="true" android:exported="true"&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 以上，就将一个服务定义好了。 10.2.2 启动和停止服务 启动和停止服务的方法主要是借助 Intent 来实现的。下面就在项目中尝试去启动和停止服务。 在布局中添加两个按钮，分别用于启动和停止服务： 1234567891011121314151617181920212223242526272829public class MyServiceActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_service); Button start_service = (Button) findViewById(R.id.start_service); Button stop_service = (Button) findViewById(R.id.stop_service); start_service.setOnClickListener(this); stop_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.start_service: Intent startIntent = new Intent(this,MyService.class); startService(startIntent);// 启动服务 break; case R.id.stop_service: Intent stopIntent = new Intent(this,MyService.class); stopService(stopIntent);// 停止服务 break; default: break; &#125; &#125;&#125; 上述代码，启动服务 startService() 和停止服务 stopService() 方法都是定义在 Context 类中的，在活动里可以直接调用。当然，停止服务也可以在 MyService 的任何一个位置调用 stopSelf() 方法，让服务自己停止下来。 运行程序，点击启动服务，打印日志如下： 点击停止服务，打印日志如下： 值得注意的是，onCreate() 在服务第一次创建时调用，onStartCommand() 在每次启动服务时都会调用，上面第一次点击启动服务时两个方法都会执行，之后再点击启动服务按钮就只有 onStartCommant() 方法执行了。 10.2.3 活动和服务进行通信 上面一节中，虽然服务在活动里启动，但启动之后活动与服务就没什么关系了。若要在活动中指定服务做什么，就要借助服务里面的 onBind() 方法了。 下面举个例子，若在 MyService 里提供一个下载功能，然后在活动中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的 Binder 对象来对下载功能进行管理，如下： 1234567891011121314151617181920212223public class MyService extends Service &#123; private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder&#123; // 模拟开始下载方法 public void startDownload()&#123; Log.d("------MyService------", "startDownload: "); &#125; // 模拟查看下载进度方法 public int getProgress()&#123; Log.d("------MyService------", "getProgress: "); return 0; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; . . .&#125; 接着在布局中添加两个按钮，用于绑定服务和取消绑定服务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyServiceActivity extends AppCompatActivity implements View.OnClickListener&#123; private MyService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 服务绑定成功后调用 downloadBinder = (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; // 服务解除绑定后调用 &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_service); Button bind_service = (Button) findViewById(R.id.bind_service); Button unbind_service = (Button) findViewById(R.id.unbind_service); bind_service.setOnClickListener(this); unbind_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bind_service: Intent bindIntent = new Intent(this,MyService.class); // 绑定服务，三个参数：Intent对象、ServiceConnection实例、标志位 // (BIND_AUTO_CREATE 表示活动和服务绑定后自动创建服务) bindService(bindIntent,connection,BIND_AUTO_CREATE); break; case R.id.unbind_service: // 解绑服务 unbindService(connection); break; default: break; &#125; &#125;&#125; 上述代码，首先创建了一个 ServiceConnection 的匿名类，里面重写两个方法，在 onServiceConnected() 中获取 DownloadBinder 的实例，接下来就根据具体场景来调用 DownloadBinder 中的任何公共方法。 运行程序，点击绑定服务，打印日志如下： 点击解绑服务，打印日志如下： 值得注意的是，任何一个服务在整个应用程序内都是通用的，即 MyService 可以和任何一个活动进行绑定，而且绑定完成后都可以获取到相同的 DownloadBinder 实例。 10.3 服务的生命周期 前面使用到的 onCreate()、onStartCommand()、onBind()、onDestroy() 等方法都是在服务的生命周期内可能回调的方法，具体如下图所示： 值得注意的是，当我们对一个服务既调用了 startService() 方法，又调用了 bindService() 方法时，要同时调用 stopService() 和 unbindService() 方法，onDestroy() 方法才会执行。 10.4 服务的更多技巧10.4.1 使用前台服务 服务的优先级较低，当系统内存不足时，可能会回收正在后台运行的服务，若要避免被回收，可以考虑使用前台服务。 前台服务和普通服务的区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏可以看到更加详细的信息，类似于通知的效果。 创建一个前台服务如下： 1234567891011121314151617181920212223242526public class MyService extends Service &#123; . . . /** * 在服务创建时调用 */ @Override public void onCreate() &#123; super.onCreate(); Log.d("------MyService------", "onCreate: "); Intent intent = new Intent(this,MyServiceActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("这是标题") .setContentText("这是内容") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); //让MyService变成一个前台服务，并在系统状态栏显示出来 startForeground(1,notification); &#125; . . .&#125; 前台服务的用法就这么简单，和创建通知的方法类似。运行程序，点击开启服务或绑定服务，效果如下： 10.4.2 使用 IntentService 之前提到过服务中的代码都是默认运行在主线程当中，若直接在服务里处理耗时操作，容易出现 ANR（Application Not Responding）的情况。 为避免上述情况，应该在服务的每个具体的方法里开启一个子线程，在子线程里处理耗时操作。因此一个比较标准的服务可以写成如下形式： 1234567891011121314151617public class MyService extends Service &#123; . . . /** * 在每次服务启动时调用 */ @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125;&#125; 服务开启后会一直处于运行状态，必须调用 stopService() 或者 stopSelf() 才能停止服务，所以要实现一个服务在执行完毕后自动停止，可以这样写： 1234567891011@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 stopSelf(); &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId);&#125; 当然，为了可以简单地创建一个异步地、会自动停止地服务，Android 专门提供了一个 IntentService 类。 下面介绍下 IntentService 类的用法，创建一个 MyIntentService 类继承自 IntentService，如下： 12345678910111213141516171819202122public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService");//调用父类的有参构造函数 &#125; /** * 此方法在子线程中运行，可以处理一些具体的逻辑，且不用担心 ANR 问题 * @param intent */ @Override protected void onHandleIntent(Intent intent) &#123; // 打印当前线程的 id Log.d("MyIntentService", "onHandleIntent: 线程id是 "+ Thread.currentThread().getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService", "onDestroy: 服务停止"); &#125;&#125; 下面举个例子来证实下，在布局中添加个按钮用于启动 MyIntentService 这个服务，如下： 1234567891011121314151617181920212223public class MyServiceActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_service); Button start_intent_service = (Button) findViewById(R.id.start_intent_service); start_intent_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.start_intent_service: // 打印主线程的 id Log.d("MyServiceActivity", "onClick: 主线程id："+ Thread.currentThread().getId()); Intent intentService = new Intent(this,MyIntentService.class); startService(intentService); break; &#125; &#125;&#125; 不要忘了在 AndroidManifest.xml 里注册服务（当然也可以用 AS 提供的快捷方式创建服务）： 1&lt;service android:name=".chapter10.service.MyIntentService" /&gt; 运行程序，点击按钮，打印日志如下： 可以看到，MyIntentService 在运行完毕后自动停止了。 本篇文章介绍到这，下一小节进入服务的最佳实践。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础10-探究服务（上）]]></title>
    <url>%2F2015%2F12%2F15%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8010-%E6%8E%A2%E7%A9%B6%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 线程的基本用法。 异步消息处理机制。 使用 AsyncTask。 10.1 Android 多线程编程 当我们执行一些耗时操作，如发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求，若不将这类操作放在子线程中运行，会导致主线程被阻塞，从而影响软件的使用。下面就来学习下 Android 多线程编程。 10.1.1 线程的基本用法 Android 多线程编程并不比 Java 多线程编程特殊，基本都是使用相同的语法。 继承 Thread 类 新建一个类继承自 Thread，然后重写父类的 run() 方法： 123456789class MyThread extends Thread&#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125;// 启动线程，run()方法中的代码就会在子线程中运行了new MyThread().run(); 实现 Runnable 接口 新建一个类实现 Runnable 接口，启动再 new Thread()： 12345678910class MyThread2 implements Runnable&#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125; // 启动线程 MyThread2 myThread2 = new MyThread2(); new Thread(myThread2).start(); 当然也可用匿名类方式实现 Runnable 接口： 1234567// 匿名类方式实现new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125;).start(); 10.1.2 在子线程中更新 UI Android 的 UI 是线程不安全的，若想要更新应用程序的 UI 元素，必须在主线程中进行，否则会出现异常。 下面通过个例子来验证下。在布局中添加一个 TextView用于显示内容，一个 Button 用于点击后改变显示的内容： 123456789101112131415161718192021222324252627282930313233public class UpdateUITestActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button btn_change_text; private TextView tv_text; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_update_uitest); tv_text = (TextView) findViewById(R.id.tv_text); btn_change_text = (Button) findViewById(R.id.btn_change_text); btn_change_text.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; // 把显示内容“Hello world”改成“你好世界” tv_text.setText("你好世界"); &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 上述代码在 Button 的点击事件里开启了一个子线程，然后在子线程中更新 UI，运行程序，效果如下： 程序果然崩溃了，观察错误日志，可以看出是由于在子线程中更新UI导致的： 由此证实了 Android 不允许在子线程中进行 UI 操作。但有时候，必须在子线程中执行耗时操作，然后根据执行结果进行 UI 操作，这种情况就需要使用异步消息处理的方法。 Android 提供了一套异步消息处理机制，完美地解决了在子线程中进行 UI 操作地问题。修改上面代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class UpdateUITestActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button btn_change_text; private TextView tv_text; // 定义一个整型常量用于表示更新TextView这个动作 public static final int UPDATE_TEXT = 1; private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case UPDATE_TEXT: // 在这里可以进行 UI 操作 tv_text.setText("你好世界"); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_update_uitest); tv_text = (TextView) findViewById(R.id.tv_text); btn_change_text = (Button) findViewById(R.id.btn_change_text); btn_change_text.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; // 创建Message对象，并将它的what字段指定为UPDATE_TEXT Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message);//将Message对象发送出去 &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 重新运行程序，效果如下： 上面就是 Android 异步消息处理的基本用法，下面来分析下它的工作原理。 10.1.3 解析异步消息处理机制 Android 异步消息处理主要由4个部分组成：Message、Handler、MessageQueue、Looper。 Message Message 是在线程之间传递的消息，它可在内部携带少量的信息，用于在不同线程之间交换数据。 Handler Handler 主要是用于发送和处理消息的。发送消息一般用它的 sendMessage() 方法，发送的消息经过一系列地辗转处理后，最终传递到它的 handleMessage() 方法中。 MessageQueue MessageQueue是消息队列，主要用于存放所有通过 Handler 发送地消息。这部分消息会一直存放于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。 Looper Looper 是每个线程中 MessageQueue 的管家，调用 Looper.loop() 方法后，就会进入到一个无限循环中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程中也只会有一个 Looper 对象。 整个异步消息处理机制的流程如下： （1）在主线程中创建 Handler 对象，重写 handleMessage() 方法 （2）子线程进行UI操作时，创建 Message 对象，通过 Handler 发送这条消息 （3）Looper 从MessageQueue 中取出待处理消息 （4）最后分发回 Handler 的 handleMessage() 方法中。 由于 Handler 是在主线程中创建的，所以此时 handleMessage() 方法中的代码也会在主线程中运行，就可以进行 UI 操作了。 整个异步消息处理机制的流程示意图如下： 其核心思想就是一条 Message 经过一系列的辗转调用后，也就从子线程进入到主线程，从不能更新 UI 变成了可以更新 UI。 10.1.4 使用 AsyncTask 为了更方便在子线程中进行 UI 操作，Android 基于异步处理消息机制帮我们封装了一个工具：AsyncTask。 AsyncTask是个抽象类，使用它需要创建一个子类去继承它。在继承时可以为它指定3个泛型参数，用途如下： Params在执行 AsyncTask 时传入的参数，用于后台任务中使用 Progress后台任务执行时，若需在界面显示当前进度，则使用这里指定的泛型作为进度单位 Result当任务执行完毕后，若需对结果进行返回，则使用这里指定的泛型作为返回值类型 如一个简单的自定义 AsyncTask 如下： 123456// 第一个泛型参数Void 表示在执行AsyncTask时不需要传入参数给后台任务// 第二个泛型参数Integer 表示使用整型数据作为进度条显示单位// 第三个泛型参数Boolean 表示使用布尔型数据来反馈执行结果class DownloadTask extends AsyncTask&lt;Void,Integer,Boolean&gt;&#123; . . .&#125; 若要完善上面对任务的定制，还需要重写 AsyncTask 的几个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class DownloadTask extends AsyncTask&lt;Void,Integer,Boolean&gt; &#123; /** * 在后台任务执行前调用，用于一些界面上的初始化操作 */ @Override protected void onPreExecute() &#123; progressDialog.show(); // 显示进度对话框 &#125; /** * 在子线程中运行，在这处理所有耗时操作 * 注意：不可进行 UI 操作，若需要可调用 publishProgress(Progress...)方法来完成 * @param params * @return */ @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true)&#123; int downloadPercent = doDownload();// 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;= 100)&#123; break; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return true; &#125; /** * 当后台任务中调用了 publishProgress(Progress...)方法后调用 * 返回的数据会作为参数传递到此方法中，可利用返回的数据进行一些 UI 操作 * @param values */ @Override protected void onProgressUpdate(Integer... values) &#123; // 在这里更新下载速度 progressDialog.setMessage("Download " + values[0] + "%"); &#125; /** * 当后台任务执行完毕并通过 return 语句进行返回时调用 * @param result */ @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss();// 关闭进度对话框 if (result)&#123; ToastUtils.showShort("下载成功"); &#125;else &#123; ToastUtils.showShort("下载失败"); &#125; &#125;&#125; 简单来说，使用 AsyncTask 的诀窍就是，在 doInBackground() 方法中执行具体的耗时任务，在 onProgressUpdate() 方法中进行 UI 操作，在 onPostExecute() 方法中执行一些任务的收尾工作。 想要启动这个任务，添加如下代码即可： 1new DownloadTask().execute(); 本小节就介绍到这，后面会对下载这个功能完整的实现，下面一节会进入到本章的正题，服务。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《第一行代码》阅读笔记(5-9章)]]></title>
    <url>%2F2015%2F12%2F02%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(5-9%E7%AB%A0)%2F</url>
    <content type="text"><![CDATA[一.第五章(本章只理解了大概) 1.广播机制广播分为标准广播与有序广播标准广播直接分发到所有广播接收器有序广播依次分发到各个接收器 二.第六章1.将数据存入/取出文件两种模式MODE_PRIVATE(覆盖 默认用此)和MODE_APPEND(追加)，其余两种在4.2版被废弃不做介绍。注意：读取权限的申请？这里没提到，不过可能需要SD卡的读取权限。 2.SharedPreferences调用Activity中的getSharedPreferences(“name”,模式)方法获取到SharedPreferences.Editor对象 通过设置 key , value 方式存储键值对，最后调用apply方法保存。同理于取，不做介绍。 3.SQLite新建类继承于SQLiteOpenHelper，在onCreate方法中新建表 在onUpgrade方法中更新表，每次更新都会导致数据库数据清除，通过传入比之前更大的版本号自动调用onUpgrade方法。 添加数据 调用getWritableDatabase()方法获取数据库db实例化ContentValues插入键值对后再调用db直接插入其他不做介绍 同样也可以直接使用sql语句操作数据库eg.db.execSQL(“delete from xx where number &gt; ?”,new String[]{“500”}); 4.LitePal 数据库开源操作库(重点) 同样的有GreenDao首先导入库，‘org.litepal.android.core:1.3.2’接着在main目录下新建assets目录下新建litepal.xml 1234567&lt;litepal&gt; &lt;dbname value = "name"&gt;&lt;/dbname&gt; &lt;version value = "1"&gt;&lt;/version&gt; &lt;list&gt; &lt;/list&gt;&lt;litepal&gt; 接下来配置 AndroidManifest.xml ,在application标签下面的 android:name=”org.litepal.LitePalApplication” 使用 首先，新建对应表的实体类(类—&gt;表 一个类对应一张表)。接着在litepal.xml中配置12345678&lt;litepal&gt; &lt;dbname value = "name"&gt;&lt;/dbname&gt; &lt;version value = "1"&gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class = "com.example.xxx.class"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;litepal&gt; eg.创建数据库 Connector.getDatabase()插入数据123Class xx = new Class();....(设置数据)xx.save(); 同理于其他 不予列举 三.第七章1.内容提供器内容提供器是不同应用之间共享数据的渠道 2.Android权限机制Android权限分为普通权限和危险权限，普通权限由系统之间授权，危险权限需要示意用户是否给予权限。 四.第八章本章讲调用系统组件(相机，相册等)，未仔细阅读。 五.第九章注意本章要申请网络权限 1.WebView使用方法2.HTTP协议访问HTTP协议访问网络属于底层实现，现在常用封装好的库来代替 ，但也必须了解。首先，网络属于耗时操作，只能在子线程中运行几个主要的点12345678Url url = new Url("");HttpConnection connection = new HttpConnection ();connection .setRequestMethod("GET/POST");connection .setConnectionTimeout(8000(ms));connection .setReadTimeout(8000(ms));InputStream in = connection.getInputStream();BufferedReader reader = new BufferedReader( new InputStreamReader(in) );//处理reader就可以了 3.使用OkHttpokhttp是Square公司的开源网络库，类似的有Retrofit。主要操作1234567891011121314OkHttpClient client = new OkHttpClient();//请求主体Request request = new Request.Builder() //request对象 .url("url") .builder();Response response = client.newCall(request).execute(); //发送请求//-------------------------Post提交------------------------------------//RequestBody requestBody = new FormBody.Builder() .add("key","value") .builder();Request request = new Request.Builder() .url("url") .post(requestBody ) .builder(); 4.解析XML三种方式：Pull，SAX，DOM(此书未提及) 5.解析Json多种方式，书上主要写JSONObject，GSON还有一种常用的为FastJson由于我习惯用Gson所以这里我稍微介绍下Gson。 用Gson解析Json首先要先根据Json构造对应的实体类，如果用Android Studio的话可以添加插件GsonFormat根据Json自动生成对应的实体类。 其次是用法1Class JsonClass = new Gson().fromJson(String,Class.class); 如果的List的话较为麻烦 (此处凭记忆打的可能有错,具体请百度)1List&lt;T&gt; list = new Gson().fromJson(json,new TypeToken&lt; List&lt;T&gt; &gt;() &#123;&#125;.getType() ); 完结]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《第一行代码》阅读笔记(1-4章)]]></title>
    <url>%2F2015%2F11%2F25%2F%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(1-4%E7%AB%A0)%2F</url>
    <content type="text"><![CDATA[一.第一章1. 四大组件活动(Activity):活动是与用户交互的界面 服务(Service):在后台运行，当用户退出应用的时候也能继续运行 广播接收器(broadcast receive):接受来自各处的广播，例如电话，短信。同时也能发出广播 内容提供器(Content Provider):应用之间的数据共享 二.第二章1.活动活动是与用户交互的界面，同时活动应在AndroidManiFest注册才能被打开 2.Toast3.Menu在res下新建文件夹menu，新建菜单重写onCreateOptionsMenu方法，导入菜单XML文件 在onOptionItemSelect方法下添加点击事件 4.Intent(显式/隐式/其他)5.活动(Activity)的生命周期！！！ 这个很重要当切换Activity的时候会执行onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume当Dialog悬浮前端时执行 onPause-&gt;onResume 6.活动的启动模式我的理解: 7.随时随地退出程序(活动管理器)专门创建一个活动管理器类，当要退出程序时遍历所有的活动，依次finish并从List中移除 第三章1.百分比布局compile com.android.support:percent:24.2.1 只有PercentFrameLayout与RelativeLayout 可以设置百分比宽高 方便自适应屏幕 2.自定义控件首先，创建自定义控件，继承于ViewGroup或者其子类 在构造方法中加载布局其次，若要在XML中设置属性，必须在某个(我忘了)XML中设置属性，并在类中对应设置 3.ListView的使用首先，每个Item都是一个布局，使用先写item.xml其次，要新建适配器，继承BaseAdapter 重写对应方法接着，在getView中加载子项Item布局，同时填充Item数据 如何提升ListView效率?新建内部类对应Item视图的ViewHolder通过判断converView觉得是否加载布局(复用converView)，同时也是这一步经常会出现复用bug同时，每次将ViewHolder设置入converView中。 关于ListView的点击事件，直接在onItemClickListener中设置对应Item的点击数据 4.RecyclerView的使用参考我另一篇文章RecyclerView的基本用法 四.第四章1.Fragment的生命周期 2.关于FragmentManager与FragmentTransaction完结]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础9-网络技术]]></title>
    <url>%2F2015%2F11%2F12%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8009-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以几下个知识点： 使用 HTTP 协议访问网络：使用 HttpURLConnection 和 OKHttp； 解析 XML 格式数据：Pull 和 SAX 解析； 解析 JSON 数据： JSONObject 和 GSON 解析。 9.1 使用 HTTP 协议访问网络 HTTP 协议，其工作原理很简单：客户端向服务器发出一条 HTTP 请求，服务器收到请求后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理。 9.1.1 使用 HttpURLConnection 下面学习 HttpURLConnection 的用法，其请求步骤代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * HttpURLConnection 发送请求 */ private void sendRequestWithHttpURLConnection() &#123; // 开启线程来发送网络请求 new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; BufferedReader reader = null; try&#123; URL url = new URL("http://www.baidu.com"); // 1. 获取 HttpURLConnection 实例 connection = (HttpURLConnection) url.openConnection(); // 2. 设置请求方法 connection.setRequestMethod("GET"); // 3. 自由定制，如设置连接超时、读取超时等 connection.setConnectTimeout(8000); connection.setReadTimeout(8000); // 4. 获取服务器返回的输入流 InputStream in = connection.getInputStream(); // 下面对获取到的输入流进行读取 reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine())!= null)&#123; response.append(line); &#125; showResponse(response.toString());// 显示请求结果 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if (reader != null)&#123; try&#123; reader.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; if (connection != null)&#123; // 5.把 HTTP 连接关掉 connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; 别忘了声明网络权限： 1&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 若是想要提交数据给服务器只需把请求方法改为 POST，并在获取输入流之前把要提交的数据写出即可。注意每条数据要以键值对的形式存在，数据与数据之间用 “&amp;” 隔开，比如向服务器提交用户名和密码可写成： 123connection.setRequestMethod("POST");DataOutputStream out = new DataOutputStream(connection.getOutputStream());out.writeBytes("username=admin&amp;password=123456"); 9.1.2 使用 OKHttp 接下来学习下网络请求开源项目 OKHttp，其项目主页地址是：https://github.com/square/okhttp 在使用 OKHttp 前，需要在项目中添加 OKHttp 库的依赖，如下： 1compile 'com.squareup.okhttp3:okhttp:3.5.0' 下面学习 OKHttp 请求步骤，如下： 1234567891011121314151617181920212223/** * OKHttp 发送请求 */ private void sendRequestWithOKHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; // 1. 创建 OkHttpClient 实例 OkHttpClient client = new OkHttpClient(); // 2. 创建 Request 对象 Request request = new Request.Builder().url("http://www.baidu.com").build(); // 3. 调用 OkHttpClient 的 newCall() 方法来创建 Call 对象 Response response = client.newCall(request).execute(); // 4. 获取返回的内容 String responseData = response.body().string(); showResponse(responseData);// 显示请求结果 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; 相比 HttpURLConnection，OKHttp 简单易用，若是发起一条 POST 请求，会比 GET 请求稍微复杂点，需要构建一个 RequestBody 对象来存放待提交的参数： 1234RequestBody requestBody = new FormBody.Builder() .add("username","admin") .add("password","123456") .build(); 然后在 Request.Builder 中调用一下 post() 方法，并将 RequestBody 对象传入： 1234Request request = new Request.Builder() .url("http://www.baidu.com") .post(RequestBody) .build(); 9.1.3 网络编程的最佳实践 在实际开发中，我们通常将这些通用的网络操作提取到一个公共类里，接下来就简单封装下网络操作。 首先针对 HttpURLConnection 定义一个回调接口： 1234public interface HttpCallbackListener &#123; void onFinish(String response);// 请求成功时调用 void onError(Exception e);// 请求失败时调用&#125; 接着编写工具类 HttpUtil： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class HttpUtil &#123; /** * 用 HttpURLConnection 发送请求 * @param address * @param listener */ public static void sendHttpRequest(final String address,final HttpCallbackListener listener)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; try&#123; URL url = new URL(address); // 1. 获取 HttpURLConnection 实例 connection = (HttpURLConnection) url.openConnection(); // 2. 设置请求方法 connection.setRequestMethod("GET"); // 3. 自由定制，如设置连接超时、读取超时等 connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); // 4. 获取服务器返回的输入流 InputStream in = connection.getInputStream(); // 下面对获取到的输入流进行读取 BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine())!= null)&#123; response.append(line); &#125; if (listener != null)&#123; // 回调 onFinish() 方法 listener.onFinish(response.toString()); &#125; &#125;catch (Exception e)&#123; if (listener != null)&#123; // 回调 onError() 方法 listener.onError(e); &#125; &#125;finally &#123; if (connection != null)&#123; // 5.把 HTTP 连接关掉 connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; /** * 用 OKHttp 发送请求 * @param address * @param callback */ public static void sendOKHttpRequest(String address, Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(address).build(); client.newCall(request).enqueue(callback); &#125;&#125; 这时候用 HttpURLConnection 发送请求就可以写成： 1234567891011HttpUtil.sendHttpRequest(address, new HttpCallbackListener() &#123; @Override public void onFinish(String response) &#123; // 在这里根据返回内容执行具体的逻辑 &#125; @Override public void onError(Exception e) &#123; // 在这里对异常情况进行处理 &#125;&#125;); 用 OKHttp 发送请求就可以写成： 123456789101112HttpUtil.sendOKHttpRequest("http://www.baidu.com", new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; // 在这里对异常情况进行处理 &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; // 得到服务器返回的具体内容 String responseData = response.body().string(); &#125; &#125;); 另外需要注意的是，不管是使用 HttpURLConnection 还是 OKHttp，最终回调接口都还是在子线程中运行的。 下面举个例子巩固下，在布局中放置 Button 用于发送 HTTP 请求，放置一个 TextView 用于显示服务器返回的数据，主要代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class HttpActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button send_url_request,send_okHttp_request,clear_content; private TextView response_text; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_http); response_text = (TextView) findViewById(R.id.response_text); send_url_request = (Button) findViewById(R.id.send_url_request); send_okHttp_request = (Button) findViewById(R.id.send_okHttp_request); clear_content = (Button) findViewById(R.id.clear_content); send_url_request.setOnClickListener(this); send_okHttp_request.setOnClickListener(this); clear_content.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.send_url_request: sendRequestWithHttpURLConnection(); case R.id.send_okHttp_request: sendRequestWithOKHttp(); case R.id.clear_content: showResponse(""); //清空数据 &#125; &#125; /** * OKHttp 发送请求 */ private void sendRequestWithOKHttp() &#123; HttpUtil.sendOKHttpRequest("http://www.baidu.com", new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; // 在这里对异常情况进行处理 &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; // 得到服务器返回的具体内容 String responseData = response.body().string(); showResponse(responseData); &#125; &#125;); &#125; /** * HttpURLConnection 发送请求 */ private void sendRequestWithHttpURLConnection() &#123; HttpUtil.sendHttpRequest("http://www.baidu.com", new HttpCallbackListener() &#123; @Override public void onFinish(String response) &#123; // 在这里根据返回内容执行具体的逻辑 showResponse(response); &#125; @Override public void onError(Exception e) &#123; // 在这里对异常情况进行处理 &#125; &#125;); &#125; /** * 显示请求结果 * @param response */ private void showResponse(final String response) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; // 在这里进行UI 操作，将结果显示到界面上 response_text.setText(response); &#125; &#125;); &#125;&#125; 运行效果如下： 9.2 解析 XML 格式数据 在网络上传输数据时最常用的格式有两种：XML 和 JSON。本节来学习下如何解析 XML 格式的数据。 解析 XML 格式的数据有多种方式，这里主要介绍 Pull 解析和 SAX 解析。解析前先来看看等下要解析的 XML 文本： 9.2.1 Pull 解析方式 Pull 解析整个过程比较简单，具体看代码注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * pull 解析 * @param xmlData 要解析的xml数据 */ private void parseXMLWithPull(String xmlData) &#123; try &#123; // 1. 获取 XmlPullParserFactory 实例 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); // 2. 借助 XmlPullParserFactory 实例得到 XmlPullParser 对象 XmlPullParser xmlPullParser = factory.newPullParser(); // 3. 调用 setInput() 方法设置xml数据 xmlPullParser.setInput(new StringReader(xmlData)); // 4. 获取当前的解析事件 int eventType = xmlPullParser.getEventType(); String id = ""; String name = ""; String sex = ""; // 5. 通过 while 循环不断地进行解析 while (eventType != XmlPullParser.END_DOCUMENT)&#123; String nodeName = xmlPullParser.getName(); switch (eventType)&#123; // 开始解析某个节点 case XmlPullParser.START_TAG: if ("id".equals(nodeName))&#123; id = xmlPullParser.nextText(); &#125;else if ("name".equals(nodeName))&#123; name = xmlPullParser.nextText(); &#125;else if ("sex".equals(nodeName))&#123; sex = xmlPullParser.nextText(); &#125; break; // 完成解析某个节点 case XmlPullParser.END_TAG: if ("student".equals(nodeName))&#123; Log.d("pull解析：", "id is" + id); Log.d("pull解析：", "name is" + name); Log.d("pull解析：", "sex is" + sex); &#125; break; default: break; &#125; // 获取下一个解析事件 eventType = xmlPullParser.next(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 9.2.2 SAX 解析方式 SAX 解析的用法比 Pull 解析要复杂些，但在语义方面会更加清楚。 用 SAX 解析需要建一个类继承 DefaultHandler，并重写父类的5个方法。为实现上面同样的功能，新建一个 ContentHandler 类，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class ContentHandler extends DefaultHandler &#123; private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder sex; /** * 开始 XML 解析时调用 * @throws SAXException */ @Override public void startDocument() throws SAXException &#123; id = new StringBuilder(); name = new StringBuilder(); sex = new StringBuilder(); &#125; /** * 开始解析某个节点时调用 * @param uri * @param localName * @param qName * @param attributes * @throws SAXException */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; // 记录当前节点名 nodeName = localName; &#125; /** * 获取节点中的内容时调用 * @param ch * @param start * @param length * @throws SAXException */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 根据当前节点名判断将内容添加到哪一个 StringBuilder 对象中 if ("id".equals(nodeName))&#123; id.append(ch,start,length); &#125;else if ("name".equals(nodeName))&#123; name.append(ch,start,length); &#125;else if ("sex".equals(nodeName))&#123; sex.append(ch,start,length); &#125; &#125; /** * 完成解析某个节点时调用 * @param uri * @param localName * @param qName * @throws SAXException */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if ("student".equals(localName))&#123; Log.d("sax解析：", "id is" + id.toString().trim()); Log.d("sax解析：", "name is" + name.toString().trim()); Log.d("sax解析：", "sex is" + sex.toString().trim()); // 最后要将 StringBuilder 清空掉 id.setLength(0); name.setLength(0); sex.setLength(0); &#125; &#125; /** * 完成整个 XML 解析时调用 * @throws SAXException */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125;&#125; 接下来就非常简单了，代码如下： 12345678910111213141516171819/** * sax 解析 * @param xmlData */ private void parseXMLWithSAX(String xmlData)&#123; try &#123; // 创建 SAXParserFactory 对象 SAXParserFactory factory = SAXParserFactory.newInstance(); // 获取 XMLReader 对象 XMLReader xmlReader = factory.newSAXParser().getXMLReader(); ContentHandler handler = new ContentHandler(); // 将 ContentHandler 的实例设置到 XMLReader 中 xmlReader.setContentHandler(handler); // 开始执行解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 9.2.3 举个例子实在点 下面在布局中放置两个按钮，分别进行pull解析和sax解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ParseXMLActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button btn_pull,btn_sax; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_parse_xml); btn_pull = (Button) findViewById(R.id.btn_pull); btn_sax = (Button) findViewById(R.id.btn_sax); btn_pull.setOnClickListener(this); btn_sax.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_pull: HttpUtil.sendOKHttpRequest("http://10.0.2.2/get_data.xml", new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; //ToastUtils.showShort("请求失败"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseData = response.body().string(); parseXMLWithPull(responseData); // pull 解析 &#125; &#125;); break; case R.id.btn_sax: HttpUtil.sendOKHttpRequest("http://10.0.2.2/get_data.xml", new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; //ToastUtils.showShort("请求失败"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseData = response.body().string(); parseXMLWithSAX(responseData); // sax 解析 &#125; &#125;); break; &#125; &#125; /** * pull 解析 * @param xmlData 要解析的xml数据 */ private void parseXMLWithPull(String xmlData) &#123; . . . &#125; /** * sax 解析 * @param xmlData */ private void parseXMLWithSAX(String xmlData)&#123; . . . &#125;&#125; 运行程序，打印的日志分别如下： 可以看到，已经将 XML 数据成功解析出来了。 9.3 解析 JSON 数据 类似的，解析 JSON 格式的数据有多种方式，这里主要介绍官方提供的 JSONObject 和谷歌的开源库 GSON 来解析。解析前先来看看等下要解析的 JSON 文本： 9.3.1 使用 JSONObject 使用 JSONObject 解析上面内容比较简单，具体看代码： 123456789101112131415161718192021/** * 用 JSONObject 解析 * @param jsonData 需要解析的数据 */ private void parseJSONWithJSONObject(String jsonData) &#123; try &#123; // 把需要解析的数据传入到 JSONArray 对象中 JSONArray jsonArray = new JSONArray(jsonData); for (int i = 0;i &lt; jsonArray.length();i++)&#123; JSONObject jsonObject = jsonArray.getJSONObject(i); String id = jsonObject.getString("id"); String name = jsonObject.getString("name"); String sex = jsonObject.getString("sex"); Log.d("JSONObject解析", "id is "+id); Log.d("JSONObject解析", "name is "+name); Log.d("JSONObject解析", "sex is "+sex); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 9.3.2 使用 GSON 接下来学习下开源库 GSON，其项目主页地址是：https://github.com/google/gson 在使用 GSON 前，需要在项目中添加 GSON 库的依赖，如下： 1compile 'com.google.code.gson:gson:2.8.0' GSON 可以将一段 JSON 格式的字符串自动映射成一个对象，从而不需要手动去编写代码进行解析了。 比如解析一段 JSON 格式数据： 1&#123;"name":"Tom","age":20&#125; 就可以定义一个 Person 类，并加入 name 和 age 两字段，然后只需调用如下代码就可以将 JSON 数据自动解析成一个 Person 对象： 12Gson gson = new Gson();Person person = gson.fromJson(jsonData,Person.class); 若解析一段 JSON 数组会麻烦些，需要借助 TypeToken 把期望解析成的数据类型传入到 fromJson() 方法中： 1List&lt;Person&gt; people = gson.fromJson(jsonData,new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType()); GSON 的基本用法就是这样。下面来解析上面的 JSON 文本，首先新增一个 Student 类： 123456789public class Student &#123; private String id; private String name; private String sex; // Getter and Setter . . .&#125; 接下来就非常简单了，代码如下： 12345678910111213/** * 用 GSON 解析 * @param jsonData */ private void parseJSONWithGSON(String jsonData)&#123; Gson gson = new Gson(); List&lt;Student&gt;studentList = gson.fromJson(jsonData,new TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType()); for (Student student:studentList)&#123; Log.d("GSON解析", "id is "+student.getId()); Log.d("GSON解析", "name is "+student.getName()); Log.d("GSON解析", "sex is "+student.getSex()); &#125; &#125; 9.3.3 举个例子实在点 下面在布局中放置两个按钮，分别用 JSONObject 和 GSON 进行 json 解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ParseJSONActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button btn_object,btn_gson; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_parse_json); btn_object = (Button) findViewById(R.id.btn_object); btn_gson = (Button) findViewById(R.id.btn_gson); btn_object.setOnClickListener(this); btn_gson.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_object: HttpUtil.sendOKHttpRequest("http://10.0.2.2/get_data.json", new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123;&#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseData = response.body().string(); parseJSONWithJSONObject(responseData); // 用 JSONObject 解析 &#125; &#125;); break; case R.id.btn_gson: HttpUtil.sendOKHttpRequest("http://10.0.2.2/get_data.json", new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123;&#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseData = response.body().string(); parseJSONWithGSON(responseData); // 用 GSON 解析 &#125; &#125;); break; &#125; &#125; /** * 用 JSONObject 解析 * @param jsonData 需要解析的数据 */ private void parseJSONWithJSONObject(String jsonData) &#123; . . . &#125; /** * 用 GSON 解析 * @param jsonData */ private void parseJSONWithGSON(String jsonData)&#123; . . . &#125;&#125; 运行程序，打印的日志分别如下： 关于网络编程先学习到这，下篇文章将进入安卓四大组件之服务的学习。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础8-手机多媒体]]></title>
    <url>%2F2015%2F10%2F28%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8008-%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 通知的使用； 调用系统相机拍照或调用相册选取照片； 播放多媒体文件。 8.1 使用通知 当某个应用程序希望向用户发送一些提示消息，而该应用程序又不在前台运行时，就可借助通知（Notification）来实现。 8.1.1 通知的基本用法 通知的用法灵活，既可以在活动里创建，也可在广播接收器里创建，还可在服务里创建。 无论在哪里创建通知，整体的步骤都是相同的。接下来学习下创建通知的步骤，代码如下： 1234567891011121314151617181920212223242526272829303132333435public class NotificationActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_notification); Button btn_send_notice = (Button) findViewById(R.id.btn_send_notice); btn_send_notice.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_send_notice: // 1. 获取 NotificationManager 实例来对通知进行管理 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); // 2. 使用 Builder 构造器来创建 Notification 对象 Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is content title") // 标题内容 .setContentText("This is content text") // 正文内容 .setWhen(System.currentTimeMillis()) // 通知被创建的时间 .setSmallIcon(R.mipmap.ic_launcher) // 通知的小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))// 通知的大图标 .build(); // 3. 显示通知. 其中notify()的两个参数：第一个是id,要保证为每个通知所指定的id都是不同的; // 第二个参数是 Notification 对象 manager.notify(1,notification); break; default: break; &#125; &#125;&#125; 上述代码，界面上就一个 发送通知 按钮，在按钮的点击事件里面完成了通知的创建工作。运行程序，点击按钮效果如下： 接下来实现通知的点击效果，这里要用到 PendingIntent ，即在某个合适的时机去执行某个动作。PendingIntent 实例可由 getActivity()、getBroadcast()、getServices() 等方法获取，其接收的参数：第一个是 Context；第二个一般用不到传0即可；第三个是 Intent 对象；第四个用于确定 PendingIntent 的行为，一般传0即可。 首先，准备好一个点击通知跳转的活动 NotificationTestActivity ，然后，修改 NotificationActivity 的代码如下： 12345678910111213141516171819202122232425262728293031public class NotificationActivity extends AppCompatActivity implements View.OnClickListener &#123; . . . @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_send_notice: Intent intent = new Intent(this,NotificationTestActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); // 1. 获取 NotificationManager 实例来对通知进行管理 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); // 2. 使用 Builder 构造器来创建 Notification 对象 Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is content title") .setContentText("This is content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) // 传入pi .build(); // 3. 显示通知 manager.notify(1,notification); break; default: break; &#125; &#125;&#125; 现在重新运行程序并点击按钮，效果如下： 细心的你会发现系统状态栏上的通知图标还没消失，解决方法有两种，一种是在 NotificationCompat.Builder 中再连缀一个 setAutoCancel() 方法，如下： 1234Notification notification = new NotificationCompat.Builder(this) . . . .setAutoCancel(true) .build(); 另外一种是显式调用 NotificationManager 的 cancel()方法，在点击通知跳转的活动 NotificationTestActivity 中添加如下代码： 1234567891011public class NotificationTestActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_notification_test); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(1); // 传入创建通知时指定的id &#125;&#125; 8.1.2 通知的进阶用法 上面提到了通知的基本用法，接下来介绍一些通知的其他技巧，比如： 在通知发出时播放一段音频，调用 setSound() 方法： 1234Notification notification = new NotificationCompat.Builder(this) . . . .setSound(Uri.fromFile(new File("/system/media/audio/ringtones/Luna.ogg"))) // 在音频目录下选个音频文件 .build(); 在通知到来时让手机振动，设置 vibrate 属性： 1234Notification notification = new NotificationCompat.Builder(this) . . . .setVibrate(new long[]&#123;0,1000,1000,1000&#125;) // 数组下标0表静止的时长，下标1表振动的时长，下标2表静止的时长，以此类推 .build(); 当然别忘了声明振动权限： 1&lt;uses-permission android:name="android.permission.VIBRATE" /&gt; 在通知到来时显式手机 LED 灯，调用 setLights() 方法： 1234Notification notification = new NotificationCompat.Builder(this) . . . .setLights(Color.GREEN,1000,1000) // 三个参数：LED 灯的颜色、灯亮时长、灯暗时长 .build(); 当然也可直接使用默认效果，如下： 1234Notification notification = new NotificationCompat.Builder(this) . . . .setDefaults(NotificationCompat.DEFAULT_ALL) .build(); 8.1.3 通知的高级功能 上面提到了通知的进阶用法，接下来介绍一些通知的高级功能，比如： NotificationCompat.Builder 类中的 setStyle() 方法 这个方法允许我们构建出富文本的通知内容，setStyle() 方法接收一个 NotificationCompat.style 参数，这个参数用来构造具体的富文本信息，如长文字、图片等。 在通知当中显示一段长文字，代码如下： 1234567Notification notification = new NotificationCompat.Builder(this) . . . // 在setStyle方法中创建NotificationCompat.BigTextStyle对象，调用其bigText()方法传入文字即可 .setStyle(new NotificationCompat.BigTextStyle().bigText("红红火火恍恍惚惚，" + "哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈呵呵，红红火火恍恍惚惚" + "哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈")) .build(); 效果如图所示： 在通知当中显示一张图片，代码如下： 12345Notification notification = new NotificationCompat.Builder(this) . . . .setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory. decodeResource(getResources(),R.drawable.big_image))))) .build(); 效果如图所示： NotificationCompat.Builder 类中的 setPriority() 方法 这个方法用于设置通知的重要程度，setPriority() 方法接收一个整型参数。 将通知的重要程度设置最高，代码如下： 123456Notification notification = new NotificationCompat.Builder(this) . . // 一共有5个常量可选：PRIORITY_DEFAULT默认、PRIORITY_MIN最低、PRIORITY_LOW较低、 // PRIORITY_HIGH较高、PRIORITY_MAX最高 .setPriority(NotificationCompat.PRIORITY_MAX) .build(); 效果如图所示： 8.2 调用摄像头和相册 调用摄像头拍照以及从相册中选择照片的相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192public class TakePhotoActivity extends AppCompatActivity &#123; private Button btn_take_photo; // 调用摄像头拍照 private Button btn_select_photo; // 从相册中选照片 private ImageView iv_show_photo; // 展示照片 public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private Uri imageUri; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_take_photo); btn_take_photo = (Button) findViewById(R.id.btn_take_photo); btn_select_photo = (Button) findViewById(R.id.btn_select_photo); iv_show_photo = (ImageView) findViewById(R.id.iv_show_photo); // 调用相机拍照 btn_take_photo.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 创建File对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),"output_image.jpg"); try&#123; if (outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; // 将File对象转换成Uri对象 if (Build.VERSION.SDK_INT &gt;= 24)&#123; // getUriForFile() 方法接收三个参数：Context对象、任意唯一的字符串、File对象 imageUri = FileProvider.getUriForFile(TakePhotoActivity.this, "com.wonderful." + "myfirstcode.chapter8.TakePhotoActivity.fileprovider",outputImage); &#125;else &#123; imageUri = Uri.fromFile(outputImage); &#125; // 启动相机程序 Intent intent = new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); // 打开相册选照片 btn_select_photo.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ActivityCompat.checkSelfPermission(TakePhotoActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(TakePhotoActivity.this, new String[]&#123;android.Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1); &#125;else &#123; // 若已授权，则直接执行打开相册的逻辑 openAlbum(); &#125; &#125; &#125;); &#125; /** * 打开相册 */ private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent,CHOOSE_PHOTO); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; ToastUtils.showShort("你拒绝了权限请求"); &#125; break; default: break; &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode)&#123; case TAKE_PHOTO: if (resultCode == RESULT_OK)&#123; try&#123; // 将拍摄的照片显示出来 Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); iv_show_photo.setImageBitmap(bitmap); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; &#125; case CHOOSE_PHOTO: if (resultCode == RESULT_OK)&#123; // 判断手机系统版本号 if (Build.VERSION.SDK_INT &gt;= 19)&#123; // 4.4及以上系统使用这个方法处理图片 handleImageOnKitKat(data); &#125;else &#123; // 4.4以下系统使用这个方法处理图片 handleImageBeforeKitKat(data); &#125; &#125; default: break; &#125; &#125; /** * 4.4及以上系统处理图片方法 * @param data */ @TargetApi(19) private void handleImageOnKitKat(Intent data) &#123; String imagePath = null; Uri uri = data.getData(); if (DocumentsContract.isDocumentUri(this,uri))&#123; // 若是document类型的Uri，则通过document id 处理 String docId = DocumentsContract.getDocumentId(uri); if ("com.android.providers.media.documents".equals(uri.getAuthority()))&#123; String id = docId.split(":")[1];// 解析出数字格式的id String selection = MediaStore.Images.Media._ID + "=" + id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if ("com.android.providers.downloads.documents".equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse( "content://downloads/public_downloads"),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if ("content".equalsIgnoreCase(uri.getScheme()))&#123; // 若是content类型的Uri，则使用普通方法处理 imagePath = getImagePath(uri,null); &#125;else if ("file".equalsIgnoreCase(uri.getScheme()))&#123; // 若是file类型到1Uri，则直接获取图片路径即可 imagePath = uri.getPath(); &#125; // 根据图片路径显示图片 displayImage(imagePath); &#125; /** * 4.4以下系统处理图片方法 * @param data */ private void handleImageBeforeKitKat(Intent data) &#123; Uri uri = data.getData(); String imagePath = getImagePath(uri,null); displayImage(imagePath); &#125; /** * 通过Uri和selection来获取真实的图片路径 * @param uri * @param selection * @return */ private String getImagePath(Uri uri,String selection)&#123; String path = null; Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if (cursor != null)&#123; if (cursor.moveToFirst())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; /** * 根据图片路径显示图片 * @param imagePath */ private void displayImage(String imagePath)&#123; if (imagePath != null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); iv_show_photo.setImageBitmap(bitmap); &#125;else &#123; ToastUtils.showShort("选取图片失败"); &#125; &#125;&#125; 上述代码中，调用摄像头拍照时用到了内容提供器，所以别忘了在 AndroidManifest.xml 中对内容提供器进行注册，如下： 123456789101112&lt;!-- android:name 属性的值是固定的 android:authorities 属性的值要和FileProvider.getUriForFile()方法中的第二个参数一致 &lt;meta-data&gt;来指定Uri的共享路径 --&gt;&lt;provider android:authorities="com.wonderful.myfirstcode.chapter8.TakePhotoActivity.fileprovider" android:name="android.support.v4.content.FileProvider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; 上面引用了一个 @xml/file_paths 资源是不存在的，需要另外创建它。新建 file_paths.xml 文件，内容如下： 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- external_path指定Uri共享，其name的值可随便填，path是指共享的具体路径 --&gt; &lt;external_path name = "my_images" path = ""/&gt;&lt;/paths&gt; 当然也别忘了声明访问SD卡的权限： 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 注意事项：在实际开发中最好根据项目的需求先对照片进行适当的压缩，然后再加载到内存中。 8.3 播放多媒体文件 在安卓中播放音频文件一般用 MediaPlayer 类来实现，播放视频文件主要用 VideoView 类来实现。以下是两个类的常用方法： 实现播放多媒体代码相对简单，这里播放音频和视频写在一块了，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class MediaPlayActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button music_play,music_pause,music_stop;// 音频播放、暂停、停止 private Button video_play,video_pause,video_replay;// 视频播放、暂停、重新播放 // 音频播放 创建MediaPlayer实例 private MediaPlayer mediaPlayer = new MediaPlayer(); // 视频播放显示 private VideoView videoView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_media_play); initMediaPlayerView(); if (ActivityCompat.checkSelfPermission(MediaPlayActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MediaPlayActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1); &#125;else &#123; initMediaPlayer(); // 初始化MediaPlayer initVideoPath(); // 初始化MediaPlayer &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; initMediaPlayer(); initVideoPath(); &#125;else &#123; ToastUtils.showShort("你拒绝了权限请求"); &#125; break; default: break; &#125; &#125; /** * 初始化音频播放器 */ private void initMediaPlayer() &#123; File file = new File(Environment.getExternalStorageDirectory(),"music.mp3");//事先放好的音频文件 try &#123; mediaPlayer.setDataSource(file.getPath()); // 指定音频文件的路径 mediaPlayer.prepare();// 让 MediaPlayer 进入到准备状态 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 初始化视频播放器 */ private void initVideoPath() &#123; File file = new File(Environment.getExternalStorageDirectory(),"movie.mp4");//事先放好的视频文件 videoView.setVideoPath(file.getPath()); // 指定视频文件的路径 &#125; private void initMediaPlayerView() &#123; music_play = (Button) findViewById(R.id.music_play); music_pause = (Button) findViewById(R.id.music_pause); music_stop = (Button) findViewById(R.id.music_stop); music_play.setOnClickListener(this); music_pause.setOnClickListener(this); music_stop.setOnClickListener(this); videoView = (VideoView) findViewById(R.id.video_view); video_play = (Button) findViewById(R.id.video_play); video_pause = (Button) findViewById(R.id.video_pause); video_replay = (Button) findViewById(R.id.video_replay); video_play.setOnClickListener(this); video_pause.setOnClickListener(this); video_replay.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; // 音频播放 case R.id.music_play: if (!mediaPlayer.isPlaying())&#123; mediaPlayer.start(); // 开始播放 &#125; break; case R.id.music_pause: if (!mediaPlayer.isPlaying())&#123; mediaPlayer.pause(); // 暂停播放 &#125; break; case R.id.music_stop: if (!mediaPlayer.isPlaying())&#123; mediaPlayer.stop(); // 停止播放 &#125; break; // 视频播放 case R.id.video_play: if (!videoView.isPlaying())&#123; videoView.start(); // 开始播放 &#125; break; case R.id.video_pause: if (!videoView.isPlaying())&#123; videoView.pause(); // 暂停播放 &#125; break; case R.id.video_replay: if (!videoView.isPlaying())&#123; videoView.resume(); // 重新播放 &#125; break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mediaPlayer != null)&#123; mediaPlayer.stop(); mediaPlayer.release();// 释放资源 &#125; if (videoView != null)&#123; videoView.suspend(); // 释放资源 &#125; &#125;&#125; 当然别忘了声明权限： 12&lt;!-- 访问SD卡权限 --&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 本章内容相对简单，下一章将学习网络编程的知识。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础7 - 内容提供器]]></title>
    <url>%2F2015%2F10%2F07%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8007-%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： Android 运行时权限； 内容提供器。 7.1 运行时权限 在介绍内容提供器之前先来了解了解 Android 运行时权限。 7.1.1 Android 权限机制 Android 把所有的权限归成两类：普通权限和危险权限。 普通权限 不会直接威胁到用户的安全和隐私的权限，对于这部分的权限申请，系统会自动帮我们进行授权。 危险权限 可能触及用户隐私，或对设备安全性造成影响的权限，如获取联系人信息、地理位置等，对于这部分的权限申请，必须由用户手动点击授权才可以，否则程序无法使用相应的功能。 下面列出了 Android 中所有的危险权限： 上表中每个危险权限都属于一个权限组，若用户同意授权某个权限名，那么该权限所对应的权限组中的其他权限也会同时跟着被授权。 注：访问Android官网可以查看完整的权限列表。 7.1.2 在运行程序时申请权限 接下来通过个例子来介绍如何在运行程序时申请权限。 此次的例子是通过点击界面上的一个按钮来直接拨打电话。拨打电话时需要声明上节表中的 CALL_PHONE 这个危险权限。 首先，在 AndroidManifest.xml 文件中声明权限： 1&lt;uses-permission android:name="android.permission.CALL_PHONE" /&gt; 然后在布局 activity_call_phone.xml 中添加个按钮： 1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/btn_call_phone" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击拨打电话"/&gt;&lt;/RelativeLayout&gt; 接着修改 activity 中代码如下： 1234567891011121314151617181920212223public class CallPhoneActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_call_phone); Button btn_call_phone = (Button) findViewById(R.id.btn_call_phone); btn_call_phone.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; // Intent.ACTION_CALL 是系统内置的打电话动作（而Intent.ACTION_DIAL指打开拨号界面，不需要声明权限） Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;catch (SecurityException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 在 Android 6.0 前，拨打电话功能的实现很简单，上面代码就把拨打电话功能实现了，在低于 Android 6.0 系统的手机上可以正常运行，但在 Android 6.0 或更高版本系统的手机上运行则无效，会抛出“Permission Denial”的异常。 接下来，修改 activity 中的代码，修复上面的问题，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class CallPhoneActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_call_phone); Button btn_call_phone = (Button) findViewById(R.id.btn_call_phone); btn_call_phone.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 1. 判断用户是否授权，借助 ContextCompat.checkSelfPermission() 方法 // ContextCompat.checkSelfPermission() 方法接收两参数：context 和权限名 if (ActivityCompat.checkSelfPermission(CallPhoneActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123; // 3. 若没授权，则调用 ActivityCompat.requestPermissions()方法来向用户授权 // 其三个参数：Activity实例、String数组（放权限名）、请求码（只要唯一就行了,这里传1） ActivityCompat.requestPermissions(CallPhoneActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, 1); // 4. 调用完 requestPermissions()方法后，会弹出一个权限申请对话框，供用户选择， // 最后回调 onRequestPermissionsResult()方法 &#125;else &#123; // 2. 若已授权，则直接执行拨打电话的逻辑 call(); &#125; &#125; &#125;); &#125; /** * 拨打电话方法 */ private void call() &#123; try &#123; // Intent.ACTION_CALL 是系统内置的打电话动作 Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;catch (SecurityException e)&#123; e.printStackTrace(); &#125; &#125; /** * 无论用户是否同意权限申请，都会回调此方法 * @param requestCode * @param permissions * @param grantResults 授权的结果 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; call(); &#125;else &#123; ToastUtils.showShort("你拒绝了权限请求"); &#125; break; default: break; &#125; &#125;&#125; 这样就完成了权限申请的代码编写了，具体过程看代码注释，现在运行一下程序，效果如下： 好了，关于运行时权限的内容先介绍到这，下面进入主题——内容提供器。 7.2 内容提供器 内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问到另一个程序中的数据，同时还能保证被访问数据的安全性。目前，使用内容提供器是 Android 实现跨程序共享数据的标准方式。 不同于文件存储和 SharedPreferences 存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄露的风险。 7.2.1 访问其他程序中的数据 内容提供器的用法有两种： 使用现有的内容提供器来读取和操作相应程序中的数据 创建自己的内容提供器给我们程序的数据提供外部访问接口7.2.1.1 ContentResolver 的基本用法 每一个应用程序，借助 ContenResolver 类才能访问内容提供器中共享的数据，该类可通过 Context 中的 getContentResolver() 方法获取实例，该类提供的一系列对数据的增删查改方法不同于 SQLiteDataBase，是不接收表名参数的，而是用参数Uri（称为内容 URI） 代替。 内容 URI 给内容提供器中的数据建立了唯一标识符，它由 authority（区分不同的应用程序）和 path（区分不同的表）组成。如某个程序包名为 com.example.app 且存在两张表 table1 和 table2 ，其标准格式写法如下： 在得到了 内容 URI 字符串后，需要调用 Uri.parse() 方法把它解析成 Uri 对象才可作为参数传入，代码如下： 1Uri uri = Uri.parse("content://com.example.app.provider/table1") 查询操作 现在就可以用这个 Uri 对象来查询 table1 表中的数据了，代码如下： 1Curson curson = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder); 下表对上面的参数进行了详细的解释： 查询完后返回一个 Curson 对象，读取代码如下： 12345678// 通过移动游标的位置来遍历Cursor的所有行if (cursor != null)&#123; while (cursor.moveToNext())&#123; String column1 = cursor.getString(cursor.getColumnIndex("column1")); int column2 = cursor.getInt(cursor.getColumnIndex("column2")); &#125; cursor.close(); &#125; 添加操作 向 table1 表中添加一条数据： 123456// 将待添加的数据组装到 ContentValues 中ContentValues values = new ContentValues();values.put("column1","text");values.put("column2",1);// 调用 insert() 方法添加数据getContentResolver().insert(uri, values); 更新操作 更新数据，把 column1 的值清空： 12345ContentValues values = new ContentValues();// 清空values.put("column1","");// 调用 update() 方法更新数据getContentResolver().update(uri, values, "column1 = ? and column2 = ?",new String[]&#123;"text","1"&#125;); 删除操作 调用 ContentResolver 的 delete() 删除数据： 1getContentResolver().delete(uri, "column2 = ?", new String[]&#123;"1"&#125;); 以上就是 ContentResolver 中的增删查改方法。 7.2.1.2 读取系统联系人 接下来举个例子来加深学习：利用内容提供器来读取系统联系人。 由于模拟器上木有联系人，先向模拟器中创建几个联系人。联系人准备好后，首先在项目的 AndroidManifest.xml 中声明读取联系人的权限： 1&lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt; 简单起见，在布局 activity_read_contact.xml 中放一个 ListView 来显示读取的联系人信息： 1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ListView android:id="@+id/contacts_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/ListView&gt;&lt;/RelativeLayout&gt; 接着修改 activity 中的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ReadContactActivity extends AppCompatActivity &#123; ArrayAdapter&lt;String&gt; adapter; List&lt;String&gt; contactsList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_read_contact); // 获取 listView 的实例，设置适配器 ListView contacts_view = (ListView) findViewById(R.id.contacts_view); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1,contactsList); contacts_view.setAdapter(adapter); // 判断是否授权 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,1); &#125;else &#123; readContacts(); &#125; &#125; /** * 读取联系人方法 */ private void readContacts() &#123; Cursor cursor = null; try&#123; // 查询联系人数据 cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if (cursor != null)&#123; while (cursor.moveToNext())&#123; // 获取联系人姓名 String name = cursor.getString(cursor.getColumnIndex (ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); // 获取联系人号码 String number = cursor.getString(cursor.getColumnIndex (ContactsContract.CommonDataKinds.Phone.NUMBER)); contactsList.add(name + "\n" + number); &#125; adapter.notifyDataSetChanged(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if (cursor != null)&#123; cursor.close(); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; readContacts(); &#125;else &#123; ToastUtils.showShort("你拒绝了权限请求"); &#125; break; default: break; &#125; &#125;&#125; 运行程序，效果如下： 7.2.2 创建自己的内容提供器 上一小节，介绍了如何访问其他应用程序得数据，其思路是获取应用程序的内容 URI 后借助 ContentResolver 进行 CRUD 操作就行了。接下来介绍创建自己的内容提供器。 7.2.2.1 创建步骤 首先，新建一个类去继承 ContentProvider，重写它的6个抽象方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 自己的内容提供器 * Created by KXwon on 2016/12/18. */public class MyProvider extends ContentProvider&#123; // 初始化内容提供器的时候调用，返回true表示成功，false失败 @Override public boolean onCreate() &#123; return false; &#125; // 从内容提供器中查询数据 @Override public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) &#123; return null; &#125; // 向内容提供器中添加一条数据 @Override public Uri insert(Uri uri, ContentValues contentValues) &#123; return null; &#125; // 从内容提供器中删除数据 @Override public int delete(Uri uri, String s, String[] strings) &#123; return 0; &#125; // 更新内容提供器中已有的数据 @Override public int update(Uri uri, ContentValues contentValues, String s, String[] strings) &#123; return 0; &#125; // 根据传入的内容 URI 来返回 MIME 类型 @Override public String getType(Uri uri) &#123; return null; &#125;&#125; 之前提到一个标准的内容 URI 写法是这样的： 12// 表示调用方期望访问的是 com.example.app 这个应用的 table1 表中的数据content://com.example.app.provider/table1 除此之外，还可以在内容 URI 后面加一个id，如下： 12// 表示调用方期望访问的是 com.example.app 这个应用的 table1 表中 id 为 1 的数据content://com.example.app.provider/table1/1 内容 URI 的格式主要就只有以上两种，可以通过用通配符的方式来匹配这两种内容 URI，规则如下： （1） *：表示匹配任意长度的任意字符。 （2）# ：表示匹配任意长度的数字 所以，一个能够匹配任意表的内容 URI 格式可写成： 1content://com.example.app.provider/* 一个能够匹配 table1 表中任意一行数据的内容 URI 格式可写成： 1content://com.example.app.provider/table1/# 然后，再借助 UriMatcher 这个类实现内容 URI 功能，修改 MyProvider 类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyProvider extends ContentProvider&#123; public static final int TABLE1_DIR = 0; //访问 table1 表中的所有数据 public static final int TABLE1_ITEM = 1;//访问 table1 表中的单条数据 public static final int TABLE2_DIR = 3; //访问 table2 表中的所有数据 public static final int TABLE2_ITEM = 4;//访问 table2 表中的单条数据 private static UriMatcher uriMatcher; static &#123; // 创建 UriMatcher 实例 uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); // 调用 addURI() 方法，此方法接收3个参数：authority、path、自定义代码 uriMatcher.addURI("com.example.app.provider","table1",TABLE1_DIR); uriMatcher.addURI("com.example.app.provider","table1/#",TABLE1_ITEM); uriMatcher.addURI("com.example.app.provider","table2",TABLE2_DIR); uriMatcher.addURI("com.example.app.provider","table2/#",TABLE2_ITEM); &#125; // 从内容提供器中查询数据 @Override public Cursor query(Uri uri, String[] strings, String s, String[] strings1, String s1) &#123; switch (uriMatcher.match(uri))&#123; case TABLE1_DIR: // 查询 table1 表中的所有数据 break; case TABLE1_ITEM: // 查询 table1 表中的单条数据 break; case TABLE2_DIR: // 查询 table2 表中的所有数据 break; case TABLE2_ITEM: // 查询 table2 表中的单条数据 break; default: break; &#125; . . . &#125; . . .&#125; 上述代码只是以 query() 方法做了个示范，其他3个增删改的方法也差不多。 而 getType() 方法，是所有的内容提供器都必须提供的一个方法，用于获取 Uri 对象所对应的 MIME 类型。MIME 字符串主要由 3 部分组成，并有如下格式规定： 必须由 vnd 开头； 若内容 URI 以路径结尾，则后接 android.cursor.dir/，若内容 URI 以 id 结尾，则后接 android.cursor.item/； 最后接上vnd..。 最后，实现 getType() 方法中的逻辑，完善 MyProvide r类如下： 12345678910111213141516171819202122public class MyProvider extends ContentProvider&#123; . . . // 根据传入的内容 URI 来返回 MIME 类型 @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri))&#123; case TABLE1_DIR: return "vnd.android.cursor.dir/vnd.com.example.app.provider.table1"; case TABLE1_ITEM: return "vnd.android.cursor.item/vnd.com.example.app.provider.table1"; case TABLE2_DIR: return "vnd.android.cursor.dir/vnd.com.example.app.provider.table2"; case TABLE2_ITEM: return "vnd.android.cursor.item/vnd.com.example.app.provider.table2"; default: break; &#125; return null; &#125;&#125; 到这里，一个完整的内容提供器就创建完成了。 7.2.2.1 实现跨程序数据共享 好了，例子来了。上一章项目中建立了 BookStore.db 数据库，里面有 book 表和 category 表这两张表，为简单起见，在上一章的基础上继续开发。 首先，为项目创建个内容提供器，在 Android Studio 中右击 com.wonderful.myfirstcode.chapter7.provider包（你项目所在的包名）→New→Other→Content Provider，会弹出如下窗口： 可以看到，这里把内容提供器命名为 DatabaseProvider，authority 指定为项目包名，Exported 表示是否允许外部程序访问我们的内容提供器，Enabled 表示是否启用这个内容提供器。两个勾选点击 Finish 完成创建。 接着修改 DatebaseProvider 中的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public class DataBaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; //访问 book 表中的所有数据 public static final int BOOK_ITEM = 1;//访问 book 表中的单条数据 public static final int CATEGORY_DIR = 3; public static final int CATEGORY_ITEM = 4; public static final String AUTHORITY = "com.wonderful.myfirstcode.chapter7.provider"; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; // 创建 UriMatcher 实例 uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); // 调用 addURI() 方法，此方法接收3个参数：authority、path、自定义代码 uriMatcher.addURI(AUTHORITY,"book",BOOK_DIR); uriMatcher.addURI(AUTHORITY,"book/#",BOOK_ITEM); uriMatcher.addURI(AUTHORITY,"category",CATEGORY_DIR); uriMatcher.addURI(AUTHORITY,"category/#",CATEGORY_ITEM); &#125; /** * 初始化内容提供器 */ @Override public boolean onCreate() &#123; // 创建 MyDatabaseHelper 实例 dbHelper = new MyDatabaseHelper(getContext(),"BookStore.db",null,2); // 返回true表示完成了创建或升级数据库 return true; &#125; /** * 查询数据 */ @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: // 查询 book 表中的所有数据 cursor = db.query("book",projection,selection,selectionArgs, null,null,sortOrder); break; case BOOK_ITEM: // 查询 book 表中的单条数据 String bookId = uri.getPathSegments().get(1); cursor = db.query("book",projection,"id = ?",new String[]&#123;bookId&#125;, null,null,sortOrder); break; case CATEGORY_DIR: cursor = db.query("category",projection,selection,selectionArgs, null,null,sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query("category",projection,"id = ?",new String[] &#123;categoryId&#125;, null,null,sortOrder); break; default: break; &#125; return cursor; &#125; /** * 添加数据 */ @Override public Uri insert(Uri uri, ContentValues values) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert("book",null,values); uriReturn = Uri.parse("content://" + AUTHORITY + "/book" + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert("category",null,values); uriReturn = Uri.parse("content://" + AUTHORITY + "/category" + newCategoryId); break; default: break; &#125; return uriReturn; &#125; /** * 更新数据 */ @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); int updatedRows = 0; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: updatedRows = db.update("book",values,selection,selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = db.update("book",values,"id = ?",new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: updatedRows = db.update("category",values,selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updatedRows = db.update("category",values,"id = ?",new String[] &#123;categoryId&#125;); break; default: break; &#125; return updatedRows; &#125; /** * 删除数据 */ @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: deletedRows = db.delete("book",selection,selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete("book","id = ?",new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: deletedRows = db.delete("category",selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete("category","id = ?",new String[] &#123;categoryId&#125;); break; default: break; &#125; return deletedRows; &#125; /** * 获取 Uri 对象所对应的 MIME 类型 */ @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: return "vnd.android.cursor.dir/vnd.com.wonderful.myfirstcode." + "chapter7.provider.book"; case BOOK_ITEM: return "vnd.android.cursor.item/vnd.com.wonderful.myfirstcode." + "chapter7.provider.book"; case CATEGORY_DIR: return "vnd.android.cursor.dir/vnd.com.wonderful.myfirstcode." + "chapter7.provider.category"; case CATEGORY_ITEM: return "vnd.android.cursor.item/vnd.com.wonderful.myfirstcode." + "chapter7.provider.category"; &#125; return null; &#125;&#125; 另外，内容提供器一定要在 AndroidManifest.xml 中注册才可使用。不过刚用 AS 创建的内容提供器已经帮我们自动注册完成了，如下： 123456 &lt;provider android:name=".chapter7.provider.DataBaseProvider" android:authorities="com.wonderful.myfirstcode.chapter7.provider" android:enabled="true" android:exported="true"&gt;&lt;/provider&gt; 现在，内容提供器已经创建好了，接下来新建一个项目 ProviderTest 来访问上面程序中的数据，记得清空上一章项目里的数据，以防造成干涉。 先来编写下布局文件 activity_main.xml，添加4个按钮来增删查改，如下： 12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="10dp" android:orientation="vertical"&gt; &lt;Button android:id="@+id/btn_add_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="添加数据"/&gt; &lt;Button android:id="@+id/btn_query_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="查询数据"/&gt; &lt;Button android:id="@+id/btn_update_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="更新数据"/&gt; &lt;Button android:id="@+id/btn_delete_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="删除数据"/&gt;&lt;/LinearLayout&gt; 然后修改 MainActivity 中的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity &#123; private String newId; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 添加数据 Button btn_add_data = (Button) findViewById(R.id.btn_add_data); btn_add_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse("content://com.wonderful.myfirstcode.chapter7.provider/book"); ContentValues values = new ContentValues(); values.put("name", "第一行代码"); values.put("author", "郭霖"); values.put("pages", 1000); values.put("price", 66.66); Uri newUri = getContentResolver().insert(uri,values); newId = newUri.getPathSegments().get(1); &#125; &#125;); // 查询数据 Button btn_query_data = (Button) findViewById(R.id.btn_query_data); btn_query_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse("content://com.wonderful.myfirstcode.chapter7.provider/book"); Cursor cursor = getContentResolver().query(uri,null,null,null,null); if (cursor != null)&#123; while (cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex("name")); String auhtor = cursor.getString(cursor.getColumnIndex("auhtor")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d("MainActivity", "书名: " + name); Log.d("MainActivity", "作者: " + auhtor); Log.d("MainActivity", "页数: " + pages); Log.d("MainActivity", "价格: " + price); &#125; &#125; cursor.close(); &#125; &#125;); // 更新数据 Button btn_update_data = (Button) findViewById(R.id.btn_update_data); btn_update_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse("content://com.wonderful.myfirstcode.chapter7.provider/book/" + newId); ContentValues values = new ContentValues(); values.put("name", "第二行代码"); values.put("pages", 2000); values.put("price", 88.88); getContentResolver().update(uri,values,null,null); &#125; &#125;); // 删除数据 Button btn_delete_data = (Button) findViewById(R.id.btn_delete_data); btn_delete_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse("content://com.wonderful.myfirstcode.chapter7.provider/book/" + newId); getContentResolver().delete(uri,null,null); &#125; &#125;); &#125;&#125; 代码很简单，不做解释了，现在运行一下项目，如下界面： 点击 添加数据 按钮，此时数据就添加到上一章项目的数据库中了，点击 查询数据 按钮，打印日志如下： 然后点击 更新数据 按钮，再次点击 查询数据 按钮查看打印日志如下： 最后点击 删除数据 按钮，此时数据就没了，点击 查询数据 按钮也就查询不到数据了。 以上，跨程序共享数据功能成功实现了。 关于内容提供器相关内容就介绍到这。下篇文章将进入手机多媒体的学习。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础6 - 持久化技术（下）]]></title>
    <url>%2F2015%2F10%2F05%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8006-%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： SQLite 数据库存储； 开源数据库框架 LitePal。 6.3 SQLite 数据库存储 前面介绍的两种存储方式很难应付得了需要存储大量复杂的关系型数据的时候，而使用数据库就可以做到。 SQLite 是一款轻量级的关系型数据库，它的运算速度非常快， 占用资源很少，通常只需几百 K 的内存就足够了，因而特别适合在移动设备上使用。SQLite 不仅支持标准的 SQL 语法，还遵循了数据库的 ACID 事务，只要你以前用过其他的关系型数据库，就可以很快地上手 SQLite。 6.3.1 创建数据库 Android 为了让我们更加方便地管理数据库，专门提供了一个 SQLiteOpenHelper 帮助类，借助这个类可以非常简单地对数据库进行创建和升级。 SQLiteOpenHelper 是一个抽象类，意味着若要使用它的话， 就需要创建一个自己的帮助类去继承它并且重写它的两个抽象方法，即 onCreate() 和 onUpgrade()，去实现创建、升级数据库的逻辑。 SQLiteOpenHelper 中有两个重要的实例方法 ， getReadableDatabase() 和 getWritableDatabase()。它们都可以创建或打开一个现有的数据库（若已存在则打开，否则创建一个新的），并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候（如磁盘空间已满）getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而 getWritableDatabase()方法则将出现异常。 SQLiteOpenHelper 中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可。构建出 SQLiteOpenHelper 的实例之后，再调用它的 getReadableDatabase() 或 getWritableDatabase() 方法就能够创建数据库了，数据库文件会存放在/data/data//databases/目录下。 此时，重写的 onCreate() 方法也会得到执行，在这里去处理一些创建表的逻辑。 说了这么多，还是举例子实在。这里我们希望创建一个名为 BookStore.db 的数据库，然后在这个数据库中新建一张 book表，表中有 id（主键）、作者、价格、页数和书名等列。 首先，在你的项目中新建 MyDatabaseHelper类继承自 SQLiteOpenHelper，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 数据库帮助类 * Created by KXwon on 2016/12/16. */public class MyDatabaseHelper extends SQLiteOpenHelper &#123; // Book表的建表语句 private static final String CREATE_BOOK = "create table book(" +"id integer primary key autoincrement," +"author text," +"price real," +"pages integer," +"name text)"; private Context mContext; /** * 构造方法 * @param context * @param name 数据库名 * @param factory 允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null * @param version 当前数据库的版本号，可用于对数据库进行升级操作 */ public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; /** * 创建数据库 * @param db */ @Override public void onCreate(SQLiteDatabase db) &#123; // 执行建表语句 db.execSQL(CREATE_BOOK); ToastUtils.showShort("创建成功"); &#125; /** * 升级数据库 * @param db * @param oldVersion * @param newVersion */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 然后修改布局 activity_sqlite.xml 中代码，添加个按钮来创建数据库： 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="15dp" android:orientation="vertical" &gt; &lt;Button android:id="@+id/btn_create_database" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="创建数据库"/&gt;&lt;/LinearLayout&gt; 最后修改 activity 中的代码： 12345678910111213141516171819202122public class SQLiteActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sqlite); // 构建MyDatabaseHelper对象，指定数据库名为"BookStore.db、版本号为1 dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 1); Button btn_create_database = (Button) findViewById(R.id.btn_create_database); btn_create_database.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 创建或打开一个现有的数据库（已存在则打开，否则创建一个新的） dbHelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 上述代码，当第一次点击按钮时，会检测到当前程序中并没有 BookStore.db 这个数据库，于是会创建该数据库并调用 MyDatabaseHelper中的 onCreate()方法，创建 book 表，然后弹出一个 Toast 提示创建成功。再次点击按钮时，会发现此时已存在 BookStore.db 数据库了，因此不会再创建一次。 运行代码，点击按钮，结果如下： 下面检查 book 表是否创建成功（木有兴趣可跳过）。 adb 是 Android SDK 中自带的一个调试工具，使用这个工具可以直接对连接在电脑上的手机或模拟器进行调试操作。它存放在 sdk 的 platform-tools 目录下，如果想要在命令行中使用这个工具，就要先把它的路径配置到环境变量里。 配置好环境变量后，就可以使用 adb 工具了。打开命令行界面，输入 adb shell，进入到设备的控制台，如下： 然后使用 cd 命令进行到/data/data/com.wonderful.myfirstcode/databases/目录下，并使用 ls命令查看到该目录里的文件，如下： 此目录下出现了两个数据库文件，一个是我们创建的 BookStore.db ，而另一个 BookStore.db-journal 则是为了让数据库能够支持事务而产生的临时日志文件，通常情况下这个文件的大小都是 0 字节。 接下来借助 sqlite 命令来打开数据库，键入 sqlite3，后面加上数据库名即可，如下： 这时已经打开了 BookStore.db 数据库，现在可以对这个数据库中的表进行管理了。 首先来看一下目前数据库中有哪些表，键入.table 命令，如下： 可以看到，此时数据库中有两张表，android_metadata 表是每个数据库中都会自动生成的，不用管它，而另外一张 book 表就是我们在 MyDatabaseHelper 中创建的了。这里还可以通过.schema 命令来查看它们的建表语句，如下： 由此证明，BookStore.db 数据库和 book 表已经创建成功了。之后键入.exit 或.quit命令可以退出数据库的编辑，再键入 exit 命令就可以退出设备控制台了。 6.3.2 升级数据库 MyDatabaseHelper 中的onUpgrade() 方法是用于对数据库进行升级的，它在整个数据库的管理工作当中起着非常重要的作用。 目前项目中已经有一张 book 表用于存放书的各种详细数据，若我们想再添加一张 category 表用于记录书籍的分类该怎么做呢？ 修改 MyDatabaseHelper 中的代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 数据库帮助类 * Created by KXwon on 2016/12/16. */public class MyDatabaseHelper extends SQLiteOpenHelper &#123; // Book表的建表语句 private static final String CREATE_BOOK = "create table book(" +"id integer primary key autoincrement," +"author text," +"price real," +"pages integer," +"name text)"; // Category表的建表语句 private static final String CREATE_CATEGORY = "create table category(" +"id integer primary key autoincrement," +"category_name text," +"category_code integer)"; private Context mContext; /** * 构造方法 * @param context * @param name 数据库名 * @param factory 允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null * @param version 当前数据库的版本号，可用于对数据库进行升级操作 */ public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; /** * 创建数据库 * @param db */ @Override public void onCreate(SQLiteDatabase db) &#123; // 执行建表语句 db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); ToastUtils.showShort("创建成功"); &#125; /** * 升级数据库 * @param db * @param oldVersion * @param newVersion */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; // 若发现数据库中已存在 book 表或 category 表，将这两张表删除掉 db.execSQL("drop table if exists book"); db.execSQL("drop table if exists category"); // 重新创建表 onCreate(db); &#125;&#125; 接着修改 activity 中的代码，在 SQLiteOpenHelper 的构造方法里接收的第四个参数传入一个比之前传入的版本号 1 大的数，就可以让 onUpgrade()方法得到执行了。如下所示： 123456789101112131415161718192021222324public class SQLiteActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sqlite); // 构建MyDatabaseHelper对象，指定数据库名为"BookStore.db、版本号为1 //dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 1); // 将数据库版本号指定为2 dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2); Button btn_create_database = (Button) findViewById(R.id.btn_create_database); btn_create_database.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 创建或打开一个现有的数据库（已存在则打开，否则创建一个新的） dbHelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 现在重新运行程序，并点击按钮，这时就会再次弹出创建成功的提示。 为了验证一下 category 表是 不是已经创建成功了，我们在 adb shell 中打开 BookStore.db 数据库，然后键入.table 命令， 结果如下： 接着键入.schema 命令查看一下建表语句，如下： 由此表明，category 表已创建成功了，同时也说明升级功能起作用了。 6.3.3 增删查改 接下来学习一下如何对表中的数据进行操作。对数据进行的操作无非四种，即 CRUD：添加（Create），查询（Retrieve），更新（Update），删除（Delete）。SQLiteOpenHelper 中的 getReadableDatabase() 或 getWritableDatabase() 方法都会返回一个 SQLiteDatabase对象，借助这个对象可以对数据进行 CRUD 操作。 首先修改下布局 activity_sqlite.xml 的代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="15dp" android:orientation="vertical" &gt; &lt;Button android:id="@+id/btn_create_database" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="创建数据库"/&gt; &lt;Button android:id="@+id/btn_add_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="添加数据"/&gt; &lt;Button android:id="@+id/btn_update_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="更新数据"/&gt; &lt;Button android:id="@+id/btn_delete_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="删除数据"/&gt; &lt;Button android:id="@+id/btn_query_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="查询数据"/&gt;&lt;/LinearLayout&gt; 修改后是这样的： 6.3.3.1 添加数据 SQLiteDatabase 中提供了一个 insert() 方法用于添加数据。它接收三个参数，第一个参数是表名；第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL，一般直接传入 null 即可；第三个参数是一个 ContentValues 对象，它提供了一系列的 put() 方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。 修改 activity 中的代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435public class SQLiteActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sqlite); . . . // 添加数据 Button btn_add_data = (Button) findViewById(R.id.btn_add_data); btn_add_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); // 开始组装第一条数据 values.put("name","The Da Vinci Code"); values.put("author","Dan Brown"); values.put("pages",454); values.put("price",16.96); db.insert("book",null,values); //插入第一条数据 values.clear(); // 开始组装第二条数据 values.put("name","The Lost Symbol"); values.put("author","Dan Brown"); values.put("pages",510); values.put("price",19.95); db.insert("book",null,values); //插入第二条数据 &#125; &#125;); &#125;&#125; 运行程序，点击添加数据按钮，此时两条数据应该都已经添加成功了。为了证实一下，打开 BookStore.db 数据库，输入 SQL 查询语句 “select * from Book；”，结果如下： 上图中由于我不小心点了两次按钮，所以出现了四条数据，但可以看出，刚刚组装的两条数据，已经添加到 book 表中了。 6.3.3.2 更新数据 SQLiteDatabase 中提供了一个 update() 方法用于更新数据。它接收四个参数，第一个参数和 insert()方法一样，是表名；第二个参数是 ContentValues 对象，要把更新数据在这里组装进去。第三、第四个参数用于去约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。 修改 activity 中的代码，如下所示： 12345678910111213141516171819202122232425public class SQLiteActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sqlite); . . . // 更新数据 Button btn_update_data = (Button) findViewById(R.id.btn_update_data); btn_update_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); // 把名字为 The Da Vinci Code 的这本书的更新成666.66 values.put("price",666.66); db.update("book",values, "name = ?", new String[]&#123;"The Da Vinci Code"&#125;); &#125; &#125;); &#125;&#125; 运行程序，点击更新数据按钮后，再次输入查询语句查看表中的数据情况，结果如下： 可以看到，The Da Vinci Code 这本书的价格已经被成功改为 666.66 了。 6.3.3.3 删除数据 SQLiteDatabase 中提供了一个 delete()方法用于删除数据。这个方法接收三个参数，第一 个参数仍然是表名；第二、第三个参数又是用于去约束删除某一 行或某几行的数据，不指定的话默认就是删除所有行。 修改 activity 中的代码，如下所示： 1234567891011121314151617181920212223public class SQLiteActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sqlite); . . . // 删除数据 Button btn_delete_data = (Button) findViewById(R.id.btn_delete_data); btn_delete_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); // 删除页数超过500页的书 db.delete("book", "pages &gt; ?", new String[]&#123;"500"&#125;); &#125; &#125;); &#125;&#125; 运行程序，点击删除数据按钮后，再次输入查询语句查看表中的数据情况，结果如下： 其中 The Lost Symbol 这本书的页数超过了 500 页，被删除掉了。 6.3.3.4 查询数据 SQLiteDatabase 中提供了一个 query()方法用于查询数据。 这个方法的参数非常复杂，最短的一个方法重载也需要传入七个参数。 第一个参数不用说，当然还是表名； 第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列； 第三、第四个参数用于去约束查询某一行或某几行的数据，不指定则默认是查询所有行的数据； 第五个参数用于指定需要去 group by 的列，不指定则表示不对查询结果进行 group by 操作； 第六个参数用于对 group by 之后的数据进行进一步的过滤，不指定则表示不进行过滤； 第七个参数用 于指定查询结果的排序方式，不指定则表示使用默认的排序方式。 更多详细的内容可以参考下表。其他几个 query()方法的重载其实也大同小异。 调用 query() 方法后会返回一个 Cursor 对象，查询到的所有数据都将从这个对象中取出。 修改 activity 中的代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738public class SQLiteActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sqlite); . . . // 查询数据 Button btn_query_data = (Button) findViewById(R.id.btn_query_data); btn_query_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); // 查询 book 表中所有数据 Cursor cursor = db.query("book", null,null,null,null,null,null,null); if (cursor.moveToFirst())&#123; do &#123; // 遍历 Cursor 对象，取出数据并打印 String name = cursor.getString(cursor.getColumnIndex("name")); String author = cursor.getString(cursor.getColumnIndex("author")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d("SQLiteActivity_query", "book name is: " + name); Log.d("SQLiteActivity_query", "book author is: " + author); Log.d("SQLiteActivity_query", "book pages are: " + pages); Log.d("SQLiteActivity_query", "book price is: " + price); &#125;while (cursor.moveToNext()); &#125; cursor.close(); &#125; &#125;); &#125;&#125; 运行程序，点击查询数据按钮后，查看Log的打印内容，结果如下： 可以看到，这里已经将 book 表中剩余两条数据成功地读取出来了。 6.3.4 使用 SQL 操作数据库 下面来简略演示一下，如何直接使用 SQL 来完成前面几小节中学过的 CRUD 操作。 添加数据的方法如下： 12db.execSQL("insert into book (name, author, pages, price) values(?, ?, ?, ?)", new String[] &#123; "The Da Vinci Code", "Dan Brown", "454", "16.96" &#125;); db.execSQL("insert into book (name, author, pages, price) values(?, ?, ?, ?)", new String[] &#123; "The Lost Symbol", "Dan Brown", "510", "19.95" &#125;); 更新数据的方法如下： 1db.execSQL("update Book set price = ? where name = ?", new String[] &#123; "666.66", "The Da Vinci Code" &#125;); 删除数据的方法如下： 1db.execSQL("delete from Book where pages &gt; ?", new String[] &#123; "500" &#125;); 查询数据的方法如下： 1db.rawQuery("select * from Book", null); 6.4 使用 LitePal 操作数据库 LitePal 是一款开源的 Android 数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行了封装，使得不用编写一行 SQL 语句就可以完成各种建表和增删查改的操作。LitePal 的项目主页上也有详细的使用文档，地址是：https://github.com/LitePalFramework/LitePal 6.4.1 配置 LitePal 使用 LitePal 的第一步，在 app/build.gradle 文件中引入 LitePal 的最新版本： 1compile 'org.litepal.android:core:1.4.1' 项目中引入 LitePal 成功后，需要配置 litepal.xml 文件。右击 app/src/main 目录→New→Directory，创建一个 assets 目录，然后在 assets 目录下再新建一个 litepal.xml 文件，接着编辑 litepal.xml 文件中的内容，如下所示： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;!-- 指定数据库名 --&gt; &lt;dbname value="MyBookStore"&gt;&lt;/dbname&gt; &lt;!-- 指定数据库版本号 --&gt; &lt;version value="1"&gt;&lt;/version&gt; &lt;!-- 指定所有的映射模型 --&gt; &lt;list&gt; &lt;/list&gt;&lt;/litepal&gt; 最后还要在 Application 中调用 LitePal 的初始化方法： 12345678910111213/** * 全局 * Created by KXwon on 2016/12/9. */public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 调用 LitePal 的初始化方法 LitePal.initialize(this); &#125;&#125; 当然别忘了在 AndroidManifest.xml 中配置 Application： 123456789&lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; . . . &lt;/application&gt; 现在 LitePal 的配置工作完成了，下面正式开始使用它吧。 6.4.2 创建和升级数据库 介绍时说过 LitePal 采取的是对象关系映射（ORM）的模式，即把面向面向对象的语言和面向关系的数据库之间建立一种映射关系。对象关系映射模式可以用面向对象的思维来操作数据库，这样就不用和 SQL 语句打交道了。 下面用 LitePal 实现和上面几小节中同样的功能，为了方便测试，突出对比，把数据库命名为 MyBookStore 。修改布局 activity_lite_pal.xm 中的代码和上面例子的布局类似： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="15dp" android:orientation="vertical" &gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:padding="10dp" android:text="LitePal 操作数据库"/&gt; &lt;Button android:id="@+id/btn_create_database" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="创建数据库"/&gt; &lt;Button android:id="@+id/btn_add_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="添加数据"/&gt; &lt;Button android:id="@+id/btn_update_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="更新数据"/&gt; &lt;Button android:id="@+id/btn_delete_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="删除数据"/&gt; &lt;Button android:id="@+id/btn_query_data" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="查询数据"/&gt;&lt;/LinearLayout&gt; 长这样的： 首先，为了创建一张 Book 表，先定义一个 Book 类，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Book 实体类 * Created by KXwon on 2016/12/16. */public class Book &#123; private int id; private String author; private double price; private int pages; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 接下来将 Book 类添加到映射关系列表中，修改 litepal.xml 中的代码如下： 123456789101112&lt;litepal&gt; &lt;!-- 指定数据库名 --&gt; &lt;dbname value="MyBookStore"&gt;&lt;/dbname&gt; &lt;!-- 指定数据库版本号 --&gt; &lt;version value="1"&gt;&lt;/version&gt; &lt;!-- 指定所有的映射模型 --&gt; &lt;list&gt; &lt;mapping class="com.wonderful.myfirstcode.chapter6.litepal_persistence.Book"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 这里使用标签来声明我们要配置的映射模型类，注意一定要使用完整的类名。不管有多少模型类型需要映射，都使用同样的方式配置在标签下即可。 这样就已经把所有工作完成了，现只要进行任意一次数据库的操作，MyBookStore.db 数据库就会自动创建出来。修改 activity 中的代码如下： 1234567891011121314151617public class LitePalActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lite_pal); // 创建数据库 Button btn_create_database = (Button) findViewById(R.id.btn_create_database); btn_create_database.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Connector.getDatabase(); &#125; &#125;); &#125;&#125; 其中调用 Connector.getDatabase() 方法就是一次最简单的数据库操作。运行程序并点击一下创建数据库按钮数据库就自动创建完成了，通过adb shell 查看数据库创建情况，如下： 可以看到，数据库文件已经创建成功了（前面两张表是上面例子创建的）。 接下来使用 sqlite3 命令打开 MyBookStore.db 文件，然后用 .schema 命令来查看见表语句，如下： 可以看到，这有3张建表语句，其中 android_metadata 不用管，table_schema 表是 LitePal 内部使用的，也可忽视，book 表就是根据定义的 Book 类以及类中的字段生成的。 前面使用 SQLiteOpenHelper 升级数据库时，会把之前的表 drop 掉，造成数据丢失（当然也可已通过复杂的逻辑来避免），而使用 LitePal 这些就不再是问题了。使用 LitePal 升级数据库很简单，不用思考任何的逻辑，只需要改你想改的任何内容，然后版本加1就行了。 比如想要向 Book 表中添加一个press(出版社)列，直接在 Book 类中添加一个 press 字段即可，如下所示： 12345678910111213public class Book &#123; . . . private String press; public String getPress() &#123; return press; &#125; public void setPress(String press) &#123; this.press = press; &#125; . . .&#125; 与此同时，若还想在添加一张 Category 表，那么只需要新建一个 Category 类就可以了，代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Category 实体类 * Created by KXwon on 2016/12/16. */public class Category &#123; private int id; private String categoryName; private int categoryCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCategoryName() &#123; return categoryName; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125; public int getCategoryCode() &#123; return categoryCode; &#125; public void setCategoryCode(int categoryCode) &#123; this.categoryCode = categoryCode; &#125;&#125; 改完了想改的东西，修改下 litepal.xml 中的代码如下： 12345678910111213&lt;litepal&gt; &lt;!-- 指定数据库名 --&gt; &lt;dbname value="MyBookStore"&gt;&lt;/dbname&gt; &lt;!-- 指定数据库版本号 --&gt; &lt;version value="2"&gt;&lt;/version&gt; &lt;!-- 指定所有的映射模型 --&gt; &lt;list&gt; &lt;mapping class="com.wonderful.myfirstcode.chapter6.litepal_persistence.Book"&gt;&lt;/mapping&gt; &lt;mapping class="com.wonderful.myfirstcode.chapter6.litepal_persistence.Category"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 将版本号加1，并把新的模型类添加到映射列表中。重新运行下程序，然后点击创建数据库按钮，再查看一下新的建表语句，如下： 这样数据库修改或升级就完成了，并且保留了之前表中的所有数据。 6.4.3 使用 LitePal 增删查改6.4.3.1 添加数据 使用 LitePal 添加数据，只需要创建出模型类的实例，再将所有要存储的数据设置好，最后调用一下 save() 方法就可以了。 LitePal 进行表管理操作时不需要模型类有任何继承结构，但进行 CRUD 操作时必须继承 DataSupport 类才行，因此需要修改 Book 类的代码如下： 123456789101112131415161718192021222324252627282930313233public class Book extends DataSupport&#123; . . .&#125; 接着向 Book 表中添加数据，修改 activity 中的代码如下：public class LitePalActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lite_pal); . . . // 添加数据 Button btn_add_data = (Button) findViewById(R.id.btn_add_data); btn_add_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 创建 Book 实例 Book book = new Book(); // 设置数据 book.setName("第一行代码"); book.setAuthor("郭霖"); book.setPages(570); book.setPrice(79.00); book.setPress("人民邮电出版社"); // 添加数据 book.save(); &#125; &#125;); &#125;&#125; 现重新运行程序，点击 添加数据 按钮，此时数据就已经添加了。同样打开 MyBookStore.db，输入 select*from Book；结果如下： 6.4.3.2 更新数据 使用 LitePal 更新数据，它的接口比较多，这里只介绍几种常用的。 方式1 对已存储的对象重新设值，然后调用 save() 方法即可。修改 activity 中的代码如下： 1234567891011121314151617181920212223242526272829public class LitePalActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lite_pal); . . . // 更新数据 Button btn_update_data = (Button) findViewById(R.id.btn_update_data); btn_update_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Book book = new Book(); book.setName("第一行代码"); book.setAuthor("郭霖"); book.setPages(570); book.setPrice(79.00); book.setPress("人民邮电出版社"); book.save(); // 修改书的名称和价格 book.setName("第二行代码"); book.setPrice(88.88); book.save(); &#125; &#125;); &#125;&#125; 方式2 对需要更新的数据进行设值，最后调用 updateAll() 方法去执行更新操作。修改 activity 中的代码如下： 12345678910111213141516171819202122public class LitePalActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lite_pal); . . . // 更新数据 Button btn_update_data = (Button) findViewById(R.id.btn_update_data); btn_update_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Book book = new Book(); book.setName("第二行代码"); book.setPrice(88.88); book.updateAll("name = ? and author = ?","第一行代码","郭霖"); &#125; &#125;); &#125;&#125; 现重新运行程序，点击 更新数据 按钮，查询表中的数据情况，结果如下： 注意事项：在使用 updateAll() 方法时，若你把一个字段的值更新为默认值时，是不可以使用上面的方式来 set 数据的。对于想要将数据更新为默认值，LitePal 统一提供了一个 setToDefault() 方法，然后传入相应的列名就可以了。如将所有书的页数都更新为默认值 0，直接调用 book.setPages(0) 是不可以的，但可以这样写： 123Book book = new Book();book.setToDefault("pages");book.updateAll(); 6.4.3.3 删除数据 使用 LitePal 删除数据的方式主要有两种：第一种就是直接调用已存储的对象的 delete() 方法就可以了；第二种是调用 DataSupport.deleteAll() 方法来删除。 这里演示下第二种方式，修改 activity 中的代码如下： 1234567891011121314151617181920public class LitePalActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lite_pal); . . . // 删除数据 Button btn_delete_data = (Button) findViewById(R.id.btn_delete_data); btn_delete_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 删除 Book 表中价格低于15的书 DataSupport.deleteAll(Book.class, "price &lt; ?", "15"); &#125; &#125;); &#125;&#125; 另外，deleteAll() 方法若不指定约束条件，就意味着删除表中的所有数据。 6.4.3.4 查询数据 使用 LitePal 查询数据一点都不复杂。 比如想要实现上节中的查询 Book 表，修改 activity 的代码如下： 12345678910111213141516171819202122232425262728public class LitePalActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lite_pal); . . . // 查询数据 Button btn_query_data = (Button) findViewById(R.id.btn_query_data); btn_query_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 查询 Book 表 List&lt;Book&gt; books = DataSupport.findAll(Book.class); // 打印 Book 表中的信息 for (Book book: books)&#123; Log.d("LitePalActivity_query", "book name is: " + book.getName()); Log.d("LitePalActivity_query", "book author is: " + book.getAuthor()); Log.d("LitePalActivity_query", "book pages are: " + book.getPages()); Log.d("LitePalActivity_query", "book price is: " + book.getPrice()); Log.d("LitePalActivity_query", "book press is: " + book.getPress()); &#125; &#125; &#125;); &#125;&#125; 没错，就是这么简单。现重新运行程序，点击 查询数据 按钮，查看Log信息如下： 除了 findAll() 方法之外，LitePal 还提供了其他非常有用的 API。比如: 查询 Book 表中的第一条数据： 1Book firstBook = DataSupport.findFirst(Book.class); 查询 Book 表中的最后一条数据： 1Book LastBook = DataSupport.findLast(Book.class); 还可以通过连缀查询来制定更多的查询功能： select() 方法用于指定查询哪几列的数据。如查询 name 和 author 这两列数据： 1List&lt;Book&gt; books = DataSupport.select("name","author").find(Book.class); where() 方法用于指定查询的约束条件。如查询页数大450的数据： 1List&lt;Book&gt; books = DataSupport.where(&quot;pages &gt; ?&quot;,&quot;450&quot;).find(Book.class); order() 方法用于指定结果的排序方式。如查询结果按书价从高到低排列： 12// 其中 desc 表示降序，asc 或者不写表示升序List&lt;Book&gt; books = DataSupport.order("price desc").find(Book.class); limit() 方法用于指定查询结果的数量。如查询表中前3条数据： 1List&lt;Book&gt; books = DataSupport.limit(3).find(Book.class); offset() 方法用于指定查询结果的偏移量。 如查询表中的第2、3、4条数据： 1List&lt;Book&gt; books = DataSupport.limit(3).offset(1).find(Book.class); 当然你也可以对这5个方法进行任意的连缀组合，如： 12345678// 查询 Book 表中第11-20跳满足页数大于450这个条件的 name、author 和 pages 这3列数据，// 并将查询结果按照页数升序排序List&lt;Book&gt; books = DataSupport.select("name","author","pages") .where("pages &gt; ?","450") .order("pages") .limit(10) .offset(10) .find(Book.class); LitePal 也可以支持使用原生的 SQL 语句来进行查询： 1Cursor c = DataSupport.findBySQL("select * from Book where pages &gt; ? and price &lt; ?","450","20"); 关于 LitePal 就介绍到这，下篇文章将进入内容提供器的学习。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础6 - 持久化技术（上）]]></title>
    <url>%2F2015%2F10%2F03%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8006-%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 文件存储； SharedPreference 存储； 实战：实现记住密码功能。 数据持久化是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的，持久化技术则是提供了一种机制可以让数据在瞬时状态和持久状态之间进行转换。 Android 系统中主要提供了三种方式实现数据持久化功能， 即文件存储、SharedPreference 存储以及数据库存储。当然，也可以将数据保存在手机的 SD 卡中，但相对会复杂一些，而且不安全。 6.1 文件存储 文件存储是 Android 中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据或二进制数据。 Context 类中提供了一个 openFileOutput () 方法，用于将数据存储到指定的文件中。Context 类中还提供了一个 openFileInput() 方法，用于从文件中读取数据。 下面通过一个例子学习下在 Android 项目中使用文件存储的技术。首先创建一个项目，并修改其布局代码： 1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;EditText android:id="@+id/edit_test" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="Type something here"/&gt;&lt;/RelativeLayout&gt; 这里只是在布局中加入了一个 EditText，用于输入文本内容。我们的目的是在文本输入框中随意输入内容，然后按下 Back 键，将输入的内容保存到文件中，再重新启动程序，刚才输入的内容不丢失。 修改 activity 中的代码（具体内容见注解），如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class FilePersistenceActivity extends AppCompatActivity &#123; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_file_persistence); editText = (EditText) findViewById(R.id.edit_test); String inputText = load(); if (!TextUtils.isEmpty(inputText))&#123; editText.setText(inputText); editText.setSelection(inputText.length()); // 将输入光标移到文本末尾位置 ToastUtils.showShort("重启读取存储的内容成功"); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText = editText.getText().toString(); // 在活动销毁前把输入的内容存储到文件中 save(inputText); &#125; /** * 把内容存储到文件 * @param inputText 存储的内容 */ public void save(String inputText) &#123; FileOutputStream out = null; BufferedWriter writer = null; try &#123; // openFileOutput方法接收两个参数： // 第一个是不包含路径的文件名 (默认存储到/data/data/&lt;package name&gt;/files/目录下) // 第二个是文件的操作模式,有两种可选： // 1.MODE_PRIVATE(默认)：当指定同样文件名的时候,所写入的内容将会覆盖原文件中的内容 // 2.MODE_APPEND：若该文件已存在就往文件里面追加内容,不存在就创建新文件。 // (注：其他操作模式过于危险,在 Android 4.2 已被废弃) // openFileOutput方法返回的是一个FileOutputStream对象 out = openFileOutput("data", Context.MODE_PRIVATE); // 构建OutputStreamWriter对象后,构建BufferedWriter对象 writer = new BufferedWriter(new OutputStreamWriter(out)); // 将文本写入文件 writer.write(inputText); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (writer != null)&#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 从文件中读取数据 * @return 读取的内容 */ public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; // openFileInput只接收一个参数，即要读取的文件名,然后系统会自动到 // /data/data/&lt;package name&gt;/files/目录下去加载这个文件,并返回一个FileInputStream对象. in = openFileInput("data"); // 构建InputStreamReader对象后,构建BufferedReader对象 reader = new BufferedReader(new InputStreamReader(in)); String line = ""; // 读取内容 while ((line = reader.readLine())!= null)&#123; content.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null)&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125;&#125; 运行程序，输入wonderful 后退出程序再重启，刚输入的内容并不会丢失，还原到了输入框中，如图所示： 文件存储所用到的核心技术就是 Context 类中提供的 openFileInput() 和 openFileOutput() 方法，之后就是利用 Java 的各种流来进行读写操作就可以了。 文件存储的方式并不适合用于保存一些较为复杂的文本数据，因此，下面就来学习一下 Android 中另一种数据持久化的方式，它比文件存储更加简单易用，而且可以很方便地对某一指定的数据进行读写操作。 6.2 SharedPreferences 存储 不同于文件的存储方式，SharedPreferences 是使用键值对的方式来存储数据的。 6.2.1 将数据存储到 SharedPreferences 中 要想使用 SharedPreferences 来存储数据，首先需要获取到 SharedPreferences 对象。Android 提供了三种方法得到 SharedPreferences 对象： Context 类中的 getSharedPreferences()方法 此方法接收两个参数，第一个参数指定 SharedPreferences 文件的名称，第二个参数指定操作模式，目前只有 MODE_PRIVATE 一种模式，和直接传入 0 效果相同。其他几种模式已被废弃。 Activity 类中的 getPreferences()方法 此方法和上面的方法相似，但只接收一个操作模式参数，使用这个方法时会自动将当前活动的类名作为 SharedPreferences 的文件名。 PreferenceManager 类中的 getDefaultSharedPreferences()方法 这是一个静态方法，它接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。 得到了 SharedPreferences 对象之后，分为三步实现向 SharedPreferences 文件中存储数据： （1）调用 SharedPreferences 对象的 edit()方法来获取一个 SharedPreferences.Editor 对象。 （2）向 SharedPreferences.Editor 对象中添加数据，如添加一个布尔型数据使用 putBoolean 方法，添加一个字符串使用 putString()方法，以此类推。 （3） 调用 apply()方法将添加的数据提交，完成数据存储。 当然，SharedPreference在提交数据时也可用 Editor 的 commit 方法，两者区别如下： apply() 没有返回值而 commit() 返回 boolean 表明修改是否提交成功 apply() 将修改提交到内存，然后再异步提交到磁盘上;而 commit() 是同步提交到磁盘上。 谷歌建议：若在UI线程中，使用 apply() 减少UI线程的阻塞（写到磁盘上是耗时操作）引起的卡顿。 接下来通过个例子来体验下。新建一个项目，修改其布局文件代码，如下： 123456789101112&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;Button android:id="@+id/save_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="保存数据" /&gt;&lt;/LinearLayout&gt; 放一个按钮，将一些数据存储到SharedPreferences 文件当中。然后修改 Activity 中的代码，如下所示： 1234567891011121314151617181920212223public class SharePreferencesActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_share_preferences); Button save_data = (Button) findViewById(R.id.save_data); save_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 1.指定文件名为 wonderful，并得到 SharedPreferences.Editor 对象 SharedPreferences.Editor editor = getSharedPreferences("wonderful",MODE_PRIVATE).edit(); // 2.添加数据 editor.putString("name","开心wonderful"); editor.putInt("age",20); editor.putBoolean("married",false); // 3.数据提交 editor.apply(); &#125; &#125;); &#125;&#125; 运行程序，点击按钮后，这时数据已保存成功了。接下来借助 File Explorer 来进行查看：打开 Android Device Monitor→点击 File Explorer 标签页→进入/data/data/com. wonderful.myfirstcode/shared_prefs /目录，可以看到生成了一个 wonderful.xml 文件，如下： 用记事本打开这个文件，里面内容如图所示： 可以看到，在按钮的点击事件中添加的所有数据都已经成功保存下来了，并且SharedPreferences 文件是使用 XML 格式来对数据进行管理的。 6.2.2 从 SharedPreferences 中读取数据 SharedPreferences 对象中提供了一系列的 get 方法用于对存储的数据进行读取，每种 get 方法都对应了 SharedPreferences. Editor 中的一种 put 方法。这些 get 方法接收两个参数，第一个参数是键，即传入存储数据时使用的键；第二个参数是默认值，即当传入的键找不到对应的值时，返回默认值。 还是例子实在，修改上面项目中的布局代码： 1234567891011121314151617181920212223&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;Button android:id="@+id/save_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="保存数据" /&gt; &lt;Button android:id="@+id/restore_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="读取数据" /&gt; &lt;TextView android:id="@+id/show_data" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 这里增加了一个还原数据的按钮和 TextView，点击按钮来从 SharedPreferences 文件中读取数据并在 TextView 中显示读取的数据。修改 Activity 中的代码，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SharePreferencesActivity extends AppCompatActivity &#123; private Button save_data,restore_data; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_share_preferences); save_data = (Button) findViewById(R.id.save_data); save_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 1.指定文件名为 wonderful，并得到 SharedPreferences.Editor 对象 SharedPreferences.Editor editor = getSharedPreferences("wonderful",MODE_PRIVATE).edit(); // 2.添加不同类型的数据 editor.putString("name","开心wonderful"); editor.putInt("age",20); editor.putBoolean("married",false); // 3.数据提交 editor.apply(); &#125; &#125;); textView = (TextView) findViewById(R.id.show_data); restore_data = (Button) findViewById(R.id.restore_data); restore_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 获得 SharedPreferences 对象 SharedPreferences pref = getSharedPreferences("wonderful",MODE_PRIVATE); // 获取相应的值 String name = pref.getString("name",""); int age = pref.getInt("age",0); boolean married = pref.getBoolean("married",false); // 将获取到的值显示 textView.setText("name is " + name + ",age is "+ age + ",married is "+ married); &#125; &#125;); &#125;&#125; 重新运行一下程序，并点击界面上的 读取数据 按钮，然后查看 TextView中显示的信息，如下： 所有之前存储的数据都成功读取出来了！相比之下，SharedPreferences 存储要比文件存储简单方便了许多。 6.2.3 实现记住密码功能 接下来，通过一个实现记住密码功能，来加深对 SharedPreferences 的学习。这里继续用上一章广播的强制下线的例子。 修改项目前，先来简单封装下关于 SharedPreferences 的工具类，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * SharePreference封装 * Created by KXwon on 2016/7/1. */public class PrefUtils &#123; private static final String PREF_NAME = "config"; /** * 读取布尔数据 * @param ctx 上下文 * @param key 键 * @param defaultValue 默认值 * @return */ public static boolean getBoolean(Context ctx, String key, boolean defaultValue) &#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); return sp.getBoolean(key, defaultValue); &#125; /** * 添加布尔数据 * @param ctx 上下文 * @param key 键 * @param value 添加的数据 */ public static void setBoolean(Context ctx, String key, boolean value) &#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); sp.edit().putBoolean(key, value).apply(); &#125; /** * 读取字符串 * @param ctx * @param key * @param defaultValue * @return */ public static String getString(Context ctx, String key, String defaultValue) &#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); return sp.getString(key, defaultValue); &#125; /** * 添加字符串 * @param ctx * @param key * @param value */ public static void setString(Context ctx, String key, String value) &#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); sp.edit().putString(key, value).apply(); &#125; /** * 读取int类型数据 * @param ctx * @param key * @param defaultValue * @return */ public static int getInt(Context ctx, String key, int defaultValue) &#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); return sp.getInt(key, defaultValue); &#125; /** * 添加int类型数据 * @param ctx * @param key * @param value */ public static void setInt(Context ctx, String key, int value)&#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); sp.edit().putInt(key, value).apply(); &#125; /** * 将数据全部清除掉 * @param ctx */ public static void clear(Context ctx)&#123; SharedPreferences sp = ctx.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); sp.edit().clear().apply(); &#125;&#125; 然后来编辑下登录界面，修改 activity_login.xml 中的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;!--***************** 账号 *********************--&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="60dp"&gt; &lt;TextView android:layout_width="90dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:gravity="center" android:textSize="18sp" android:text="账号："/&gt; &lt;EditText android:id="@+id/et_account" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:layout_gravity="center_vertical"/&gt; &lt;/LinearLayout&gt; &lt;!--***************** 密码 *********************--&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="60dp"&gt; &lt;TextView android:layout_width="90dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:gravity="center" android:textSize="18sp" android:text="密码："/&gt; &lt;EditText android:id="@+id/et_password" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:layout_gravity="center_vertical" android:inputType="textPassword"/&gt; &lt;/LinearLayout&gt; &lt;!--***************** 是否记住密码 *********************--&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;CheckBox android:id="@+id/cb_remember_pass" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="10dp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="18sp" android:layout_gravity="center_vertical" android:text="记住密码"/&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="match_parent" android:layout_height="60dp" android:layout_margin="10dp" android:text="登录"/&gt;&lt;/LinearLayout&gt; 只是添加了个 CheckBox 来勾选记住密码，接着修改 LoginActivity 的代码，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class LoginActivity extends BaseActivity &#123; private EditText et_account, et_password; private CheckBox cb_remember_pass; private Button btn_login; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); et_account = (EditText) findViewById(R.id.et_account); et_password = (EditText) findViewById(R.id.et_password); cb_remember_pass = (CheckBox) findViewById(R.id.cb_remember_pass); btn_login = (Button) findViewById(R.id.btn_login); Boolean isRemember = PrefUtils.getBoolean(this,"remember_pass",false); if (isRemember)&#123; // 将账号和密码都设置到文本框中 String account = PrefUtils.getString(this,"account",""); String password = PrefUtils.getString(this,"password",""); et_account.setText(account); et_password.setText(password); cb_remember_pass.setChecked(true); &#125; btn_login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String account = et_account.getText().toString(); String password = et_password.getText().toString(); // 若账号是 wonderful 且密码是 123456，就认为登录成功 if (account.equals("wonderful") &amp;&amp; password.equals("123456"))&#123; // 检查复选框是否被勾选 if (cb_remember_pass.isChecked())&#123; // 保存数据到SharePreference文件中 PrefUtils.setBoolean(LoginActivity.this,"remember_pass",true); PrefUtils.setString(LoginActivity.this,"account",account); PrefUtils.setString(LoginActivity.this,"password",password); &#125;else &#123; // 清除SharePreference文件中的数据 PrefUtils.clear(LoginActivity.this); &#125; // 登录成功跳转到主界面 IntentUtils.myIntent(LoginActivity.this,ForceOfflineActivity.class); finish(); &#125;else &#123; ToastUtils.showShort("账号或密码无效！"); &#125; &#125; &#125;); &#125; @Override protected int initLayoutId() &#123; return R.layout.activity_login; &#125;&#125; 具体代码就不解释了，看注释。 现在运行下程序，输入账号和密码并选中记住密码复选框后，点击登录，就会跳转到 ForceOfflineActivity。接着在 ForceOfflineActivity 中发出一条强制下线广播会让程序重新回到登录界面， 此时你会发现，账号密码都已经自动填充到界面上了，如下： 这样我们就使用 SharedPreferences 技术将记住密码功能成功实现了。当然这只是个简单的示例，实际项目中将密码以明文的形式存储在 SharedPreferences 文件中是不安全的，还需配合加密算法进行保护。 关于 SharedPreferences 的学习就到这，接下来会在下一篇文章中学习 Android 中的数据库技术。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础5 - 广播机制]]></title>
    <url>%2F2015%2F10%2F01%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8005-%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 广播机制的简介； 接收系统广播：动态注册与静态注册； 发送自定义广播； 使用本地广播； 实战：实现强制下线。 5.1 广播机制简介 Android 中的广播主要分两种类型：标准广播和有序广播。 标准广播（Normal broadcasts） 是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可 言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。标准广播的工作流程如下： 有序广播（Ordered broadcasts） 是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。有序广播的工作流程如下：5.2 接收系统广播 Android 内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。若想要接收到这些广播，就需要使用广播接收器。 5.2.1 动态注册监听网络变化 注册广播的方式有两种，在代码中注册（动态注册）和在 AndroidManifest.xml 中注册（静态注册）。 创建一个广播接收器：新建一个类，继承 BroadcastReceiver， 并重写父类的 onReceive() 方法。当有广播到来时，onReceive()方法就会得到执行， 具体的逻辑在这个方法中处理。 接下来先通过动态注册的方式编写一个能够监听网络变化的程序，学习一下广播接收器的基本用法。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 广播，动态监听网络变化 */public class BroadcastActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_broadcast); // 创建 IntentFilter 实例 intentFilter = new IntentFilter(); // 添加广播值 intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); // 创建 NetworkChangeReceiver 实例 networkChangeReceiver = new NetworkChangeReceiver(); // 注册广播 registerReceiver(networkChangeReceiver,intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消注册 unregisterReceiver(networkChangeReceiver); &#125; class NetworkChangeReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; // 获取管理网络连接的系统服务类的实例 ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); // 判断网络是否可用 if (networkInfo != null &amp;&amp; networkInfo.isAvailable())&#123; ToastUtils.showShort("网络可用"); &#125;else &#123; ToastUtils.showShort("网络不可用"); &#125; &#125; &#125;&#125; 注意事项： 动态注册的广播接收器一定都要取消注册才行，这里我们是在 onDestroy()方法中通过调用 unregisterReceiver()方法来实现的。 在 AndroidManifest.xml 文件中加入访问系统的网络状态权限： 1&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 运行程序，然后按下 Home 键→按下 Menu 键→System settings→Data usage 进入到数据使用详情界面，关闭 Mobile Data 会弹出网络不可用的提示： 重新打开 Mobile Data 又会弹出网络可用的提示： 5.2.2 静态注册实现开机启动 动态注册的广播接收器可以自由地控制注册与注销，在灵活性方面有很大的优势，但它也存在着一个缺点，即必须要在程序启动之后才能接收到广播，因为注册的逻辑是写在 onCreate()方法中的。使用静态注册的方式就可以让程序在未启动的情况下接收到广播。 接下来让程序接收一条开机广播，收到这条广播时在 onReceive() 方法中相应的逻辑，从而实现开机启动的功能。Android Studio 创建广播接收器：右击com.wonderful.myfirstcode.chapter5（你的包名）→New→Other→Broadcast Receiver，会弹出窗口： 这里把广播接收器命名为 BootCompleteReceiver，Exported 表示是否允许此广播接收本程序以外的广播，Enabled 表示是否启用这个广播接收器。 点击 Finish 完成创建后，修改 BootCompleteReceiver 中的代码： 12345678public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // 执行相应的逻辑 ToastUtils.showShort("开机完成"); &#125;&#125; 静态的广播接收器一定要在 AndroidManifest.xml 文件中注册才可使用，刚使用 Android Studio 创建的广播接收器已经自动帮我们完成注册了，如下： 12345678910111213141516171819202122&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.wonderful.myfirstcode"&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; . . . &lt;receiver android:name=".chapter5.BootCompleteReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; 接下来修改 AndroidManifest.xml 文件中的标签中的内容，使 BootCompleteReceiver 接收开机广播： 12345678&lt;receiver android:name=".chapter5.BootCompleteReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 由于系统启动后会发出一条值为 android.intent.action.BOOT_COMPLETED 的广播，因此在 标签中添加相应的 action。另外，别忘了声明监听系统开机广播的权限： 1&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt; 这样程序可以接收到开机广播了，将模拟器关闭并重启，如下： 注意事项：不要在 onReceive() 方法中添加过多的逻辑或者进行耗时操作，因为广播接收器中是不允许开启线程的。 5.3 发送自定义广播 接下来学习如何在应用程序中发送自定义广播，通过实践的方式来看一下标准广播和有序广播的区别。 5.3.1 发送标准广播 在发送广播之前，先新建一个广播接收器 MyBroadcastReceiver 来接收自定义广播，收到广播时弹提示，代码如下： 1234567public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; ToastUtils.showShort("收到自定义广播"); &#125;&#125; 然后修改 AndroidManifest.xml 文件中的标签中的内容，让 MyBroadcastReceiver 收到一条值为 com.wonderful.myfirstcode.MY_BROADCAST 的广播： 12345678&lt;receiver android:name=".chapter5.MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.wonderful.myfirstcode.MY_BROADCAST" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 接下来在布局文件中添加一个按钮作为发送广播的触发点： 1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/btn_send_broadcast" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="发送广播"/&gt;&lt;/RelativeLayout&gt; 然后修改 activity 中的代码，在按钮点击事件中加入发送自定义广播逻辑，如下： 123456789101112131415161718192021222324public class BroadcastActivity extends AppCompatActivity &#123; . . . @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_broadcast); Button btn_send_broadcast= (Button) findViewById(R.id.btn_send_broadcast); btn_send_broadcast.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 构建 Intent 对象 Intent intent = new Intent("com.wonderful.myfirstcode.MY_BROADCAST"); // 发送广播 sendBroadcast(intent); &#125; &#125;); . . . &#125; . . .&#125; 运行程序，点击按钮，效果如下： 这样就完成了发送自定义广播的功能。另外，由于广播是使用 Intent 进行传递的，因此你还可以在 Intent 中携带一些数据传递给广播接收器。 5.3.1 发送有序广播 广播是一种可以跨进程的通信方式，这一点从前面接收系统广播的时候可以看出来。因此在我们应用程序内发出的广播，其他的应用程序应该也是可以收到的。为了验证这一点，我们需要再新建一个 BroadcastTest2 项目。 项目创建好后，定义一个接收上一小节中的自定义广播的广播接收器 AnotherBroadcastReceiver，如下： 1234567public class AnotherBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "另外一个广播接收器收到广播了！", Toast.LENGTH_SHORT).show(); &#125;&#125; 然后修改 AndroidManifest.xml 文件中的标签中的内容，让 AnotherBroadcastReceiver 同样收到一条值为 com.wonderful.myfirstcode.MY_BROADCAST 的广播： 12345678&lt;receiver android:name=".AnotherBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.wonderful.myfirstcode.MY_BROADCAST" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 现在把项目 BroadcastTest2 安装到模拟器上，然后重新回到上一个项目的界面上，点击发送广播按钮，就会弹两次提示信息，如图： 到目前为止，发送的都是标准广播，接下来尝试一下发送有序广播。 回到前面的项目，修改 Activity 中的代码，如下： 12345678910111213141516171819202122232425262728public class BroadcastActivity extends AppCompatActivity &#123; . . . @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_broadcast); Button btn_send_broadcast = (Button) findViewById(R.id.btn_send_broadcast); btn_send_broadcast.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 构建 Intent 对象 Intent intent = new Intent("com.wonderful.myfirstcode.MY_BROADCAST"); // 发送标准广播 //sendBroadcast(intent); // 发送有序广播 sendOrderedBroadcast(intent, null); &#125; &#125;); . . . &#125; . . .&#125; 发送有序广播 sendOrderedBroadcast() 方法接收两个参数，第一个是 Intent，第二个是与权限相关的字符串，在这传 null 就行了。当然现在运行程序点击按钮两个应用程序还是会收到广播，接下来还需要修改 AndroidManifest.xml 文件中的标签中的代码，设定广播接收器的先后顺序： 12345678&lt;receiver android:name=".chapter5.MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="com.wonderful.myfirstcode.MY_BROADCAST" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 上述代码，通过 android:priority 属性给广播接收器设置了优先级，优先级比较高的广播接收器就可以先收到广播。把 MyBroadcastReceiver 的优先级设成了 100，保证它一定会在 AnotherBroadcastReceiver 之前收到广播。 接下来，修改 MyBroadcastReceiver 中的代码，设置是否允许广播继续传递。在 onReceive()方法中调用 abortBroadcast()方法，表示将这条广播截断，后面的广播接收器将无法再接收到这条广播。如下： 123456789public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; ToastUtils.showShort("收到自定义广播"); // 将这条广播拦截 abortBroadcast(); &#125;&#125; 现在重新运行程序，就只有 MyBroadcastReceiver 可以接收到广播弹提示信息了。 5.4 使用本地广播 本地广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播。本地广播的用法并不复杂，主要使用了一个 LocalBroadcastManager 来对广播进行管理，并提供了发送广播和注册广播接收器的方法。 通过具体的实例来尝试一下它的用法，修改 Activity 中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class BroadcastActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_broadcast); // 获取实例 localBroadcastManager = LocalBroadcastManager.getInstance(this); Button btn_send_broadcast = (Button) findViewById(R.id.btn_send_broadcast); btn_send_broadcast.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 构建 Intent 对象 Intent intent = new Intent("com.wonderful.myfirstcode.LOCAL_BROADCAST"); // 发送有序广播 localBroadcastManager.sendBroadcast(intent); &#125; &#125;); // 创建 IntentFilter 实例 intentFilter = new IntentFilter(); // 添加广播值 intentFilter.addAction("com.wonderful.myfirstcode.LOCAL_BROADCAST"); // 创建 LocalReceiver 实例 localReceiver = new LocalReceiver(); // 注册本地广播监听器 localBroadcastManager.registerReceiver(localReceiver,intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消注册 localBroadcastManager.unregisterReceiver(localReceiver); &#125; /** * 本地广播接收器 */ class LocalReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; ToastUtils.showShort("收到本地广播"); &#125; &#125;&#125; 基本上就和前面的动态注册广播接收器以及发送广播的代码是一样。 运行效果如下： 另外还有一点需要说明，本地广播是无法通过静态注册的方式来接收的。 最后盘点一下使用本地广播的优势： 可以明确知道正在发送的广播不会离开我们的程序，不需要担心机密数据泄漏的问题。 其他的程序无法将广播发送到我们程序的内部，不需要担心会有安全漏洞的隐患。 发送本地广播比起发送系统全局广播将会更加高效。 5.5 广播的最佳实践——实现强制下线功能 又到了实战环节了。此次的需求是：强制下线后在界面上弹出一个对话框，让用户无法进行任何其他操作，必须要点击对话框中的确定按钮， 然后回到登录界面。 借助本次所学的广播知识，可以轻松实现这一功能。 首先，创建一个 ActivityCollector 类用于管理所有的活动： 123456789101112131415161718192021222324252627282930313233343536/** * 活动管理器 * Created by KXwon on 2016/12/9. */public class ActivityCollector &#123; // 通过一个List来缓存活动 public static List&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;(); /** * 用于向List中添加一个活动 * @param activity */ public static void addActivity(Activity activity) &#123; activities.add(activity); &#125; /** * 用于从List中移除活动 * @param activity */ public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125; /** * 将List中存储的活动全部销毁掉 */ public static void finishAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125;&#125; 然后创建 BaseActivity 类作为所有活动的父类（忽略一些不必要的内容，主要看ActivityCollector 相关的）： 123456789101112131415161718192021222324252627282930313233343536373839/** * 基类 * Created by KXwon on 2016/12/9. */public abstract class BaseActivity extends AppCompatActivity &#123; protected Context mContext; protected Unbinder mBinder; /** * 初始化布局id * @return 布局id */ protected abstract int initLayoutId(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(initLayoutId()); Log.d("BaseActivity", getClass().getSimpleName());// 知晓当前是在哪一个活动 ActivityCollector.addActivity(this);// 将当前正在创建的活动添加到活动管理期里 mContext = this; mBinder = ButterKnife.bind(this); &#125; @Override protected void onDestroy() &#123; // 取消绑定 mBinder.unbind(); super.onDestroy(); // 将一个马上要销毁的活动从管理器里移除 ActivityCollector.removeActivity(this); &#125;&#125; 接下来创建一个登录界面，新建 LoginActivity，编辑 activity_login.xml 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="60dp"&gt; &lt;TextView android:layout_width="90dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:gravity="center" android:textSize="18sp" android:text="账号："/&gt; &lt;EditText android:id="@+id/et_account" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:layout_gravity="center_vertical"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="60dp"&gt; &lt;TextView android:layout_width="90dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:gravity="center" android:textSize="18sp" android:text="密码："/&gt; &lt;EditText android:id="@+id/et_password" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:layout_gravity="center_vertical"/&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="match_parent" android:layout_height="60dp" android:layout_margin="10dp" android:text="登录"/&gt;&lt;/LinearLayout&gt; 接着修改 LoginActivity 中的代码： 123456789101112131415161718192021222324252627282930313233343536public class LoginActivity extends BaseActivity &#123; private EditText et_account, et_password; private Button btn_login; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); et_account = (EditText) findViewById(R.id.et_account); et_password = (EditText) findViewById(R.id.et_password); btn_login = (Button) findViewById(R.id.btn_login); btn_login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String account = et_account.getText().toString(); String password = et_password.getText().toString(); // 若账号是 wonderful 且密码是 123456，就认为登录成功 if (account.equals("wonderful") &amp;&amp; password.equals("123456"))&#123; // 登录成功跳转到主界面 IntentUtils.myIntent(LoginActivity.this,ForceOfflineActivity.class); finish(); &#125;else &#123; ToastUtils.showShort("账号或密码无效！"); &#125; &#125; &#125;); &#125; @Override protected int initLayoutId() &#123; return R.layout.activity_login; &#125;&#125; 登录成功后跳转到 ForceOfflineActivity 主界面，在主界面加入一个强制下线的功能即可，其布局 activity_force_offline.xml 代码为： 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="10dp"&gt; &lt;Button android:id="@+id/btn_force_offline" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="发送强制下线广播"/&gt;&lt;/RelativeLayout&gt; 只有一个按钮，用于触发强制下线功能，然后修改 ForceOfflineActivity 中的代码： 12345678910111213141516171819202122public class ForceOfflineActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Button btn_force_offline = (Button) findViewById(R.id.btn_force_offline); btn_force_offline.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent("com.wonderful.myfirstcode.FORCE_OFFLINE"); // 发送强制下线广播 sendBroadcast(intent); &#125; &#125;); &#125; @Override protected int initLayoutId() &#123; return R.layout.activity_force_offline; &#125;&#125; 上述代码，在按钮的点击事件里面发送了一条广播，广播的值为 com.wonderful.myfirstcode.FORCE_OFFLINE，这条广播就是用于通知程序强制用户下线的。也就是说强制用户下线的逻辑并不是写在 ForceOfflineActivity 里的，而是写在接收这条广播的广播接收器里面，这样强制下线的功能就不会依附于任何的界面，不管是在程序的任何地方，只需要发出这样一条广播，就可以完成强制下线的操作了。 毫无疑问，要在 BaseActivity 中动态注册一个广播接收器，因为所有的活动都继承 BaseActivity 的，修改 BaseActivity 中的代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 基类 * Created by KXwon on 2016/12/9. */public abstract class BaseActivity extends AppCompatActivity &#123; protected Context mContext; protected Unbinder mBinder; private ForceOfflineReceiver receiver; /** * 初始化布局id * @return 布局id */ protected abstract int initLayoutId(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(initLayoutId()); Log.d("BaseActivity", getClass().getSimpleName());// 知晓当前是在哪一个活动 ActivityCollector.addActivity(this);// 将当前正在创建的活动添加到活动管理期里 mContext = this; mBinder = ButterKnife.bind(this); &#125; @Override protected void onResume() &#123; super.onResume(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("com.wonderful.myfirstcode.FORCE_OFFLINE"); receiver = new ForceOfflineReceiver(); registerReceiver(receiver,intentFilter); &#125; @Override protected void onPause() &#123; super.onPause(); if (receiver != null)&#123; unregisterReceiver(receiver); receiver = null; &#125; &#125; @Override protected void onDestroy() &#123; // 取消绑定 mBinder.unbind(); super.onDestroy(); // 将一个马上要销毁的活动从管理器里移除 ActivityCollector.removeActivity(this); &#125; class ForceOfflineReceiver extends BroadcastReceiver&#123; @Override public void onReceive(final Context context, Intent intent) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle("警告"); builder.setMessage("你已被下线，请重新登录"); // 设置不可取消 builder.setCancelable(false); // 设置点击事件 builder.setPositiveButton("OK", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; // 销毁所有活动 ActivityCollector.finishAll(); // 重新启动 LoginActivity IntentUtils.myIntent(context, LoginActivity.class); &#125; &#125;); builder.show(); &#125; &#125;&#125; 上述代码中，重写了 onResume() 和 onPause() 这两个生命周期的函数，然后分别在这两个方法里注册和取消注册了 ForceOfflineReceiver，之所以这样写而不是在 onCreate() 和 onDestroy() 方法里注册和取消注册是因为我们始终需要保证只有处于栈顶的活动才能接收到下线广播，非栈顶活动不必要接收这条广播，写在 onResume() 和 onPause() 方法里很好的解决了这个问题，当活动失去栈顶位置时就会自动取消广播接收器的注册。 现在，所有强制下线的逻辑处理完了，接下来运行程序，首先进入登录界面： 输入正确的账号和密码后，点击登录进入主界面： 这时点击按钮，就会发出一条强制下线的广播，ForceOfflineReceiver 接收到这条广播后会弹出一个提示对话框，这时就无法对其他界面的任何元素进行操作，只能点击 OK 按钮，重新回到登录界面，如下： 关于广播机制的学习就到这，下篇文章将进入持久化技术的学习。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础4 - 探究碎片]]></title>
    <url>%2F2015%2F09%2F25%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8004-%E6%8E%A2%E7%A9%B6%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍以下几个知识点： 碎片 fragment 的用法； 碎片 fragment 的生命周期； 动态加载布局的技巧，限定符的使用； 实战：简易版的新闻应用 4.1 碎片是什么 碎片（Fragment）是一种可以嵌入在活动当中的 UI 片段，它能让程序更加合理和充分 地利用大屏幕的空间，因而在平板上应用的非常广泛。 那么究竟要如何使用碎片才能充分地利用平板屏幕的空间呢？想象我们正在开发一个新闻应用，其中一个界面使用 RecyclerView 展示了一组新闻的标题，当点击了其中一个标题，就打开另一个界面显示新闻的详细内容。若是在手机中设计，我们可以将新闻标题列表放在 一个活动中，将新闻的详细内容放在另一个活动中，如图所示：但显示在平板上，那么新闻标题列表将会被拉长至填充满整个平板的屏幕，而新闻的标题一般都不会太长，这样将会导致界面上有大量的空白区域，如图所示：因此，更好的设计方案是将新闻标题列表界面和新闻详细内容界面分别放在两个碎片中，然后在同一个活动里引入这两个碎片，这样就可以将屏幕空间充分地利用起来了，如图所示： 4.2 碎片的使用方式4.2.1 碎片的简单用法 这里我们准备先写一个最简单的碎片示例来练练手，在一个活动当中添加两个碎片，并让这两个碎片平分活动空间。新建一个左侧碎片布局 fragment_left.xml，代码如下所示： 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="按钮"/&gt;&lt;/LinearLayout&gt; 这个布局非常简单，只放置了一个按钮，并让它水平居中显示。然后新建右侧碎片布局fragment_right.xml，代码如下所示： 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="#00ff00"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:textSize="20sp" android:text="这是右边的fragment"/&gt;&lt;/LinearLayout&gt; 可以看到，我们将这个布局的背景色设置成绿色，并放置了一个 TextView 用于显示一段文本。 接着新建一个 LeftFragment 类，继承自 Fragment。注意，这里可能会有两个不同包 下的 Fragment 供你选择，一个是系统内置的android.app.Fragment，一个是 support-v4 库中的 android.support.v4.app.Fragment 。这里强烈建议使用 support-v4 库中的 Fragment，因为它可以让碎片在所有 Android 系统版本中保持功能一致性。 LeftFragment 的代码如下所示： 123456789public class LeftFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_left, container, false); return view; &#125;&#125; 这里仅仅是重写了 Fragment 的 onCreateView()方法，然后在这个方法中通过 LayoutInflater 的 inflate()方法将刚才定义的 fragment_left 布局动态加载进来，整个方法简单明了。接着我们用同样的方法再新建一个 RightFragment： 123456789public class RightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_right, container, false); return view; &#125;&#125; 接下来修改 activity_fragment.xml 中的代码，如下所示： 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_fragment" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;fragment android:id="@+id/fragment_left" android:name="com.wonderful.myfirstcode.inquiry_fragment.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;fragment android:id="@+id/fragment_right" android:name="com.wonderful.myfirstcode.inquiry_fragment.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt;&lt;/LinearLayout&gt; 可以看到，我们使用了标签在布局中添加碎片，通过 android:name 属性来显式指明要添加的碎片类名，注意一 定要将类的包名也加上。 这样最简单的碎片示例就已经写好了，运行一下程序，（平板上）效果如图: 4.2.2 动态添加碎片 碎片真正的强大之处在于，它可以在程序运行时动态地添加到活动当中。根据具体情况来动态地添加碎片，你就 可以将程序界面定制得更加多样化。 在上一节代码的基础上继续完善，新建 fragment_another_right.xml，代码如下所示： 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="#ffff00"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:textSize="20sp" android:text="这是另外一个右边的fragment"/&gt;&lt;/LinearLayout&gt; 然后新建 AnotherRightFragment 作为另一个右侧碎片，代码如下所示： 123456789public class AnotherRightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_another_right, container, false); return view; &#125;&#125; 接下来看一下如何将它动态地添加到活动当中。修改 activity_fragment.xml，代码如下所示： 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_fragment" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;fragment android:id="@+id/fragment_left" android:name="com.wonderful.myfirstcode.inquiry_fragment.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;FrameLayout android:id="@+id/right_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;!-- &lt;fragment android:id="@+id/fragment_right" android:name="com.wonderful.myfirstcode.inquiry_fragment.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; --&gt;&lt;/LinearLayout&gt; 可以看到，现在将右侧碎片放在了一个 FrameLayout 中，下面在代码中向 FrameLayout 里添加内容，从而实现动态添加碎片的功能。修改 Activity 中的代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435public class FragmentActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragment); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(this); replaceFragment(new RightFragment()); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.button: replaceFragment(new AnotherRightFragment()); break; default: break; &#125; &#125; private void replaceFragment(Fragment fragment)&#123; // 获取FragmentManager FragmentManager fragmentManager = getSupportFragmentManager(); // 开启事务 FragmentTransaction transaction = fragmentManager.beginTransaction(); // 添加或替换碎片 transaction.replace(R.id.right_layout,fragment); // 提交事务 transaction.commit(); &#125;&#125; 上述代码，给左侧碎片中的按钮注册了一个点击事件，调用 replaceFragment() 方法动态添加碎片。结合代码可看出，动态添加碎片主要分为 5 步。 1. 创建待添加的碎片实例。 2. 获取 FragmentManager，在活动中可以直接调用 getSupportFragmentManager()方法得到。 3. 开启一个事务，通过调用 beginTransaction()方法开启。 4. 向容器内添加或替换碎片，一般使用 replace() 方法实现，需要传入容器的 id 和待添加的碎 片实例。 5. 提交事务，调用 commit()方法来完成。 重新运行程序，效果如图： 4.2.3 在碎片中模拟返回栈 在上一小节中，我们实现了向活动中动态添加碎片的功能，但通过点击按钮添加了一个碎片之后，按下 Back 键程序就会直接退出。如果这里我们想模仿类似于返回栈的效果，按下 Back 键可以回到上一个碎片，该如何实现呢？ FragmentTransaction 中提供了一个 addToBackStack() 方法，可以用于将一个事务添加到返回栈中，修改 Activity 中的代码，如下所示： 1234567891011121314151617public class FragmentActivity extends AppCompatActivity implements View.OnClickListener &#123; . . . private void replaceFragment(Fragment fragment)&#123; // 获取FragmentManager FragmentManager fragmentManager = getSupportFragmentManager(); // 开启事务 FragmentTransaction transaction = fragmentManager.beginTransaction(); // 添加或替换碎片 transaction.replace(R.id.right_layout,fragment); // 用于描述返回栈的状态 transaction.addToBackStack(null); // 提交事务 transaction.commit(); &#125;&#125; 在事务提交之前调用了 FragmentTransaction 的 addToBackStack() 方法，它可以接收一个名字用于描述返回栈的状态，一般传入 null 即可。这样问题就解决了。 4.2.4 碎片和活动之间进行通信 为了方便碎片和活动之间进行通信，FragmentManager 提供了一个类似于 findViewById() 的方法，专门用于从布局文件中获取碎片的实例。在活动中调用碎片里的方法： 1RightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment); 在碎片中调用活动里的方法：通过调用 getActivity()方法来得到和当前碎片相关联的活动实例，代码如下所示： 1MainActivity activity = (MainActivity) getActivity(); 4.3 碎片的生命周期 每个活动在其生命周期内可能会有四种状态：运行状态、暂停 状态、停止状态和销毁状态。类似地，每个碎片在其生命周期内也可能会经历这几种状态，只不过在一些细小的地方会有部分区别。 运行状态： 当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。 暂停状态： 当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关联的可见碎片就会进入到暂停状态。 停止状态： 当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态。或者通过调用 FragmentTransaction 的 remove()、replace()方法将碎片从活动中移除，但若在事务提交之前调用 addToBackStack() 方法，这时的碎片也会进入到停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。 销毁状态： 碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用 FragmentTransaction 的 remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用 addToBackStack()方法，这时的碎片也会进入 到销毁状态。 和活动 Acitvity 相似，Fragment 类中也提供了一系列的回调方法，以覆盖碎片生命周期的每个环节。其中，活动中有的回调方法，碎片中几乎都有，不过碎片还提供了一些附加的回调方法，重点来看下这几个回调： onAttach() 当碎片和活动建立关联的时候调用。 onCreateView() 为碎片创建视图（加载布局）时调用。 onActivityCreated() 确保与碎片相关联的活动一定已经创建完毕的时候调用。 onDestroyView() 当与碎片关联的视图被移除的时候调用。 onDetach() 当碎片和活动解除关联的时候调用。 碎片完整的生命周期可参考源自 Android 官网图的示意图： 另外，在碎片中你也可以通过 onSaveInstanceState()方法来保存数据， 因为进入停止状态的碎片有可能在系统内存不足的时候被回收。保存下来的数据在 onCreate()、onCreateView() 和 onActivityCreated()这三个方法中你都可以重新得到，它们都含有一个 Bundle 类型的 savedInstanceState 参数。 4.4 动态加载布局的技巧4.4.1 使用限定符 现有个需求：在平板上使用双页模式，在手机上显示单页模式。那么怎样才能在运行时判断程序应该是使用双页模式还是单页模式呢？这就需要借助限定符（Qualifiers）来实现了。 我们通过一个例子来学习一下它的用法，修改项目中 activity_fragment.xml 的代码： 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_fragment" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;fragment android:id="@+id/fragment_left" android:name="com.wonderful.myfirstcode.inquiry_fragment.LeftFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 这里将多余的代码都删掉，只留下一个左侧碎片，并让它充满整个父布局。接着在 res 目录下新建 layout-large 文件夹，在这个文件夹下新建一个布局，也叫做 activity_fragment.xml， 代码如下所示： 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_fragment" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;fragment android:id="@+id/fragment_left" android:name="com.wonderful.myfirstcode.inquiry_fragment.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;fragment android:id="@+id/fragment_right" android:name="com.wonderful.myfirstcode.inquiry_fragment.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3"/&gt;&lt;/LinearLayout&gt; 可以看到，layout/activity_fragment 布局只包含了一个碎片，即单页模式，而 layout-large/activity_fragment 布局包含了两个碎片，即双页模式。其中 large 就是一个限定符，那些屏幕被认 为是 large 的设备就会自动加载 layout-large 文件夹下的布局，而小屏幕的设备则还是会加载 layout 文件夹下的布局。 然后将 Activity 中 replaceFragment() 方法注释掉，并在平板模拟器上重新运行程序， 效果如图： 再启动一个手机模拟器，并在这个模拟器上重新运行程序，效果如图： Android 中一些常见的限定符可以参考下表： 4.4.2 使用最小宽度限定符 有时候我们希望可以更加灵活地为不同设备加载布局，不管它们是不是被系统 认定为 “ large ”，这时就可以使用最小宽度限定符（Smallest-width Qualifier）了。 最小宽度限定符允许我们对屏幕的宽度指定一个最小指（以 dp 为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局。 在 res 目录下新建 layout-sw600dp 文件夹，然后在这个文件夹下新建 activity_fragment .xml布局，代码与上面 layout-large/activity_fragment 中的一样。 1... 这就意味着，当程序运行在屏幕宽度大于 600dp 的设备上时，会加载 layout-sw600dp/ activity_fragment 布局，当程序运行在屏幕宽度小于 600dp 的设备上时，则仍然加载默认的 layout/activity_fragment 布局。 4.5 碎片的最佳实践——一个简易版的新闻应用 需求：一个简易的新闻应用，可以同时兼容手机和平板。 首先，在 app/build.gradle 中添加后面需要用到的 RecyclerView 依赖库： 123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:recyclerview-v7:24.2.1' testCompile 'junit:junit:4.12'&#125; 接下来，准备好一个新闻的实体类，新建类 News，代码如下所示： 123456789101112131415161718192021222324252627/** * 新闻实体类 * Created by KXwon on 2016/12/12. */public class News &#123; private String title; // 新闻标题 private String content; // 新闻内容 public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 接着新建一个 news_content_frag.xml 布局，作为新闻内容的布局： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/visibility_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:visibility="invisible"&gt; &lt;TextView android:id="@+id/news_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:textSize="20sp" android:padding="10dp"/&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#000"/&gt; &lt;TextView android:id="@+id/news_content" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:textSize="18sp" android:padding="15dp"/&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width="1dp" android:layout_height="match_parent" android:layout_alignParentLeft="true" android:background="#000"/&gt;&lt;/RelativeLayout&gt; 新闻内容的布局主要分为两个部分，头部显示新闻标题，正文显示新闻内容，中间使用一条细线分隔开。 然后再新建一个 NewsContentFragment 类，如下： 1234567891011121314151617181920212223242526272829/** * 新闻内容fragment * Created by KXwon on 2016/12/12. */public class NewsContentFragment extends Fragment &#123; private View view; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; view = inflater.inflate(R.layout.news_content_frag, container, false); return view; &#125; /** * 将新闻标题和新闻内容显示在界面上 * @param newsTitle 标题 * @param newsContent 内容 */ public void refresh(String newsTitle, String newsContent) &#123; View visibilityLayout = view.findViewById(R.id.visibility_layout); visibilityLayout.setVisibility(View.VISIBLE); TextView newsTitleText = (TextView) view.findViewById (R.id.news_title); TextView newsContentText = (TextView) view.findViewById(R.id.news_content); newsTitleText.setText(newsTitle); // 刷新新闻的标题 newsContentText.setText(newsContent); // 刷新新闻的内容 &#125;&#125; 这样就把新闻内容的碎片和布局创建好了，但它们都是在双页模式下使用的，若要在单页模式中使用，还需创建一个活动 NewsContentActivity，其布局 news_content.xml 中的代码如下： 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/news_content_fragment" android:name="com.wonderful.myfirstcode.chapter4.simple_news.NewsContentFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 这里直接在布局中引入了 NewsContentFragment，相当于把 news_content_frag 布局的内容自动加了进来。然后编写 NewsContentActivity 的代码，如下： 1234567891011121314151617181920212223242526272829public class NewsContentActivity extends AppCompatActivity &#123; /** * 构建Intent，传递所需数据 * @param context * @param newsTitle * @param newsContent */ public static void actionStart(Context context, String newsTitle, String newsContent) &#123; Intent intent = new Intent(context, NewsContentActivity.class); intent.putExtra("news_title", newsTitle); intent.putExtra("news_content", newsContent); context.startActivity(intent); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.news_content); // 获取传入的新闻标题、新闻内容 String newsTitle = getIntent().getStringExtra("news_title"); String newsContent = getIntent().getStringExtra("news_content"); // 获取 NewsContentFragment 实例 NewsContentFragment newsContentFragment = (NewsContentFragment) getSupportFragmentManager() .findFragmentById(R.id.news_content_fragment); // 刷新 NewsContentFragment 界面 newsContentFragment.refresh(newsTitle, newsContent); &#125;&#125; 上述代码，在 onCreate() 方法中通过 Intent 获取传入的新闻标题和内容，然后调用 FragmentManager 的 findFragmentById() 方法得到 NewsContentFragment 的实例，接着调用它的 refresh() 方法，并将新闻的标题和内容传入，显示数据。（关于 actionStart() 方法可以阅读前面的探究活动2.5.2相关笔记。） 接下来还需再创建显示新闻列表的布局 news_title_frag.xml，如下： 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/news_title_recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 新建 news_item.xml 作为 上述 RecyclerView 子项的布局： 123456789&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/news_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:singleLine="true" android:ellipsize="end" android:textSize="18sp" android:padding="10dp"/&gt; 子项的布局就只有一个 TextView。 新闻列表和子项布局都创建好了，接下来就需要一个用于展示新闻列表的地方。这里新建 NewsTitleFragment 作为展示新闻列表的碎片： 123456789101112131415161718192021222324252627/** * 新闻列表fragment * Created by KXwon on 2016/12/12. */public class NewsTitleFragment extends Fragment&#123; private boolean isTowPane; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.news_content_frag, container, false); return view; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (getActivity().findViewById(R.id.news_content_layout)!= null)&#123; // 可以找到 news_content_layout 布局时，为双页模式 isTowPane = true; &#125;else &#123; // 找不到 news_content_layout 布局时，为单页模式 isTowPane = false; &#125; &#125;&#125; 为实现上述 onActivityCreated() 方法中判断当前时双页还是单页模式，需要借助限定符，首先修改主布局 activity_news.xml 中的代码： 123456789101112&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/news_title_layout" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/news_title_fragment" android:name="com.wonderful.myfirstcode.chapter4.simple_news.NewsTitleFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/FrameLayout&gt; 上述代码表示，在单页模式下只会加载一个新闻标题的碎片。 然后在 res 目录下新建 layout-sw600dp 文件夹，在这个文件夹下再新建一个 activity_news.xml 文件，代码如下： 1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/news_title_fragment" android:name="com.wonderful.myfirstcode.chapter4.simple_news.NewsTitleFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;FrameLayout android:id="@+id/news_content_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3" &gt; &lt;fragment android:id="@+id/news_content_fragment" android:name="com.wonderful.myfirstcode.chapter4.simple_news.NewsContentFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 上述代码表示，在双页模式下会同时加载两个碎片，并将新闻内容碎片放在 FrameLayout 布局下，这个布局 id 正是 news_content_layout。因此能找到这个 id 的时候就是双页模式，否则就是单页模式。 现在已经将绝大多数工作完成了，剩下至关重要的一点，就是在 NewsTitleFragemt 中通过 RecyclerView 将新闻列表展示出来。接下来在 NewsTitleFragemt 中新建一个内部类 NewsAdapter 来作为 RecyclerView 的适配器，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NewsTitleFragment extends Fragment&#123; private boolean isTowPane; . . . class NewsAdapter extends RecyclerView.Adapter&lt;NewsAdapter.ViewHolder&gt; &#123; private List&lt;News&gt; mNewsList; class ViewHolder extends RecyclerView.ViewHolder &#123; TextView newsTitleText; public ViewHolder(View view) &#123; super(view); newsTitleText = (TextView) view.findViewById(R.id.news_title); &#125; &#125; public NewsAdapter(List&lt;News&gt; newsList) &#123; mNewsList = newsList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_item, parent, false); final ViewHolder holder = new ViewHolder(view); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; News news = mNewsList.get(holder.getAdapterPosition()); if (isTwoPane) &#123; // 若是双页模式，则刷新 NewsContentFragment 中的内容 NewsContentFragment newsContentFragment = (NewsContentFragment) getFragmentManager().findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(news.getTitle(), news.getContent()); &#125; else &#123; // 若是单页模式，则直接启动 NewsContentActivity NewsContentActivity.actionStart(getActivity(), news.getTitle(), news.getContent()); &#125; &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; News news = mNewsList.get(position); holder.newsTitleText.setText(news.getTitle()); &#125; @Override public int getItemCount() &#123; return mNewsList.size(); &#125; &#125; 需要注意的是，这里把适配器写成内部类是为了直接访问 NewsTitleFragment 的变量，比如 isTowPane 。 现在还剩最后一步收尾工作，就是向 RecyclerView 中填充数据了。修改 NewsTitleFragment 中的代码，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class NewsTitleFragment extends Fragment&#123; . . . @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.news_title_frag, container, false); RecyclerView newsTitleRecyclerView = (RecyclerView) view.findViewById(R.id.news_title_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity()); newsTitleRecyclerView.setLayoutManager(layoutManager); NewsAdapter adapter = new NewsAdapter(getNews()); newsTitleRecyclerView.setAdapter(adapter); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (getActivity().findViewById(R.id.news_content_layout) != null) &#123; // 可以找到news_content_layout布局时，为双页模式 isTwoPane = true; &#125; else &#123; // 找不到news_content_layout布局时，为单页模式 isTwoPane = false; &#125; &#125; /** * 初始化50条模拟新闻数据 * @return */ private List&lt;News&gt; getNews() &#123; List&lt;News&gt; newsList = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 50; i++) &#123; News news = new News(); news.setTitle("This is news title " + i); news.setContent(getRandomLengthContent("新闻内容吼吼吼" + i + "!")); newsList.add(news); &#125; return newsList; &#125; /** * 随机生成不同长度的新闻内容 * @param content * @return */ private String getRandomLengthContent(String content) &#123; Random random = new Random(); int length = random.nextInt(20) + 1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; builder.append(content); &#125; return builder.toString(); &#125; . . . &#125; 到这里，所有的代码编写工作就完成了，运行程序，效果如下： 点击一条新闻，会启动一个新的活动来显示新闻内容： 接下来把程序在平板上运行，同样点击一条新闻，效果如下： 好了，关于碎片的内容学习到这，下篇文章将学习广播机制…]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础3 - UI 开发]]></title>
    <url>%2F2015%2F09%2F20%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8003-UI%20%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本文主要介绍以下几个知识点： 百分比布局； 引入布局，自定义控件； RecyclerView 的用法； 制作 Nine_Patch 图片； 实战 实现一个聊天界面。 3.1 百分比布局 百分比布局属于新增布局，在这种布局中，我们可以不再使用 wrap_content、match_parent等方式来指定控件的大小，而是允许直接指定控件布局中所占的百分比，可以轻松实现平分布局甚至任意比例分割布局的效果。 百分比布局只为FrameLayout 和 RelativeLayout 进行功能扩展，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局。 用法：在项目的build.gradle 中添加百分比布局库的依赖： 123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:percent:24.2.1' testCompile 'junit:junit:4.12'&#125; 接下来修改activity_percent.xml中的布局代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435&lt;android.support.percent.PercentFrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/activity_percent" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button1" android:text="button1" android:layout_gravity="left|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button2" android:text="button2" android:layout_gravity="right|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button3" android:text="button3" android:layout_gravity="left|bottom" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt; &lt;Button android:id="@+id/button4" android:text="button4" android:layout_gravity="right|bottom" app:layout_widthPercent="50%" app:layout_heightPercent="50%"/&gt;&lt;/android.support.percent.PercentFrameLayout&gt; 最外层使用了PercentFrameLayout，由于百分比布局并不是内置在系统 SDK 当中的，所以需要把完整路径写下来。然后定义一个app 的命名空间，方可使用百分比布局的自定义属性。PercentFrameLayout继承了FrameLayout的特性。 上述代码中定义了4个按钮，使用app:layout_widthPercent 属性将各按钮的宽度指定为布局的50%，使用app:layout_heightPercent属性将各按钮的高度指定为布局的50%，效果如图： 可以看到，每一个按钮的宽高都占据了布局的50%，轻松实现了4个按钮平分屏幕的效果。 另外一个PercentRelativeLayout的用法类似，继承了RelativeLayout中的所有属性，并可以使用app:layout_widthPercent 和app:layout_heightPercent来按百分比指定控件的宽高。 3.2 创建自定义控件 我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接或间接继承自 ViewGroup 的。View 是 Android 中一种最基本的 UI 组件，它可以在屏幕 上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是 在 View 的基础之上又添加了各自特有的功能。而 ViewGroup 则是一种特殊的 View，它可以 包含很多的子 View 和子 ViewGroup，是一个用于放置控件和布局的容器。 如图所示： 3.2.1 引入布局 来实现个类似iPhone 应用的界面顶部的标题栏， 标题栏上有两个按钮可用于返回或其他操作（iPhone 没有实体返回键）。 新建个布局title.xml，代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/colorAccent" &gt; &lt;Button android:id="@+id/title_back" android:layout_width="60dp" android:layout_height="60dp" android:layout_gravity="center" android:layout_margin="5dip" android:background="@drawable/bg_back" android:textColor="#fff" /&gt; &lt;TextView android:id="@+id/title_text" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_weight="1" android:gravity="center" android:text="Title Text" android:textColor="#fff" android:textSize="24sp" /&gt; &lt;Button android:id="@+id/title_edit" android:layout_width="60dp" android:layout_height="60dp" android:layout_gravity="center" android:layout_margin="5dip" android:background="@drawable/bg_message" android:textColor="#fff" /&gt;&lt;/LinearLayout&gt; 在 LinearLayout 中分别加入了两个 Button 和一个 TextView。 现在标题栏布局已经编写完了，剩下的就是如何在程序中使用这个标题栏了，修改activity_custom_title.xml 中的代码，如下所示： 12345678&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;include layout="@layout/title" /&gt;&lt;/LinearLayout&gt; 只需要通过一行 include 语句将标题栏布局引入进来就可以了。 最后别忘了在 CustomTitleActivity中将系统自带的标题栏隐藏掉，代码如下所示： 123456789101112public class CustomTitleActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_custom_title); ActionBar actionBar = getSupportActionBar(); if (actionBar != null)&#123; actionBar.hide(); // 隐藏系统自带的标题栏 &#125; &#125;&#125; 运行程序，效果如下： 使用这种方式，不管有多少布局需要添加标题栏，只需一行 include 语句就可以了。 3.2.2 创建自定义控件 引入布局的技巧确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁掉当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑又是增加了很多重复代码，这种情况最好是使用自定义控件的方式来解决。 新建 TitleLayout 继承自 LinearLayout，让它成为我们自定义的标题栏控件，代码如下 所示： 12345678910111213141516171819202122232425262728293031/** * 自定义标题栏 * Created by KXwon on 2016/12/9. */public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); // 初始化两个按钮 Button titleBack = (Button) findViewById(R.id.title_back); Button titleMessage = (Button) findViewById(R.id.title_message); // 设置点击事件 titleBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 点击返回按钮销毁当前活动 ((Activity) getContext()).finish(); &#125; &#125;); titleMessage.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getContext(), "You clicked Message button", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 现在自定义控件已经创建好了，然后我们需要在布局文件中添加这个自定义控件，修改activity_custom_title.xml 中的代码，如下所示： 12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.wonderful.myfirstcode.custom_controls.TitleLayout android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 重新运行程序，效果如图所示： 这样的话，每当我们在一个布局中引入 TitleLayout，省去了很多编写重复代码的工作。 3.3 强大的滚动控件——RecyclerView RecyclerView 可以说是一个增强版的 ListView，不仅可以轻松实现ListView 同样的效果，还优化了 ListView 中存在的各种不足。接下来讲解下 RecyclerView 的用法。 3.3.1 RecyclerView 的基本用法 使用 RecyclerView 这个控件，首先需要在项目的 build.gradle 中添加相应的依赖库才行。打开 app/build.gradle 文件，在 dependencies 闭包中添加如下内容： 123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:recyclerview-v7:24.2.1' testCompile 'junit:junit:4.12'&#125; 然后修改activity_recycler_view.xml中的代码： 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_recycler_vew" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.wonderful.myfirstcode.custom_controls.recycler_view.RecyclerVewActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 我们的目的是为了用 RecyclerView 来展示一个水果列表，先建立一个水果 Fruit 类： 123456789101112131415161718192021222324252627282930/** * 水果类 * Created by KXwon on 2016/12/11. */public class Fruit &#123; private String name; // 水果名 private int imageId; // 水果图片id public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getImageId() &#123; return imageId; &#125; public void setImageId(int imageId) &#123; this.imageId = imageId; &#125;&#125; 以及展示水果的布局 fruit_item.xml： 123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt; 接下来为 RecyclerView 准备一个适配器，新建 FruitAdapter 类，让这个适配器继承RecyclerView.Adapter，并将泛型指定为 FruitAdapter.ViewHolder。其中，ViewHolder 是我们在 FruitAdapter 中定义的一个内部类，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 水果适配器 * Created by KXwon on 2016/12/11. */public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123; private List&lt;Fruit&gt; mFruitList; /** * 构造函数，用于把要展示的数据源传进来 * @param mFruitList */ public FruitAdapter(List&lt;Fruit&gt; mFruitList) &#123; this.mFruitList = mFruitList; &#125; /** * 创建ViewHolder实例 * @param parent * @param viewType * @return */ @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); ViewHolder holder = new ViewHolder(view); return holder; &#125; /** * 对RecyclerView子项的数据进行赋值 * @param holder * @param position */ @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; /** * 子项的数目 * @return */ @Override public int getItemCount() &#123; return mFruitList.size(); &#125; /** * 内部类，ViewHolder要继承自 RecyclerView.ViewHolder */ public class ViewHolder extends RecyclerView.ViewHolder&#123; ImageView fruitImage; TextView fruitName; public ViewHolder(View itemView) &#123; super(itemView); fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 适配器准备好了之后，可以开始使用 RecyclerView 了，activity中的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RecyclerVewActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycler_view); // 初始化水果数据 initFruits(); // 获取RecyclerView的实例 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); // LayoutManager用于指定RecyclerView的布局方式，LinearLayoutManager表示线性布局 LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); // 创建FruitAdapter的实例 FruitAdapter adapter = new FruitAdapter(fruitList); // 设置适配器 recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i = 0;i &lt; 2;i++)&#123; Fruit apple = new Fruit("Apple",R.drawable.pic_apple); fruitList.add(apple); Fruit banana = new Fruit("Banana",R.drawable.pic_banana); fruitList.add(banana); Fruit orange = new Fruit("orange",R.drawable.pic_orange); fruitList.add(orange); Fruit watermelon = new Fruit("watermelon",R.drawable.pic_watermelon); fruitList.add(watermelon); Fruit grape = new Fruit("grape",R.drawable.pic_grape); fruitList.add(grape); Fruit pineapple = new Fruit("pineapple",R.drawable.pic_pineapple); fruitList.add(pineapple); Fruit strawberry = new Fruit("strawberry",R.drawable.pic_strawberry); fruitList.add(strawberry); Fruit cherry = new Fruit("cherry",R.drawable.pic_cherry); fruitList.add(cherry); Fruit mango = new Fruit("mango",R.drawable.pic_mango); fruitList.add(mango); &#125; &#125;&#125; 运行效果如下： 3.3.2 实现横向滚动和瀑布流布局 用 RecyclerView 实现横向滚动效果，修改 fruit_item.xml 中的代码： 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="100dp" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="60dp" android:layout_height="60dp" android:padding="5dp" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="10dp"/&gt;&lt;/LinearLayout&gt; 上述代码中，把 LinearLayout 改成了垂直方向，宽度设为 100dp，把 ImageView 和 TextView 设成了布局中水平居中，接下来修改 activity 中的代码： 12345678910111213141516171819202122232425public class RecyclerVewActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycler_view); // 初始化水果数据 initFruits(); // 获取RecyclerView的实例 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); // LayoutManager用于指定RecyclerView的布局方式，LinearLayoutManager表示线性布局 LinearLayoutManager layoutManager = new LinearLayoutManager(this); // 设置布局横向排列（默认是纵向排列的） layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); recyclerView.setLayoutManager(layoutManager); // 创建FruitAdapter的实例 FruitAdapter adapter = new FruitAdapter(fruitList); // 设置适配器 recyclerView.setAdapter(adapter); &#125; ...&#125; activity 中只加了一行代码，调用 LinearLayoutManager 的 setOrientation() 方法来设置布局的排列方向，运行程序，效果如下： 除了 LinearLayoutManager 之外，RecyclerView 还提供了 GridLayoutManager 和 StaggeredGridLayoutManager 两种内置的布局排列方式。GridLayoutManager 实现网格布局，StaggeredGridLayoutManager 实现瀑布流布局。 接下来实现下瀑布流布局，首先修改 fruit_item.xml 中的代码： 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="5dp"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:layout_marginTop="10dp"/&gt;&lt;/LinearLayout&gt; 上述代码中，把 LinearLayout 的宽度设为 match_parent 因为瀑布流布局的宽度是根据布局的列数来自动适配的，而不是一个固定值，把 TextView 设成了居左对齐，接下来修改 activity 中的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RecyclerVewActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycler_view); // 初始化水果数据 initFruits(); // 获取RecyclerView的实例 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); // 创建StaggeredGridLayoutManager的实例（构造函数中的两个参数：第一个指定布局的列数，第二个指定布局的排列方向） StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); // 创建FruitAdapter的实例 FruitAdapter adapter = new FruitAdapter(fruitList); // 设置适配器 recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i = 0;i &lt; 2;i++)&#123; for (int i = 0;i &lt; 2;i++)&#123; Fruit apple = new Fruit(getRandomLengthName("Apple"),R.drawable.pic_apple); fruitList.add(apple); Fruit banana = new Fruit(getRandomLengthName("Banana"),R.drawable.pic_banana); fruitList.add(banana); Fruit orange = new Fruit(getRandomLengthName("orange"),R.drawable.pic_orange); fruitList.add(orange); Fruit watermelon = new Fruit(getRandomLengthName("watermelon"),R.drawable.pic_watermelon); fruitList.add(watermelon); Fruit grape = new Fruit(getRandomLengthName("grape"),R.drawable.pic_grape); fruitList.add(grape); Fruit pineapple = new Fruit(getRandomLengthName("pineapple"),R.drawable.pic_pineapple); fruitList.add(pineapple); Fruit strawberry = new Fruit(getRandomLengthName("strawberry"),R.drawable.pic_strawberry); fruitList.add(strawberry); Fruit cherry = new Fruit(getRandomLengthName("cherry"),R.drawable.pic_cherry); fruitList.add(cherry); Fruit mango = new Fruit(getRandomLengthName("mango"),R.drawable.pic_mango); fruitList.add(mango); &#125; &#125; /** * 随机生成水果名字的长度 * @param name * @return */ private String getRandomLengthName(String name)&#123; Random random = new Random(); int length = random.nextInt(20)+1; StringBuilder builder = new StringBuilder(); for (int i = 0 ;i &lt; length;i++)&#123; builder.append(name); &#125; return builder.toString(); &#125;&#125; 至此，已成功实现瀑布流效果了，运行程序，效果如下： 3.3.3 RecyclerView 的点击事件 不同于 ListView 的是，RecyclerView 并没有提供类似 setOnItemClickListener() 这样的注册监听方法，而是需要给子项具体的 view 去注册点击事件。 为实现 RecyclerView 中注册点击事件，修改 FruitAdapter 中的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 水果适配器 * Created by KXwon on 2016/12/11. */public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123; private List&lt;Fruit&gt; mFruitList; /** * 构造函数，用于把要展示的数据源传进来 * @param mFruitList */ public FruitAdapter(List&lt;Fruit&gt; mFruitList) &#123; this.mFruitList = mFruitList; &#125; /** * 创建ViewHolder实例 * @param parent * @param viewType * @return */ @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); final ViewHolder holder = new ViewHolder(view); // 为最外层布局注册点击事件 holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); ToastUtils.showShort("you clicked view"+ fruit.getName()); &#125; &#125;); // 为ImageView注册点击事件 holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); ToastUtils.showShort("you clicked image"+ fruit.getName()); &#125; &#125;); return holder; &#125; /** * 对RecyclerView子项的数据进行赋值 * @param holder * @param position */ @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; /** * 子项的数目 * @return */ @Override public int getItemCount() &#123; return mFruitList.size(); &#125; /** * 内部类，ViewHolder要继承自 RecyclerView.ViewHolder */ public class ViewHolder extends RecyclerView.ViewHolder&#123; View fruitView; // 添加fruitView变量来保存子项最外层布局的实例 ImageView fruitImage; TextView fruitName; public ViewHolder(View itemView) &#123; super(itemView); fruitView = itemView; fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 上述代码，先修改了 ViewHolder，在 ViewHolder 中添加了 fruitView 变量来保存子项最外层布局的实例，然后在 onCreateViewHolder() 方法中注册点击事件就可以了。这里分别为最外层布局和 ImageView 注册了点击事件。RecyclerView 的强大之处在于可以轻松实现子项中任意控件或布局的点击事件。 运行程序，并点击香蕉的图片部分，效果如下： 点击菠萝的文字部分，由于 TextView 没有注册监听事件，因此点击文字会被子项的最外层布局捕获到，效果如下： 3.4 编写界面的最佳实践3.4.1 制作 Nine_Patch 图片 若项目中有一张气泡样式的图片 message_left.png，如图所示 若将这张图片设置为一个 LinearLayout 的背景图片，代码如下所示： 123456&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/message_left"&gt;&lt;/LinearLayout&gt; 将 LinearLayout 的宽度指定为 match_parent，然后将它的背景图设置为 message_left，运行程序，效果如图： 可以看到，由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了！这种效果非常差，这时我们就可以使用 Nine-Patch 图片来进行改善。 在 Android sdk 目录下有一个 tools 文件夹，在这个文件夹中找到 draw9patch.bat 文件， 我们就是使用它来制作 Nine-Patch 图片的。双击打开draw9patch.bat 文件，在导航栏点击 File→Open 9-patch 将准备好的图片 message_left.png 加载进来，如图所示： 我们可以在图片的四个边框绘制一个个的小黑点，在上边框和左边框绘制的部分就表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分则表示内容会被放置的区域。使用鼠标在图片的边缘拖动就可以绘制了，按住 Shift 键拖动可以进行擦除，完成后效果如图所示： 最后保存即可。用制作好的图片替换掉之前的 message_left.png 图片，重新运行程序，效果如图所示： 接下来进入实战环节。 3.4.2 编写精美的聊天界面 上面制作的 message_left.9.png 可以作为收到消息的背景图，再制作一张 message_right.9.png 作为发出消息的背景图。 图片都提供好了之后就可以开始编码了。首先需要在 app/buiild.gradle 当中添加要用到的 RecyclerView 依赖库： 123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:recyclerview-v7:24.2.1' testCompile 'junit:junit:4.12'&#125; 接下来编写主界面，编写主界面 activity_ui_best_practice.xml 中的代码如下： 123456789101112131415161718192021222324252627282930313233&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="#d8e0e8"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/msg_recycler_view" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;EditText android:id="@+id/et_input_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="Type something here" android:maxLines="2"/&gt; &lt;Button android:id="@+id/btn_send" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Send" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 上述代码在主界面放置了一个 RecyclerView 来显示聊天的消息内容，放置了一个 EditText 用于输入消息，放置了一个 Button 用于发送消息。 然后定义消息的实体类，新建 Msg，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536/** * 消息实体类 * Created by KXwon on 2016/12/11. */public class Msg &#123; public static final int TYPE_RECEIVED = 0; // 收到的消息类别 public static final int TYPE_SENT = 1; // 发出的消息类别 private String content; // 消息内容 private int type; // 消息类型 public Msg(String content, int type) &#123; this.content = content; this.type = type; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125;&#125; 接着编写 RecyclerView 子项的布局，新建 msg_item.xml，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:padding="10dp"&gt; &lt;!-- ************ 收到的消息居左对齐 ************ --&gt; &lt;LinearLayout android:id="@+id/left_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:background="@drawable/message_left"&gt; &lt;TextView android:id="@+id/left_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" android:textColor="#fff"/&gt; &lt;/LinearLayout&gt; &lt;!-- ************ 发送的消息居右对齐 ************ --&gt; &lt;LinearLayout android:id="@+id/right_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:background="@drawable/message_right"&gt; &lt;TextView android:id="@+id/right_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 接下来创建 RecyclerView 的适配器，新建 MsgAdapter，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 消息适配器 * Created by KXwon on 2016/12/11. */public class MsgAdapter extends RecyclerView.Adapter&lt;MsgAdapter.ViewHolder&gt;&#123; private List&lt;Msg&gt; mMsgList; public MsgAdapter(List&lt;Msg&gt; mMsgList) &#123; this.mMsgList = mMsgList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item,parent,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Msg msg = mMsgList.get(position); if (msg.getType() == Msg.TYPE_RECEIVED)&#123; // 若是收到的消息，则显示左边的布局消息，将右边的消息布局隐藏 holder.leftLayout.setVisibility(View.VISIBLE); holder.rightLayout.setVisibility(View.GONE); holder.leftMsg.setText(msg.getContent()); &#125;else if (msg.getType() == Msg.TYPE_SENT)&#123; // 若是发送的消息，则显示右边的布局消息，将左边的消息布局隐藏 holder.leftLayout.setVisibility(View.GONE); holder.rightLayout.setVisibility(View.VISIBLE); holder.rightMsg.setText(msg.getContent()); &#125; &#125; @Override public int getItemCount() &#123; return mMsgList.size(); &#125; static class ViewHolder extends RecyclerView.ViewHolder&#123; LinearLayout leftLayout, rightLayout; TextView leftMsg, rightMsg; public ViewHolder(View view) &#123; super(view); leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); leftMsg = (TextView) view.findViewById(R.id.left_msg); rightMsg = (TextView) view.findViewById(R.id.right_msg); &#125; &#125;&#125; 最后修改 activity 中的代码，来为 RecyclerView 初始化一些数据，并给发送消息加入事件响应，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class UIBestPracticeActivity extends AppCompatActivity &#123; private List&lt;Msg&gt; msgList = new ArrayList&lt;&gt;(); private EditText et_input_text; private Button btn_send; private RecyclerView msgRecyclerView; private MsgAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_ui_best_practice); initMsg(); // 初始化消息数据 et_input_text = (EditText) findViewById(R.id.et_input_text); btn_send = (Button) findViewById(R.id.btn_send); msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); msgRecyclerView.setLayoutManager(layoutManager); adapter = new MsgAdapter(msgList); msgRecyclerView.setAdapter(adapter); btn_send.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String content = et_input_text.getText().toString(); if (!"".equals(content))&#123; Msg msg = new Msg(content,Msg.TYPE_SENT); msgList.add(msg); // 当有新消息时，刷新RecyclerView中的显示 adapter.notifyItemInserted(msgList.size() - 1); // 将RecyclerView定位到最后一行 msgRecyclerView.scrollToPosition(msgList.size() - 1); // 清空输入框中的内容 et_input_text.setText(""); &#125; &#125; &#125;); &#125; private void initMsg() &#123; Msg msg1 = new Msg("Hello world!",Msg.TYPE_RECEIVED); msgList.add(msg1); Msg msg2 = new Msg("Hello. Who is that?",Msg.TYPE_SENT); msgList.add(msg2); Msg msg3 = new Msg("。。。",Msg.TYPE_SENT); msgList.add(msg3); Msg msg4 = new Msg("This is 逗逼. Nice talking to you",Msg.TYPE_RECEIVED); msgList.add(msg4); &#125;&#125; 这样一个可以输入和发送消息的聊天界面所有的工作就都完成了，运行程序，效果如下： 至此，第三章笔记就到这，下篇文章将学习碎片的知识。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础2 - 探究活动]]></title>
    <url>%2F2015%2F09%2F15%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8002-%E6%8E%A2%E7%A9%B6%E6%B4%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[本文主要介绍以下几个知识点： 显示、隐式 Intent 的相关内容； 活动 Activity 的生命周期； 活动 Activity 的启动模式； 活动的最佳实践：活动管理类、启动活动的最佳写法。 2.1 活动是什么 活动（ activity ）是一种可以包含用户界面的组件，主要用于和用户进行交互。 2.2 使用 Intent 在活动之间穿梭 Intent 大致可分为两种：显示 Intent 和 隐式 Intent 2.2.1 使用显示 Intent Intent 有多个构造函数的重载，其中一个是Intent(Context packageContext，Class&lt;?&gt;cls) 第一个参数Context要求提供一个启动活动的上下文 第二个参数Class则是指定想要启动的目标活动 代码如下所示： 123// 显示IntentIntent intent = new Intent(FirstActivity.this,SecondActivity.class);startActivity(intent); 2.2.2 使用隐式 Intent 隐式 Intent并不明确指出想要启动哪一个活动，而是指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个Intent，并找出合适的活动去启动。 用法：打开 AndroidManifest.xml ，添加如下代码： 1234567&lt;activity android:name=".inquiry_activity.SecondActivity"&gt; &lt;intent-filter&gt; &lt;!-- 指定活动能响应的action和category --&gt; &lt;action android:name="com.wonderful.ACTION_START"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 此时在activity中的代码修改为： 123// 隐式IntentIntent intent = new Intent("com.wonderful.ACTION_START");startActivity(intent); 只有和中的内容同时能够匹配上Intent中指定的 action 和 category 时，活动才能响应该Intent。 上例中android.intent.category.DEFAULT是一种默认的category，若Intent中增加一个category： 1234// 隐式IntentIntent intent = new Intent("com.wonderful.ACTION_START");intent.addCategory("com.wonderful.MY_CATEGORY");//增加一个categorystartActivity(intent); 此时在 标签中应再添加一个category声明： 123456789&lt;activity android:name=".inquiry_activity.SecondActivity"&gt; &lt;intent-filter&gt; &lt;!-- 指定活动能响应的action和category --&gt; &lt;action android:name="com.wonderful.ACTION_START"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;!-- 新添加的category --&gt; &lt;category android:name="android.intent.category.MY_CATEGORY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.2.3 更多隐式 Intent 的用法 使用隐式Intent，还可以启动其他程序的活动，比如调用系统的浏览器来打开某个网页： 1234// 隐式Intent：打开网页Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse("http://www.baidu.com"));startActivity(intent); 比如调用系统的拨号界面： 1234// 隐式Intent：打开系统拨号界面Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse("tel:10086"));startActivity(intent); 2.2.4 向下一个活动传递数据 Intent中提供了一系列 putExtra() 方法的重载，可把要传递的数据暂存在Intent中，启动了另一个活动后再从Intent中取出。 如FirstActivity中传递一个字符串到SecondActivity中，FirstActivity中的代码为： 1234String data = "hello SecondActivity";Intent intent = new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra("extra_data",data);startActivity(intent); SecondActivity中的代码如下： 1234Intent intent = getIntent();// String:getStringExtra(); int:getIntExtra(); 布尔型:getBooleanExtra() ...以此类推String data = intent.getStringExtra("extra_data");Log.d(TAG, data); 2.2.5 返回数据给上一个活动 Activity 中有个 startActivityForResult() 方法用于启动活动，此方法在活动销毁时能返回一个结果给上个活动。 startActivityForResult()方法接收两个参数：Intent、请求码（用作回调时判断数据来源）。 修改FirstActivity中的代码如下： 12Intent intent = new Intent(FirstActivity.this,SecondActivity.class);startActivityForResult(intent,1);//请求码只要是唯一值就行了，这里传入1 接着在SecondActivity中添加返回数据： 1234Intent intent = new Intent();intent.putExtra("data_return","hello FirstActivity");setResult(RESULT_OK,intent);finish();//销毁当前活动 在SecondActivity被销毁后回调上一个活动的 onActivityResult() 方法，因此还需要在FirstActivity中重写此方法来得到返回数据： 12345678910111213141516171819/* * 处理得到的返回数据 * @param requestCode 启动活动时传入的请求码 * @param resultCode 返回数据时传入的处理结果 * @param data 携带返回数据的Intent */@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode)&#123; case 1: if (resultCode == RESULT_OK)&#123; String returnedData = data.getStringExtra("data_return"); Log.d(TAG, returnedData); &#125; break; default: break; &#125;&#125; 若在SecondActivity是通过按下Back键回到FirstActivity，可以在SecondActivity中重写 onBackPressed() 方法： 1234567@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra("data_return","hello FirstActivity"); setResult(RESULT_OK,intent); finish();&#125; 2.3 活动的生命周期2.3.1 返回栈 Android 是使用任务 （Task） 来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈 （Back Stack） 。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们 按下 Back 键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。如图所示： 2.3.2 活动状态 每个活动在其生命周期中最多可能会有四种状态。 运行状态 活动位于返回栈的栈顶。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。 暂停状态 活动不再处于栈顶位置，但仍然可见。（并不是每一个活动都会占满整个屏幕的，如对话框形式的活动只会占用屏幕中间的部分区域）。 处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种活动。 停止状态 活动不再处于栈顶位置，并且完全不可见的时候。系统仍然会为这种活动保存相应的状态和成员变量，但这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。 销毁状态 当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。 2.3.3 活动的生存期Activity 类中定义了七个回调方法，覆盖了活动生命周期的每一个环节 onCreate() 在活动第一次被创建的时候调用。在这个方法中完成活动的初始化操作，如加载布局、绑定事件等。 onStart() 在活动由不可见变为可见的时候调用。 onResume() 在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。 onPause() 在系统准备去启动或恢复另一个活动的时候调用。（释放一些消耗 CPU 的资源，保存一些关键数据）。 onStop() 在活动完全不可见的时候调用。它和onPause()方法的主要区别在于，若启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop() 方法并不会执行。 onDestroy() 在活动被销毁之前调用，之后活动的状态将变为销毁状态。 onRestart() 在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。 以上七个方法中除了 onRestart()方法，其他都是两两相对的，从而又可以将活动分为三种生存期。 1. 完整生存期： 活动在 onCreate()方法和 onDestroy()方法之间所经历的； 2. 可见生存期： 活动在 onStart()方法和 onStop()方法之间所经历的； 3. 前台生存期： 活动在 onResume()方法和 onPause()方法之间所经历的。 Android 官方提供了一张活动生命周期的示意图，如图所示： 2.3.4 活动被回收了怎么办 Activity 中提供了一个 onSaveInstanceState() 回调方法，这 个方法会保证一定在活动被回收之前调用。 onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，如用 putString() 方法保存字符串，用 putInt() 方法保存整型数据， 以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle 中取值， 第二个参数是真正要保存的内容。 在Activity 中添加如下代码就可以将临时数据进行保存： 123456@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); String tempData = "Something you just typed"; outState.putString("data_key", tempData);&#125; Activity 被回收后的恢复操作，修改其onCreate()方法，如下所示： 123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null) &#123; // 若不为空，取出相应的数据 String tempData = savedInstanceState.getString("data_key"); Log.d(TAG, tempData); &#125;&#125; 2.4 活动的启动模式 启动模式一共有四种，分别是 standard 、singleTop 、singleTask 和 singleInstance，可以在AndroidManifest.xml 中通过给 标签指定 android:launchMode 属性来选择启动模式。 2.4.1 standard standard 是活动默认的启动模式，在不进行显式指定的情况下，所有活动都会自动使用这种启动模式。 在 standard 模式（即默认情况）下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用 standard 模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建 该活动的一个新的实例。 standard 模式的原理示意图，如图所示： 2.4.2 singleTop 当活动的启动模式指定为 singleTop ，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。 singleTop模式的原理示意图，如图所示： 2.4.3 singleTask 当活动的启动模式指定为 singleTask ，每次启动该活动时系统首先 会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 singleTask模式的原理示意图，如图所示： 2.4.4 singleInstance 不同于以上三种启动模式，指定为 singleInstance 模式的活动会启用一 个新的返回栈来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈）。 singleInstance模式的原理示意图，如图所示： 2.5 活动的最佳实践2.5.1 随时随地退出程序 用一个专门的集合类对所有的活动进行管理，新建一个 ActivityCollector 类作为活动管理器，代码如下所示： 1234567891011121314151617181920public class ActivityCollector &#123; // 通过一个List来缓存活动 public static List&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;(); // 用于向List中添加一个活动 public static void addActivity(Activity activity) &#123; activities.add(activity); &#125; // 用于从List中移除活动 public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125; // 将List中存储的活动全部销毁掉 public static void finishAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125;&#125; 在活动管理器中，我们通过一个 List 来暂存活动，然后提供了一个 addActivity() 方法用于向 List 中添加一个活动，提供了一个 removeActivity() 方法用于从 List 中移除活动，最后提供了一个 finishAll() 方法用于将 List 中存储的活动全部都销毁掉。 接下来修改 BaseActivity 中的代码，如下所示： 1234567891011121314public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d("BaseActivity", getClass().getSimpleName());// 知晓当前是在哪一个活动 ActivityCollector.addActivity(this);// 将当前正在创建的活动添加到活动管理期里 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this);// 将一个马上要销毁的活动从管理器里移除 &#125;&#125; 在 BaseActivity 的 onCreate()方法中调用了 ActivityCollector 的 addActivity() 方法，表明将当前正在创建的活动添加到活动管理器里。然后在 BaseActivity 中重写 onDestroy() 方法， 并调用了 ActivityCollector 的 removeActivity() 方法，表明将一个马上要销毁的活动从活动管理器里移除。 从此以后，不管你想在什么地方退出程序，只需要调用 ActivityCollector.finishAll() 方法就可以了。 当然你还可以在销毁所有活动的代码后面再加上杀掉当前进程的代码，以保证程序完全退出，杀掉进程代码如下： 12// killProcess()方法用于杀掉一个进程，它接收一个进程id参数，可通过myPid()方法获得当前程序的进程idandroid.os.Process.killProcess(android.os.Process.myPid()); 需注意： killProcess() 方法只能用于杀掉当前程序的进程，不能杀掉其他程序。 2.5.2 启动活动的最佳写法 启动活动的方法：通过 Intent 构建出当前的“意图”，然后调用 startActivity() 或 startActivityForResult() 方法将活动启动起来，如果有数据需要从一个活 动传递到另一个活动，也可以借助 Intent 来完成。 假设 SecondActivity 中需要用到两个非常重要的字符串参数，在启动 SecondActivity 的 时候必须要传递过来，那么我们很容易会写出如下代码：1234Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra("param1", "data1");intent.putExtra("param2", "data2"); startActivity(intent); 但此时 SecondActivity 并不是由你开发的，但现在你负责的部分需要有启动SecondActivity 这个功能，而你却不清楚启动这个活动需要传递哪些数据。这时无非就有两种办法，一个是你自己去阅读 SecondActivity 中的代码，二是询问负责编写 SecondActivity的同事。你会不会觉得很麻烦呢？其实只需要换一种写法，就可以轻松解决掉上面的窘境。 修改 SecondActivity 中的代码，如下所示：123456789public class SecondActivity extends BaseActivity &#123; public static void actionStart(Context context, String data1, String data2) &#123; Intent intent = new Intent(context, SecondActivity.class); intent.putExtra("param1", data1); intent.putExtra("param2", data2); context.startActivity(intent); &#125;……&#125; 我们在 SecondActivity 中添加了一个 actionStart() 方法，在这个方法中完成了 Intent 的构建，另外所有 SecondActivity 中需要的数据都是通过 actionStart()方法的参数传递过来的，然后把它们存储到 Intent 中，最后调用 startActivity()方法启动 SecondActivity。 这样写的好处在哪里呢？最重要的一点就是一目了然，SecondActivity 所需要的数据全 部都在方法参数中体现出来了，这样即使不用阅读 SecondActivity 中的代码，或者询问负责编写 SecondActivity 的同事，你也可以非常清晰地知道启动 SecondActivity 需要传递哪些数据。 另外，这样写还简化了启动活动的代码，现在只需要一行代码就可以启动 SecondActivity， 如下所示：1SecondActivity.actionStart(FirstActivity.this, "data1", "data2"); 好了，今天就到这，下篇文章将进入–UI开发学习。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发基础1 - 启程]]></title>
    <url>%2F2015%2F09%2F08%2FAndroid%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%8001-%E5%90%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. Android系统架构四层架构: Linux内核层 、 系统运行库层 、 应用框架层 、 应用层 。如图所示： 1.1 Linux内核层Android系统是基于 Linux 内核的，这层为Android设备的各种硬件提供了底层驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。 1.2 系统运行库层这一层通过一层C/C++库来为Android系统提供了主要的特性支持。如SQLite库（数据支持）等。 同样在这一层还有Android运行时库，主要提供了一些核心库，能允许开发者使用Java语言来编写Android应用。另外，Android运行时库还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境）。 1.3 应用框架层这一层主要提供了构建应用程序时可能用到的各种API。 1.4 应用层所有安装在手机上的应用程序都是属于这一层，包括你自己开发的程序。 2. Android四大组件活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）。 3. Android Studio中的build.gradle文件解析先看下app目录下的 build.gradle 文件：1234567891011121314151617181920212223242526272829303132apply plugin: 'com.android.application'android &#123; compileSdkVersion 24 buildToolsVersion "24.0.2" defaultConfig &#123; applicationId "com.example.networktest" minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName "1.0" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; compileOptions &#123; targetCompatibility 1.7 sourceCompatibility 1.7 &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.squareup.okhttp3:okhttp:3.4.1' compile 'com.google.code.gson:gson:2.7'&#125; 在这主要分析 buildTypes 闭包：buildTypes闭包中用于指定生成安装文件的相关配置，一般有两个子闭包：debug（可忽略不写）、release。 release 闭包中： minifyEnabled 用于指定是否对项目的代码进行混淆，true表示混淆，false表示不混淆。 proguardFiles 用于指定混淆时使用的规则文件：第一个 proguard-android.txt 是在Android SDK目录下的，里面是所有项目通用的混淆规则；第二个 proguard-rules.pro 是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则。 4. Android Studio中的一些快捷键 运行程序：Shift+F10 打印 debug 级别的日志：输入logd后按下 Tab 键 打印 info 级别的日志：输入logi后按下 Tab 键 打印 warn 级别的日志：输入logw后按下 Tab 键 … 以此类推 生成 TAG 常量：在 onCreate（）方法的外面输入logt后按下 Tab 键]]></content>
      <tags>
        <tag>Android</tag>
        <tag>gradle</tag>
        <tag>Android Studio</tag>
        <tag>java</tag>
        <tag>《第一行代码》（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始设计一台CNC机床【下】]]></title>
    <url>%2F2015%2F03%2F18%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%8F%B0CNC%E6%9C%BA%E5%BA%8A%E3%80%90%E4%B8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[这篇文章记录了我有史以来我最喜欢的数控机床的设计。它实际上已经是我做的第三台机器了，它是基于前一台的改进。在我设计这台机器之前已经有设计过一台机器，所以我这次必须设计出更复杂的部分。我的目标是做一个小型台式数控铣床，这样我可以很容易地制作一些电子或机械项目的小零件。没有这台数控机床之前，公司一直在使用这些原型板来焊接PCB。通常花好几个晚上才能焊接好一块控制板，然后再花几个晚上调试它。如果电路板有一个严重的问题，或者要做出一些改进，然后又不得不重新开始。有这一台机器后，一切都变得那么简单。可以使用 EDA 软件来设计PCB，并验证了电路板的可靠性。有些时候，我得到了一个好主意，然后我就可以直接试验，并且在一天之内就可以进行测试。我还使用 SolidWorks 与 Altium Designer 的工作，因为我的大部分项目都是机电一体化的。直接将电路板导入到SolidWorks并检查它是否符合项目需求或机器人设计要求，这样更加的方便快捷。 不管怎样，让我们​​开始切入正题。下面是本机的规格参数： 尺寸：50x40x30厘米 重量：10-20公斤 工作区：22x32x10厘米（比A4纸大） 进给速度：自由运行4.5米/分钟 PCB：2.5米/分钟 钻孔：60-150孔/分钟 铝：100-500毫米/分钟 主轴：27,000 RPM，300W，BLDC 公差：&lt;=0.05毫米 电源：Swtiching电源 电机：两相步进电机 控制器： CNCUSB ， GRBL ，我自己的控制器 SolidWorks建模在这里有很多的改进。第一个是工作面，之前的机器使用了几个月后，我意识到它的工作面很小。有时候，很多材料的尺寸为20×30厘米，有时我不得不削减的尺寸来配合这个工作面。所以，大量的材料就浪费了，因为材料的其余部分太小了，无法做其它用途。这就是为什么我决定做X轴和Y轴尺寸设计为22×32厘米，另外，我还增长了Z轴，这样我可以很容易地改变工具的位置或许我还可以在工作台上加一个虎钳。 底座底座采用10毫米铝板。我需要钻一些孔做定位。这两个支柱之间的桥梁很坚固，当我移动机器时可以作为一个手柄。 Y轴这一次，我取消了平台上的铝合金型材，使之更加紧凑。为了固定的更稳和省去装夹具的麻烦，我在边缘均匀的打了一些孔。在该平台上实际上有一个PVC板，以保护铝板。 X坐标实际上下图的棒材夹持器不在真正的机器上。这只是为了简化三个分离架设计一种尝试。原来，这不是很好的想法，因为我可以购买标准件，但我却花费大量的时间来做出这样一个相同的零件。而这种设计实际上并没有带来任何好处。也许，这种设计很适合批量生产（回想我当初的设计，我为什么要设计一个3合1的支架的原因是为了减少装配误差，并保持杆和螺钉的平行。因为当时我没有专业的校准工具，我想让装配根容易，但在权衡成本和精度后，我决定去便宜的东西，嗨～经费不足啊！）。 Z轴就像X轴，我使用正时皮带，来降低高度。我用滑轨而不是导杆棒，来减少尺寸和增加强度。导轨比导杆棒更贵，因此仅在Z轴使用。还有滚珠丝杠驱动器相对于X和Y轴的直径也较小。 主轴这个小主轴很强悍！我找遍了市场上所有的主轴，没有比这更好的。它直径很小，但有300W的功率。它可以运行 27000 转。唯一的不足的是，这个是风扇散热，不是水冷却。所以这有点吵。我还做了一个铝制散热片帮助散热。 X轴，Z轴和主轴 X轴，Y轴，Z轴和主轴 机器相片 控制器的特写镜头，布线有点乱。你会看到很多插槽，我用这个控制箱来测试我自己的控制软件。 更多照片： 工作中的机器。所以有点乱… 打样照片下面是本机制造的一些零件。木雕的龙 橡皮擦雕刻 PVC头骨 PCB蚀刻 铝件 其它零件 更多阅读该项目只是整个数控项目的一部分。如果你对控制器开发有兴趣，可以点击这里。如果你对CAM软件开发有兴趣，加工PCB的生成刀具路径，可以点击这里。还可以点击这里下载SolidWorks模型文件。]]></content>
      <tags>
        <tag>CNC</tag>
        <tag>机床</tag>
        <tag>机械设计</tag>
        <tag>数控机床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时钟绘制机械手的设计优化]]></title>
    <url>%2F2015%2F02%2F04%2F%E6%97%B6%E9%92%9F%E7%BB%98%E5%88%B6%E6%9C%BA%E6%A2%B0%E6%89%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[介绍一个时钟绘制机械手的小程序，这是一个非常有趣的小时钟，由两个机器人剪刀臂在一个面板上绘制时间。如果之前你从来没有看到它是怎么工作的，先看这个。这是2015年，这是我在网上看到的一个非常有趣的小机械手。当时我试图自己去做一个，但这个想法由于一些其它事情而被耽搁了，因此有很长一段时间我在想怎么去做一个？下面是我当时想的几点问题： 1、最初的设计者是如何计算出的每一个手臂的长度？ 2、图纸面积有多大？ 3、我该如何使它更大？ 4、如何提高精度？在用SolidWorks绘制机械臂结构时，我做了一些数学计算，得到了它是如何工作的基本思路。然后，我决定用精确的参数，让每个手臂得到的最佳仿真结果，这是我最终得到的程序，非常完美，确实可以工作。实施这个计划的核心是插值代码，包括直线插补和圆弧插补，所以线性插值基本上我们从给定的点，然后计算下一个相邻的点和画它，做这一路的终点，圆弧插补是一样的但我们用sin和cos函数计算各点。既然插补问题就解决了，那么下一个问题是如何将手臂移动到该点呢？让我们以左臂为例。既然我们知道当前绘图点，那么我们可以计算点和左伺服中心之间的距离。因为我们知道下臂的长度（红色）和上臂（蓝色）让这个问题变得知道三边的长度和计算出三个内角，内角之后就可以计算出双手的关节位置。最后我们绘制在图形的所有元素。一个100ms定时器是用来显示动画。功能和程序描述 1、在图形面板，青色和蓝色矩形表示伺服； 2、橙色派是移动范围较低的机械臂（红色），如果两个机械臂相撞则需要检查； 3、红色和蓝色的节段是较低和上部的机械臂； 4、“自动”复选框启用/禁用动画； 5、拖动滚动条来调整每个参数； 6、“面积计算”按钮显示绘图区点的样式； 7、“测试”按钮显示“012”绘图数的结果。实验和结果最重要的参数：各臂长（L1R1，L2R2）和两舵机的距离。所以我们会调整一个参数保持不变，看这两个参数发生了什么变化。该区域是由5度的伺服控制和点的密度成正比的精度。理想参数将有一个均匀分布的点和大的可用的绘图区。调整D（两伺服的距离）比较下面的图表中我们可以看到，D增长的区域实际上被挤到了中心，最后消失的距离大于机械臂的总和。第一个配置是失败的因为两舵机碰撞在一起，虽然有一个精彩的点的分布。第二个有一个很好的分配和两个大的绘图区域，但是有点还是点在了“伞”下面，意味着一些输入可能会导致意想不到的位置和碰撞，所以输入角度应仔细检查。至于测试数，则第二个有最好的结果，所有的数字都会变形，最后不能得出数字。所以我们可以说，应该尽可能小。调整L1R1（下臂）比较下面的数字可以看出，下臂增长绘图区域也会增加，但精度下降。所以这是一个平衡，如果你想要更高的精度，走很短的下臂，如果你想要更大的绘图区域，则选择更长的下臂。值得注意的是，在过去的两个配置，其实有一些地区在“保护伞”不能被吸引，这实际上降低了有效绘图区域。这是因为上面的手臂太短了，所以上臂和下臂的长度应该与它们相配！（他们是兄弟，不要留下任何一个）。第一个数字有一点，它与第二和第三个比它有着良好的性能，但它最后两个数字是完全扭曲的。调整L2R2（上臂）比较下面的数字可以看出，在绘图区域的增长和移向上的增加，这是直的，因为上手臂太长，在较低的区域，点分布变得更好。有一个问题是在程序中没有显示面板。因此，较长的上半臂需要更大的面板，而面板的下部则是被浪费的。结论对于那些自己想要设计时钟绘制机械手的童鞋们应牢记这几点（仅供参考，由于程序的错误，可能不正确）。这些技巧都是建立结构的一些优化，但是优化后它是否符合你们的设计要求，那就依靠个人的设计要求来定。 1、伺服系统之间的距离应该是最小的； 2、较长的较低的手臂，面积较大，但精度较低，反之亦然； 3、较长的上臂区域较高，但已略有改善； 4、下臂和上臂的长度应与试验误差相匹配。更新我已将SolidWorks源文件上传至我的微小网主页。]]></content>
      <tags>
        <tag>机械手</tag>
        <tag>控制程序</tag>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始设计一台CNC机床【上】]]></title>
    <url>%2F2015%2F01%2F08%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%8F%B0CNC%E6%9C%BA%E5%BA%8A%E3%80%90%E4%B8%8A%E3%80%91%2F</url>
    <content type="text"><![CDATA[这篇文章将介绍我设计制作的一台数控机床。为什么我要自己设计制作一台数控机床呢？部分的原因是我喜欢DIY，但最主要的原因是，公司想要一台数控机床加工少批量的PCB样品，以及做一些简单的零件。当时我下班后有很多空闲的时间，我就向老板申请了预算，我自己设计制造一台数控机床。我先读了一些机械论坛的帖子，基本掌握了如何设计制作数控机床，然后开始了我的数控世界之旅。 因为我之前没有设计过数控机床，所以第一台机器是相当不成熟的，但从设计制作的过程中我真的获得了很多的经验。所以在下一台机床时我做了很多的改进。最终机器更好用加工质量更高。我最满意的地方就是PCB打印部分。 我先用SolidWorks建立模型。因为我没有太多的预算和工具，所以我的设计思路是让这台机器很容易的加工出来。因此，我用了很多标准件。我将Y轴分开了，没有将所有的轴设计成移动轴，驱动平台是X轴和Z轴。这种设计的优点是：机器更稳定并且加工精度更高。 下面是支架图。两铝型材支柱用来支撑沉重的X轴和Z轴。由于铝型材可以在淘宝购买已经切割好的节省了我很多时间。此外，这些铝型材都是采用标准件，也比较便宜。 正如我前面所说的，我将Y轴分开了。Y轴安装在基座上。另一个关于这些铝型材，槽与M5的螺栓和螺母，所以我可以很容易地把夹子来固定材料后。 下面X轴的设计，因为我只有少量的预算，所以我没有使用铁轨，这20毫米直径的滑杆足够支撑X轴了。 下面是Z轴的设计。它取决于X轴，即图中所示，Z轴的需要支撑的重量小于X轴所以16mm滑杆是足够的。 然后我们可以安装Z轴了。图中的主轴支架实际上是环氧树脂板，因为我想减轻重量和成本，后来被证明是一个错误的选择，在测试了一段时间后，我终于把它换成了铝材支架，在市场上应该有很多的主轴，我建议你选择铝合金的。 在SolidWorks中验证模型后我终于可以开始发出去加工了，可惜我只拍了几张照片。下面我的旧机器的升级换代。 下面是一些其它加工件。 我花了很长的时间，将这些零件组装在一起，终于完成了组装。 让我们用这台机器制造一些东西吧！因为我是主要是为了加工PCB板，所以我加工了一些印刷电路板来测试它的性能，似乎很好用。 它还可以切割亚克力、PVC、铝合金。 最后我还做了其它升级，使它更容易观察到加工对象并进行定位，我做了一个发光二极管环和激光交叉。 更新我已将SolidWorks源文件上传至我的微小网主页。]]></content>
      <tags>
        <tag>CNC</tag>
        <tag>机床</tag>
        <tag>机械设计</tag>
        <tag>数控机床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014年回顾与展望]]></title>
    <url>%2F2015%2F01%2F04%2F2014%E5%B9%B4%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[回顾 在豆瓣书评看到几本评价很高的书，心痒果断买下：《哥德尔、艾舍尔、巴赫 : 集异璧之大成》、《中国式管理》、《王石：大道当然》、《Head First HTML与CSS》、《失控》、《门后的秘密》、《计算流体力学基础及其应用》、《C程序设计语言》、《经济学原理》、《万物简史》、《算法导论》《深入理解计算机系统》、《Product Design》、《设计草图.制图.模型》、《Designing Interactions》、《设计中的设计》、《教父》、《unix编程思想》、《机械设计手册》、《计算机导论》、《Creo 2.0高级应用教程》、《Altium Designer原理图与PCB设计教程》、《AVR单片机自学笔记》、《51单片机C语言教程》、《有限元分析:ANSYS理论与应用》，看完了其中的《王石：大道当然》、《失控》、《51单片机C语言教程》前六章、《计算机科学导论》的前五章，逐渐养成了记学习笔记的习惯。 看着纸质书觉得不是很方便，便在网上找寻电子书的资源，忍痛买了一台Kindle电子书。看完了几期《知乎》的杂志，找到一档不错的技术杂志：《码农》。买了两本电子书。用它看完了《淘宝技术这十年》、《大数据时代》、《结网.改变世界的产品经理》、《猫力乱步》、《7天成为摄影达人》、《致我们终将逝去的青春》、《何以笙箫默》，还看了几篇文章，开阔了的视野。 开始关注脱口秀节目《罗辑思维》，两天时间看完了13年及14年的全集。开始关注《罗辑思维》的微信，并养成了每天早晨听听他的微信语音的习惯，拓展了原有的思维。 追了几部美剧《神探夏洛克》、《纸牌屋》、《行尸走肉》之后，对看剧的要求提高了。 开始经常关注知乎 ，在知乎，我见识了天马行空的零零后，也见识了偏执专注情商低的nerd；见识了油嘴滑舌的怪蜀黍，也见识了回眸一声百媚生的白富美；见识了义愤填膺的中二少年，还见识了早就云淡风轻的行业精英；见识了有时而傲娇时而深刻的大V，当然，更多时候见识到是越来越多的也有些口无遮拦的无良网民。我在这里收获了认同也收获了质疑，对此充满了感谢。 开始关注技术高手的博客，并收录了一些视频学习网站，走上了先看基础视频的讲解，然后再去购买中高级书籍的学习路子。 收录了一些国外的技术论坛，认识到英语学习的重要性，试着去读一些英文文章，并开始积累自己的词汇量，锻炼自己的口语。 公司上半年业务重心还是放在山东电网的大气腐蚀项目，下半年业务拓展到冷库环境监测及激光测距上。对了，11月份出差了，去了一次山东，收获颇多。公司业务快速发展，数据库、网站、市场变得更加庞大化、复杂化。公司项目组变化，由综合部转战公司项目组。 要学习的东西颇多，思考如何高效的办公学习，发现了 番茄工作法，并开始试着规划好自己的时间。8月份租的房子宽带到期了，晚上回去学习没上半年那么勤了，决心15年办个宽带。 在公司大多数时间仍做着平面工作，与小伙伴相比发展较缓，决心试着去一些更大的平台看看。 一年中看了接近200篇博客；然后见识了很多高手，如陈皓、阮一峰、廖雪峰、老赵、张鑫旭、云峰等。 所以，在毕业两年多的时间里，我觉得我个人发展的并不能算得上成功，毕业前的计划都未能实现。“收拾河山重起鼓”，于是给自己制定一个两年计划。 今后两年计划，成为一个合格的工程师，所以15年的计划是： 习惯使用emacs环境，并用它记笔记、写PPT、整理文章…… 研究开源硬件； 研究python语言； creo、机械工艺深入研究； 结构设计整理总结； 单片机、C再研究； 研究Altium Designer，设计一款智能硬件； 研究liunx； golang研究； java及移动端开发研究； 深入架构思想、文案水平学习提升； 深化产品运营思想、深化面向对象思想、深化架构思维； 扩大视野。 新手建议工作态度还是那句老话，一个人进入优秀的团队，再遇到一个好的老大，那简直就是中了彩票一样，不知不觉自己就成长起来了，但是，这种几率却很低，所以多数朋友的工作是不如意的，不如意的原因各种各样，但是我还是认为责任主要在自己，因为没有团队会放弃创造价值的人。你在团队不如意，一定是你自己不努力，如果你努力了仍然不如意，就是你努力的时间不够长，如果你自己真的做的很好了还是不如意的话，我只能建议你离职了，因为经过你如此努力的工作，离职涨个50%完全不是问题，问题是你是不是真的在努力？不懂就问，对前辈尊重，态度良好，要认识到单纯技术好意义不大，产出高、技术好才是王道，开发不但需要技术好，还得情商高，态度好！ 读书方法• 书籍这个事情贵精而不在多，学习要有成果，学习要有效率。请问各位看书后，或者看博客后会留下痕迹吗？如果留不下痕迹，那么多数就给忘了；• 看经典的书切记要细，切记要看懂，看不懂就反复看，最后一定要留下学习成果。 多多实践第三个阶段当然是多多实践了，一定要多多实践，而且必须总结出自己的经验！还要多看别人的案例，研究别人的结构、电路、源码。研究结构、电路、源码，研究的时候要细细的看，看不懂的地方就反复看，慢慢的就全部清晰了。结构、电路、源码看完后，整个技术的水平会看似上升一大截，这个时候再加紧来点经验就妥妥的将某技术入门了。 与高手交流以上几个阶段结束后，就可以去外面看看自己的斤两了，真的做到以上的朋友，基本是面几个有几个了，真正的瓶颈就出现在大公司了。 这个时候又到了另外一个阶段： 深度—细节点 广度—知识面 以细节点来说，真正的高手一个creo函数就可以问的多数人哑口无言 所以，真正的高手对这些把握是很细的，不是全部都会，但不可能全部都不会。所以，深度一定要有，而且是慢慢积累的，有了深度再提高广度，不然你的广度就不值钱。深度完了就是广度，光有深度还不够还得有广度，广度代表业务能力，代表工作水平。优秀的人不只是知识稳固，而且还能推动团队使用新技术，带给团队不一样的感觉。 开源知识点繁杂，绝不止局外人看见的那么点。若是你发现各个大公司想去就去，offer拿到手软了，那么恭喜你，你成为了中级工程师了！然后再怎样我就真不知道了，我的眼界暂时只能到这里了，希望对处于迷茫阶段的同学有所帮助！]]></content>
      <tags>
        <tag>总结</tag>
        <tag>学习</tag>
        <tag>工作</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工业机器人常用精密减速器技术分析]]></title>
    <url>%2F2014%2F09%2F12%2F%E5%B7%A5%E4%B8%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B8%B8%E7%94%A8%E7%B2%BE%E5%AF%86%E5%87%8F%E9%80%9F%E5%99%A8%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[工业机器人是一种装备有记忆装置和末端执行装置的、能够完成各种移动或工艺来代替人类劳动的通用机器。通常在生产中能代替工人做某些单调、频繁和重复的长时间作业，或是危险、恶劣环境下的作业。它能够提升生产的效率和产品的质量，是企业补充和替代劳动力的有效方案。 目前工业机器人发展特点是高速、精确、机身机构紧凑、多自由度和提高刚性，重点领域还要求重载或响应速度快。例如汽车整车生产的电焊机器人负载大部分在150-300Kg间，而电子领域的装配机器人则需要快速的响应流水线上的配件。 减速器在机械传动领域是连接动力源和执行机构之间的中间装置，通常它把电动机、内燃机等高速运转的动力通过输入轴上的小齿轮啮合输出轴上的大齿轮来达到减速的目的，并传递更大的转矩。目前成熟并标准化的减速器有：圆柱齿轮减速器、涡轮减速器、行星减速器、行星齿轮减速器、RV减速器、摆线针轮减速器和谐波减速器(80-90年代以来，在新兴产业如航空航天、机器人和医疗器械等发展的需求下，需要结构简单紧凑、传递功率大、噪声低、传动平稳的高性能精密减速器，其中RV减速器和谐波减速器是精密减速器中重要的两种减速器。 RV（Rot-Vector）减速器RV减速器是在摆线针轮传动基础上发展起来的，具有二级减速和中心圆盘支承结构。自1986年投入市场以来，因其传动比大、传动效率高、运动精度高、回差小、低振动、刚性大和高可靠性等优点是机器人的“御用”减速器。 谐波减速器谐波减速器由三部分组成：谐波发生器、柔性论和刚轮，其工作原理是由谐波发生器使柔轮产生可控的弹性变形，靠柔轮与刚轮啮合来传递动力，并达到减速的目的；按照波发生器的不同有凸轮式、滚轮式和偏心盘式。谐波减速器传动比大、外形轮廓小、零件数目少且传动效率高。单机传动比可达到50-4000，而传动效率高达92%-96%。 行星减速器行星顾名思义行星减速器就是有三个行星轮围绕一个太阳轮旋转的减速器。行星减速器体积小、重量轻，承载能力高，使用寿命长、运转平稳，噪声低。具有功率分流、多齿啮合独用的特性；是一种用途广泛的工业产品，其性能可与其它军品级行星减速器产品相媲美，却有着工业级产品的价格，被应用于广泛的工业场合。 精密减速器在工业机器人上的作用 工业机器人的动力源一般为交流伺服电机，因为由脉冲信号驱动，其伺服电机本身就可以实现调速，为什么工业机器人还需要减速器呢？工业机器人通常执行重复的动作，以完成相同的工序；为保证工业机器人在生产中能够可靠地完成工序任务，并确保工艺质量，对工业机器人的定位精度和重复定位精度要求很高。因此，提高和确保工业机器人的精度就需要采用RV减速器或谐波减速器。精密减速器在工业机器人中的另一作用是传递更大的扭矩。当负载较大时，一味提高伺服电机的功率是很不划算的，可以在适宜的速度范围内通过减速器来提高输出扭矩。此外，伺服电机在低频运转下容易发热和出现低频振动，对于长时间和周期性工作的工业机器人这都不利于确保其精确、可靠地运行。 精密减速器的存在使伺服电机在一个合适的速度下运转，并精确地将转速降到工业机器人各部位需要的速度，提高机械体刚性的同时输出更大的力矩。与通用减速器相比，机器人关节减速器要求具有传动链短、体积小、功率大、质量轻和易于控制等特点。大量应用在关节型机器人上的减速器主要有两类：RV减速器和谐波减速器。 相比于谐波减速器，RV减速器具有更高的刚度和回转精度。因此在关节型机器人中，一般将RV减速器放置在机座、大臂、肩部等重负载的位置；而将谐波减速器放置在小臂、腕部或手部；行星减速器一般用在直角坐标机器人上。 减速机的市场现状目前应用于机器人领域的减速机主要有两种，一种是RV减速器，另一种是谐波减速器。在关节型机器人中，由于RV减速器具有更高的刚度和回转精度，一般将RV减速器放置在机座、大臂、肩部等重负载的位置，而将谐波减速器放置在小臂、腕部或手部。对于高精度机器人减速器，日本具备绝对领先优势，目前全球机器人行业75%的精密减速机被日本的Nabtesco和HarmonicDrive两家垄断（业界俗称RV减速机和谐波减速机），包括ABB、FANUC、KUKA等国际主流机器人厂商的减速器均由上述两家公司提供。其中HarmonicDrive在工业机器人关节领域拥有15%的市场占有率。 据行业人士介绍，一台精密减速器四大国际巨头采购价为3万元~5万元，卖给国内关系好的客户约7万元，关系一般的普通客户约12万元，内资企业采购精密减速机的成本比国际巨头贵一倍还多，可见其间的利润差别有多大。 2013年全球工业关节类机器人减速器的出货量为73万台，同比增长6%。目前全球精密减速器市场基本上被日本的纳博特斯克和德国的Harmonicadrive所垄断。据上海机电的公告，日本的纳博特斯克2012年销售收入约30亿、全球市场份额稳居60%。 值得一提的是，日本纳博特斯克公司从1980年代初提出RV型设计到1986年RV减速器研究获得实质性突破，花了6-7年时间；而国内率先出结果的南通振康和恒丰泰花费时间也为6-8年；可以看出，技术是没有捷径可走的。换句话说，国内RV减速器现在的发展水平还停留在日本八十年代后期。据行业内不具名人士透露，ABB、发那科、安川、库卡等国际主流机器人整机厂商均由以上两家日本公司提供减速机，并且与两家公司有着非常苛刻的合作条件，即在使用这两家公司产品时不能再使用别家的产品，否则将解除合作关系。 南通振康去年的年产量是200多台，产品已被多家机器人厂商试用，包括国外的ABB、KUKA、发那科以及国内的埃夫特、埃斯顿等企业等。其中，埃夫特已经通过试用后购买了几百台RV减速器产品。核心零部件一直限制这中国机器人的快速发展，因此早日实现加速器的国产化至关重要。]]></content>
      <tags>
        <tag>减速机</tag>
        <tag>工业机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工业机器人的设计思路]]></title>
    <url>%2F2014%2F06%2F07%2F%E5%B7%A5%E4%B8%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文主要梳理一下工业机器人，主要是六轴机械手的设计思路。 了解设计需求：对于工业机器人的设计与大多数机械设计过程相同；首先要知道为什么要设计机器人？机器人能实现哪些功能？活动空间（有效工作范围）有多大？了解基本的需求后，接下来的工作就好做了。 首先是根据基本要求确定机器人的种类，是行走的提升（举升）机械臂、还是三轴坐标机器人、还是六轴机器人等。选定了机器人的种类也就确定了控制方式，也就有了在有限的空间内进行设计的指导方向。 接下来的要做的就是设计任务的确定。这是一个相对复杂的过程： 第一步是将设计要求明确的规定下来； 第二步是按照设计要求制作机械传动简图，分析简图，制定动作流程表（图），初步确定传动功率、控制流程和方式； 第三步是明确设计内容，设计步骤、攻克点、设计计算书、草图绘制，材料、加工工艺、控制程序、电路图绘制； 第四步是综合审核各方面的内容，确认生产。 下面我将以六轴工业机器人作为设计对象来阐明这一设计过程。在介绍机器人设计之前我先说一下机器人的应用领域。机器人的应用领域可以说是非常广泛的，在自动化生产线上的就有很多例子，如垛码机器人、包装机器人、转线机器人；在焊接方面也有很例子，如汽车生产线上的焊接机器人等等；现在机器人的发展是非常的迅速，机器人的应用也在民用企业的各个行业得以延伸。机器人的设计人才需求也越来越大。 六轴机器人的应用范筹不同，设计形式也各不相同。现在世界上生产机器人的公司也很多，结构各有特色。在中国应用最多的如：ABB、Panasonic、FANUK、莫托曼等国外进口的机器人。 即然机器人的应用那么广泛，在我国却没有知名的生产公司。对于作为中国机械工程技术人员来说是一个值得思考的问题！有关机器人技术方面探讨太少了？从业人员还不能成群体？虽然在很多地方可以看到机器的论术，可是却没有真正形成普及的东西。 六轴机器人是多关节、多自由度的机器人，动作多，变化灵活；是一种柔性技术较高的工业机器人，应用面也最广泛。那么怎样去从头开始的设计它呢？工作范围又怎样去确定？动作怎样去编排呢？位姿怎样去控制呢？各部位的关节又是有怎么样的要求呢？等等…让我们带着众多的疑问慢慢的往下走吧！ 首先我们设定：机器人是六轴多自由度的机器人，手爪夹持二氧气体保护焊标准焊枪；完成点焊、连续焊等不同要求的焊接部件，工艺要求、工艺路线变化快的自动生线上。最大伸长量：1700mm；转动270度；底座与地平线水平固定；全电机驱动。 好了，有了这样的基本要求我们就可以做初步的方案的思考了。 方案思考首先是全电机驱动的，那么我们在考虑方案的时候就不要去考虑液压和气压的各种结构了，也就是传动机构只能用齿轮齿条、连杆机构等机械机构了。 机器人是用于焊接方面的，那么我们就去考察有人工行为下的各种焊接手法和方法。这里就有一个很复杂的东西在里面，那就是焊接工艺；即然焊艺定不下来，我们就给它区分一下，在常用焊接里有单点点焊、连续断点点焊、连续平缝焊接、填角焊接、立缝焊接、仰焊、环缝焊等等… 搞清了各种焊方法，也就明白了要实现这些复杂的动作就要有一套可行的控制方式才行；在机械没有完全设计出来之前可以不做太多的控制方案思考，有一个大概的轮廓概念就行了，待机械结构做完，各方面的驱动功率确定下来之后再做详细的程序。 焊枪是用常用的标准的焊枪，也就是说焊枪是随时可以更换下来的，也就要求我们要做到对焊枪的夹持部分进行快速锁定与松开。在焊接过程中焊枪要进行各种焊接姿态调整，那么机械手腕就要很灵活，在各个方位角度上都可调节。 有了上面的基本要求和设定条件，方案推理也有了条理，接下来我们就把设计要求明确下来，设计方向就不会有太大的偏离了。 设计任务／要求机器人适用于焊接领域，可以完成各种焊接动作；为了机器人能适应各种焊接工艺，在线调整工艺快速，编制控制程序时采用柔性控制程序，自适应在线、离线示教程序；焊缝、焊池、焊道成像跟踪，自动调节焊机的各项参数。 机器人采用全伺服驱动，地面固定安装。六轴控制，各关节运动灵活，按工艺描述表设计各轴动作范围，尽量使机构紧凑，整体外形美观。 工艺描述 六轴动作顺序 动作范围 速度范围 定位精度 驱动功率 电器元件 1轴（回旋） 360度 0.75Kw 2轴（大臂俯仰） 160度 1.5KwX2台 3轴（前臂俯仰） 210度 0.5Kw 4轴（小臂旋转） 270度 0.35Kw 5轴（手腕俯仰） 150度 300Kw 6轴（手腕旋转） 360度 200w 设计内容机械设计：根据设计要求及工艺描述设计各关节的机械机构，确定各部件的材料和加工工艺；制作计算书，验算机械强度、驱动功率和给出最大抓（举）重量，各运动路径的惯量计算，位姿的控制计算。验算机器人各关键部件使用寿命。结合控制程序及电路制作机器人维修保养说明书。 程序控制设计：根据设计要求与机械工程师最后制定的工艺路线设计控制流程；结合机械结构与驱动、信号反馈方式，设计机器人运动程序；程序要具有自适应功能，自动定点跟踪，对焊机电流、电压实时监测，并自动调节；焊道、焊池用成像监测判别技术。设计电路图 有了这样一个文件，我们就好设计了；那么我们首先就要做的是：绘制机器人动运简图，规划机器人运动轨迹，做好这些我们就可以进行机械机构的设计，同时可以考虑程序的线路图了。 先做一个简图，来研究一下运动规迹。 下面我给出的机器人的简图，可能大家在很多书上都有见到过，只不过有少许变化而已，没有什么不同的地方。 当我们把机械运动简图画好后，一般的情况下是先对简图进行分析；虽然简图不能全部反映机械结构的组成，但是它却表现出了要设计的物体的总体轮廓。 那么对于我们这个机器人的简图，我们从哪里着手分析才合理呢？ 首先，我们看一下设计任务书的内容。从任务书中知道，六个轴中有三个轴是做旋转运动的，其余作摆角运动。 结合任务书，我们看一下简图，是不是第1轴、第4轴和第6轴是做转动的，也就是说我们要检查一下我们所画的简图是不是与任务书中的要求相符合，符合了也就代表我们的设计思路与要求（客户要求）相同，可以进行下一步工作，如果不同，就得重新画简图。 从简图知道，机器人的手臂伸缩范围较大；如果把手臂全部伸直，而且我们假设地把它们看成同一钢体，这样就形成一端固定的悬臂梁。 应用力学知识体系中的有关梁的分析我们知道，要搞清悬臂梁的变形量，首先要知道梁的重量和截面惯量。 由简图知道，由于有多个关节连接，要知道截面形状和惯量不太容易，只有把所有的机构都设计完成后才会知道想求的参数。 由简图看出，第二轴担负着手臂的上下运动，而且手臂又比较长，在运动的过程中必然存在着惯性冲量，也就是说，当大臂的运动速度很慢时，惯性就很小；如果速度加快，惯性就加大，这个惯性冲量是与速度有着线性关系；怎样保持一定的速度，又不让惯性随着变化呢？大家都知道，增加阻尼，可有效消除这种关系。这样，大家就可以理解简图上两个弹簧的用意了。 即然是这样，那我们就从手腕开始设计。也说是大家所说的从上到下的设计方法。 设计手腕要考虑哪些问题呢？可以知道的是有一把焊枪，焊枪的重量不是很重，同时要有夹持焊枪的手爪。也就是说手腕在转动时的负载是不大的，选择驱动功率不大的元件就行了。 要让手腕在360度范围内转动，而且后面紧跟着又有一个上下摆动的关节；手腕又是在机器人手臂的最前端，当然总体质量不能太重。用什么样的机构最好呢？下面我们考虑几个方案： 如简图所示，采用行星齿轮传动。电机驱动太阳轮，行星轮绕太阳轮转动，内齿轮经行星轮减速与太阳轮反向运动，电机与太阳轮同轴安装。 多级齿轮减速传，电机安装于手腕一侧。 摆线针轮减速传动，电机与偏心轴同轴安装。 蜗轮蜗杆减速传动，电机有两种安装方式；一种与输出轴成90度安装，另一种与输出轴同轴线反向错位安装。 如上所述，还有很多种方式方法，到底选哪一种最好呢？这样我们就要做比较了。从上面的方案里看，第2种方法是不行的；第4种方法如果采用，手腕的结构就会很大，不利于机器人在运动时做精密定位。这样我们去除了两种方法，我们再比较一下第1种和第3种方法： 行星齿轮传动，传动比大，结构复杂，齿轮副配合有间隙，不能自锁。如果采用就得提高齿轮精度，由于是精密传动，齿轮材料也不能按常规齿轮选用材料，加工工艺相对常规齿轮相复杂的多。摆线针轮传动，传动比大，结构复杂，传动间隙小，可以自锁。如果采用，手腕的尺寸不会太小，并且零件加工困难，精度不易保证。 比较各方面后，决定采用行星齿轮传动机械结构。行星齿轮在传动的过程中有装配间隙和机械磨损所造成的间隙；要消除这些机械间隙首先就要让齿轮副的配合间隙要小，齿轮材料经热处理后表面要耐磨，因此行星齿轮副的设计计算不能按常规行星齿轮的设计方法去计算。机器人的手腕是很灵活的关节，而且是要做正反两个方向的回转。怎么样安装电机是一个问题；行星齿轮传动机构与手腕俯仰关节连接是一个问题。 还有，手腕的运动速可能是非等速的；怎么样去控制电机？又怎么样去采集反馈信号？发出的控制信号到执行单元的过程中有没外部干扰？它来自哪里？ 再有，就是手腕在运动过程中的精度；手腕在空间做相对运动，怎样去实现运动精度？影响运动精度的因素有哪些？ 在设计手腕这前一定要搞清楚影响手腕的各方面的因素及内容，问题得到解答后再真正开始手腕的设计。 下面给出伺服电机的的技术参数：型号： MSMD04ZS1V额定输出功率：400W额定转矩：1.3 N.m 最大转矩：3.8 N.m额定转速/最高转速：3000/5000 rpm电机惯量（有制动器）：1.7×10-4Kg.m2变压器容量：0.9 KVA编码器：17位（分辨率：131072）. 7线制增量式/绝对式适配驱动器型号：MBDDT2210 位置控制接线图: 17位增量式/绝对式编码器接线图: 即然我们选用了行星齿轮传动，那么我们就要进行行星齿轮的相关计算。 首先选定模数，由于机器人手腕部分结构要求尽量的小，输出的转矩也相应不是很大，但是，它却会在正反两个方向上存在着高速换向的可能，也就是说在换向时齿轮要克服很大的惯性力，因此，模数的选择计算要按输出转矩的数倍来计算，也就是说：在按强度计算模数时，安全系数选大些。同时由于结构的限制，尽量选用小模数。有关齿轮的计算公式大家可以查阅《齿轮设计手册》。这里我选用模数为：1m 选定了模数，下面就要计算传动比，有关行星齿轮传动的计算大家可查阅《齿轮设计手册》或《机械设计手册》内的《齿轮传动部分》，里面有详细的介绍和计算范例。在此不作介绍和引用。 行星齿轮传动，必定有一个结构是浮动的，在机器人手腕部分是不是也适用呢？哪一部分做输了出？哪一部分浮动？ 首先，机器人手腕做360度转动，结构又比较小，再者就是它的输出部分是要有一个法兰，用来安装夹持执行部件的。 如果让行星架浮动，行星齿轮分布在太阳轮圆周上，让它浮动时，在运转过程中它不是绕定轴转动，也就是说它不满足输出法兰的转动条件。 现在我们考虑一下让内齿转动，法兰固定在内齿轮上，这样就可以保证法兰的转动条件。 下面给出手腕的结构图，无浮动部件，内齿轮转动。]]></content>
      <tags>
        <tag>工业机器人</tag>
        <tag>设计</tag>
        <tag>控制硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[螺杆驱动的六足机器人设计]]></title>
    <url>%2F2014%2F04%2F08%2F%E8%9E%BA%E6%9D%86%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%85%AD%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[这是一个六足机器人的项目，主要是我去年为了学习Solidworks的做的模拟练习。我先做了手工的腿部结构来验证我的想法，但它还是太复杂了。所以后来我还是选择用SolidWorks来模拟腿部的仿真。其实六足也不算一个新鲜的项目了，网上的六足项目也是多如牛毛，不过千篇一律，似乎缺乏了点创新。 最终该项目还是被放弃，但我还是决定将它张贴出来，也许有人对这样一个螺旋驱动机制的六足机器人有兴趣，也许看了我的这篇文章可以对他的项目做一些小的贡献。 这个项目的灵感来源于前段时间做的雕刻机，雕刻机其实就是把步进电机的旋转运动通过丝杆转换成直线运动，以此控制刀具和工件的移动，之后一直想把这种结构运用到什么地方去，于是乎就产生了这么一个项目。 上面的效果图仅仅是个原型，用于分析结构。最终的效果可能会有差别这个设计完全抛弃了舵机，采用空心杯伸缩杆+减速电机的方案来作为机器人的动力，不过原理还是和舵机相同，电机+减速+角度反馈。 首先，先分析一下舵机方案和螺杆驱动方案的优劣：舵机方案：舵机一体化程度高，使用简单，应用也成熟，配合舵机控制器使用非常方便。但是舵机形状比较单一，体积也比较大，速度比较慢，响应频率也低，控制频率50Hz。 螺杆驱动方案：螺杆减速驱动的方案在电机的选择方面就比较灵活，可以根据不同的情况选择不同型号的电机。响应频率高，最简单的PWM+AD就能控制电机运动，其实相当于将舵机拆开来使用。当然，螺杆方案最大的优点，就是它具有自锁功能，不用像普通模拟舵机那样要持续不断的发送角度信号，消耗的能量更少。 用螺杆驱动，会面临这么几个问题：1、选择合适的电机，电机要满足转速、转矩、重量、体积、电压、电流等要求；2、要重新设计电机角度反馈电路和控制电路、控制程序。 关于机械结构：分析了一整天机械结构，话说用这种结构的机器人非常非常少见。搜遍整个网络只发现立陶宛一个老兄用过，再一看日期，那也是3年前的了，并且之后一直没有更新（估计没成功）。那位立陶宛老兄的地址。很纳闷他为啥3年不更新了？ 做一个六足机器人，最重要的就是腿部的设计，腿部设计的重点，就是电机的选择，如电机的力矩、转速、电流等参数，所以我们就先拿一条腿开始分析： 上面两幅图展示了腿中部的运动情况，即：螺杆运动一个总行程L，机器人重心变化H，据此可以求出电机的参数。 条件：机器人自重500g，负重500g，总共1kg；电池8.4v航模锂电池；所用螺杆φ5mm，螺距p=1mm。 假设运动过程中腿角度随螺杆均匀变化，拉力不变，忽略各种摩擦力根据公式MgH=TN×2π此公式的含义：物体上升一段距离H所需的能量=电机旋转N圈做的功M=333g（六足运动中3条腿着地，1kg/3=333g)H=76-29=47mmN=电机转过圈数=L/p=20*注意：计算功的一定要将角速度转换成弧度制，rpm×2π/60=rad/sT为所求电机转矩∴T=3.3N×47/1000m/20/6.28=0.00123Nm=12.3gcm12.3gcm就是这个电机所需要的最大额定转矩同理可求得机器人无负载的时候所需的额定转矩=6.17gcm如果希望机器人上升的速度能达到4.7cm/s,那电机的转速要满足 ω=20rps=1200rpm上面的计算忽略了摩擦力，也假定转动过程中所需拉力恒定，实际上拉力方向和腿转动方向所成的角度是变化的，因此要留1倍的余量所以根据上面的参数就能很轻松的选择所需电机：工作电压8.4v，重量10-15g，额定转矩12.3gcm-24.6gcm，额定转速1200rpm。正好，目前淘宝上卖的很火的微型减速电机n20有诸多减速比，完全符合要求。 经过一番折腾确定了腿部中间的那个电机，同理再分析腿下部的电机：可以发现H=22mm，L=9.2mm，比值和上述的电机很接近，省略公式，计算得：额定转矩：12.8-25.7gcm额定转速：1200rpm经过这么一番分析后，可以发现那位老外为什么不成功了，因为他用空心杯电机作为动力（MADE IN CHINA），这也是我一开始的想法，为了减轻重量。直径7mm长度14mm的空心杯参数：电压3.7v，额定电流200ma，额定转速30000rpm，淘宝上大多数的空心杯都没给出转矩，网上搜了半天也很难找到，于是自己粗略算了一下，这种型号的空心杯转矩应该是1.2gcm，是不是小的可怜？ 另外，我猜测，烂大街的辉盛9g舵机里的电机和烂大街的n20减速电机所用的电机应该是一样的。 总结上面的一段分析，大家在给自己的机器人（不管什么类型的机器人）选择电机的时候，完全可以先用功和能的观点简单判断一款电机符不符合要求。最简单的办法，就拿上面的例子来说，某款n20，9v，负载电流60ma，负载力矩22gcm，负载转速890rpm：机器人所需功率&lt;电机输出功率&lt;电机总功率机器人所需功率：P=W/t=（mgH+1/2mv2)/1=[0.33×10×47/1000+0.5×0.33×(47/1000)2]/1=0.156W电机总功率： P=9×0.06=0.54W直流有刷电机效率一般比较低，就算50%吧0.54W×50%=0.27W&gt;0.156W粗略一算，这款电机符合要求！再算一下它的输出功率：电机输出功率：P=T×ω=22×890×2π/60×0.0000981=0.2W (一定要带上单位，W对应Nm，gcm要转换成Nm）0.2W也大于0.15W，实际效率37%。假如我们用的是空心杯，那它的总功率：P=3.7v*0.2a=0.74W，假设输出效率50%，则P=0.37w，理论计算出来用空心杯也是可行的，不过要经过减速，而且同等体积的空心杯力矩会比铁心的差。附上链接：MTU的一篇关于电机的详细文章力矩转换表 *注意：上面的分析方法、计算结果可能有错误，欢迎指正！ 以上的分析忽略了加速度，最后的结果导致偏小，由于模型比较复杂，所以改为solidworks进行运动分析。 关于硬件：硬件方面，最主要解决的问题，就是角度反馈和电机驱动。角度反馈计划采用AD读取电位器阻值变化，这也是大多数舵机里的角度反馈元件。 电机驱动再讨论，因为电机电流很小，60ma~200ma，考虑三极管H桥或者ULN2003？再采用mega8或168作为MCU，通过串口或ISP或其他方式接收命令，统一接口兼容控制其他舵机六足的命令。电机转动的精度取决于电位器的质量和AD的精度。电机转动的速度取决于电流大小，以及AD读取速度、程序处理速度。 关于控制程序：这里控制程序可以分为上位机和下位机来讨论，由于硬件接口和普通舵机控制器相同，所以其他舵机控制上位机应该能很好的修改移植。先说说下位机程序：下位机接受的命令看起来可以是这样子：#C1P60C2P90，解释起来就是1号电机转到60°，2号电机转到90°。至于驱动电机的算法，可以采用分段PID，先实现最基本的，再改进，如加上脚底触碰开关，加上陀螺仪和加速度传感器进行姿态反馈。 所以我觉得这个六足机器人主要的设计难点在于控制系统中的腿部的设计。它涉及到的电动机的转矩和速度，丝杠选择和线性反馈电位计算。 下面我再贴一些关于这个机器人的图片。 这里还有一个结构类似的六足机器人的设计。他用的是6V 700〜1000rpm的马达来驱动腿。他把伺服电机拆了下来，用印刷电路板和电位器来驱动电机，并进行反馈控制，从而节约了大量设计电机驱动系统的工作。 更新我已将SolidWorks源文件上传至我的微小网主页。]]></content>
      <tags>
        <tag>Arduino</tag>
        <tag>机器人</tag>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈国内机器人系统集成]]></title>
    <url>%2F2014%2F03%2F27%2F%E6%B5%85%E8%B0%88%E5%9B%BD%E5%86%85%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[系统集成是机器人应用的必经环节。打个比方(不是你那个叫“比方”的朋友)，机器人就好比门，你装修买门，装门的环节不可缺少。同样，你要应用机器人，部署机器人(即系统集成)是必不可少的。我所理解的系统集成的持续价值在于对应用行业工艺的理解。如杜尔作为全球最成功的喷涂机器人系统集成商，就是一个很好的例子。如果对每个行业都只是浅尝辄止地做系统集成，那么对工艺的理解就不能聚焦，就会流于表面。刚参加工作的机器人工程师或许会遇到瓶颈，我理解可能是对其真正价值的怀疑。 我认为，不管是系统集成还是非标，都需要聚焦才能成就其真正的价值。当前，国内系统集成市场往往让技术人员对各行各业眉毛胡子一把抓，让人怀疑岗位价值并心生去意也在所难免。]]></content>
      <tags>
        <tag>机器人系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解伺服电机选型中的惯量匹配]]></title>
    <url>%2F2014%2F02%2F17%2F%E8%AF%A6%E8%A7%A3%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BA%E9%80%89%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%83%AF%E9%87%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[本文主要探讨伺服系统中的惯量匹配。在伺服系统选型及调试中，常会碰到惯量问题。其具体表现为：在伺服系统选型时，除考虑电机的扭矩和额定速度等等因素外，我们还需要先计算得知机械系统换算到电机轴的惯量，再根据机械的实际动作要求及加工件质量要求来具体选择具有合适惯量大小的电机；在调试时，正确设定惯量比参数是充分发挥机械及伺服系统最佳效能的前提。此点在要求高速高精度的系统上表现尤为突出，这样，就有了惯量匹配的问题。 一、什么是“惯量匹配”？ 1、根据牛顿第二定律：“进给系统所需力矩T = 系统传动惯量J × 角加速度θ角”。 加速度θ影响系统的动态特性，θ越小，则由控制器发出指令到系统执行完毕的时间越长，系统反应越慢。如果θ变化，则系统反应将忽快忽慢，影响加工精度。由于马达选定后最大输出T值不变，如果希望θ的变化小，则J应该尽量小。 2、进给轴的总惯量“J＝伺服电机的旋转惯性动量JM ＋ 电机轴换算的负载惯性动量JL。负载惯量JL由（以平面金切机床为例）工作台及上面装的夹具和工件、螺杆、联轴器等直线和旋转运动件的惯量折合到马达轴上的惯量组成。 JM为伺服电机转子惯量，伺服电机选定后，此值就为定值，而JL则随工件等负载改变而变化。如果希望J变化率小些，则最好使JL所占比例小些。这就是通俗意义上的“惯量匹配”。 二、“惯量匹配”如何确定？ 传动惯量对伺服系统的精度，稳定性，动态响应都有影响。 惯量大，系统的机械常数大，响应慢，会使系统的固有频率下降，容易产生谐振，因而限制了伺服带宽，影响了伺服精度和响应速度，惯量的适当增大只有在改善低速爬行时有利，因此，机械设计时在不影响系统刚度的条件下，应尽量减小惯量。 衡量机械系统的动态特性时，惯量越小，系统的动态特性反应越好；惯量越大，马达的负载也就越大，越难控制，但机械系统的惯量需和马达惯量相匹配才行。 不同的机构，对惯量匹配原则有不同的选择，且有不同的作用表现。 不同的机构动作及加工质量要求对JL与JM大小关系有不同的要求，但大多要求JL与JM的比值小于十以内。一句话，惯性匹配的确定需要根据机械的工艺特点及加工质量要求来确定。 对于基础金属切削机床，对于伺服电机来说，一般负载惯量建议应小于电机惯量的5倍。 惯量匹配对于电机选型很重要的，同样功率的电机，有些品牌有分轻惯量，中惯量，或大惯量。其实负载惯量最好还是用公式计算出来。常见的形体惯量计算公式在以前学的书里都有现成的（可以去查机械设计手册）。 我们曾经做过一试验，在一伺服电机的轴伸，加一大的惯量盘准备用来做测试，结果是：伺服电机低速时停不住，摇头摆尾，不停地振荡怎么也停不下来。 后来改为：在两个伺服电机的轴伸对接加装联轴器，对其中一个伺服电机通电，作为动力即主动，另一个伺服电机作为从动，即做为一个小负载。原来那个摇头摆尾的伺服电机，启动、运动、停止，运转一切正常！ 三、惯量的理论计算的功式？ 惯量计算都有公式，至于多重负载，比如齿轮又带齿轮，或涡轮蜗杆传动，只要分别算出各转动件惯量然后相加即是系统惯量，电机选型时建议根椐不同的电机进行选配。 负载的转动惯量肯定是要设计时通过计算算出来拉，如果没有这个值，电机选型肯定是不那么合理的，或者肯定会有问题的，这是选伺服的最重要的几个参数之一。至于电机惯量，电机样本手册上都有标注。 当然，对某些伺服，可以通过调整伺服的过程测出负载的惯量，作为理论设计中的计算的参考。毕竟在设计阶段，很多类似摩擦系数之类的参数只能根据经验来猜，不可能准确。 理论设计中的计算的公式：（仅供参考） 通常将转动惯量J用飞轮矩GD2来表示，它们之间的关系为 12345J=mp^2= GD^2/4g式中 m与G－转动部分的质量（kg）与重量（N）；与D－惯性半径与直径（m）；g=9.81m/s2 －重力加速度飞轮惯量=速度变化率*飞轮距/375 当然，理论与实际总会有偏差的，有些地区（如在欧洲），一般是采用中间值通过实际测试得到。这样，相对我们的经验公式要准确一些。不过，在目前还是需要计算的，也有固定公式可以去查机械设计手册的。 四、关于摩擦系数？ 关于摩擦系数，一般电机选择只是考虑一个系数加到计算过程中，在电机调整时通常都不会考虑。不过，如果这个因素很大，或者讲，足以影响电机调整，有些日系通用伺服，据称有一个参数是用来专门测试的，至于是否好用，本人没有用过，估计应该是好用的。 有网友发贴说，曾有人发生过这样的情况：设计时照搬国外的机器，机械部分号称一样，电机功率放大了50%选型，可是电机转不动。因为样机的机械加工、装配的精度太差，负载惯量是差不多，可摩擦阻力相差太多了，对具体工况考虑不周。 当然，黏性阻尼和摩擦系数不是同一个问题。 摩擦系数是不变值，这点可以通过电机功率给予补偿，但黏性阻尼是变值，通过增大电机功率当然可以缓解，但其实是不合理的。况且没有设计依据，这个最好是在机械状态上解决，没有好的机械状态，伺服调整完全是一句空话。 还有，黏性阻尼跟机械结构设计、加工、装配等相关，这些在选型时是必须考虑的。而且跟摩擦系数也是息息相关的，正是因为加工水平不够才造成的摩擦系数不定，不同点相差较大，甚至技术工人装配水平的差异也会导致很大的差异，这些在电机选型时必须要考虑的。这样，才会有保险系数，当然归根结底还是电机功率的问题。 五、惯量的理论计算后，微调修正的简单化 可能有些朋友觉的：太复杂了！ 实际情况是，某品牌的产品各种各样的参数已经确定，在满足功率，转矩，转速的条件下，产品型号已经确定，如果惯量仍然不能满足，能否将功率提高一档来满足惯量的要求？ 答案是：功率提高可以带动加速度提高的话，应是可以的。 六、伺服电机选型在选择好机械传动方案以后，就必须对伺服电机的型号和大小进行选择和确认。 1.选型条件：一般情况下，选择伺服电机需满足下列情况：马达最大转速＞系统所需之最高移动转速。 马达的转子惯量与负载惯量相匹配。 连续负载工作扭力≤马达额定扭力 马达最大输出扭力＞系统所需最大扭力（加速时扭力） （2）选型计算：惯量匹配计算（JL/JM）回转速度计算（负载端转速，马达端转速）负载扭矩计算（连续负载工作扭矩，加速时扭矩）]]></content>
      <tags>
        <tag>控制硬件</tag>
        <tag>伺服电机</tag>
        <tag>惯量匹配</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工业4.0时代 - 机械工程师的职业规划]]></title>
    <url>%2F2014%2F01%2F02%2F%E5%B7%A5%E4%B8%9A4.0%E6%97%B6%E4%BB%A3%20%E2%80%94%20%E6%9C%BA%E6%A2%B0%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[机械工程师的知识体系：下面这张图告诉你，作为一个合格机械工程师有多难！请注意是“合格”的机械工程师。或许你在工作中没有确切的提到图中的某一项工作，但是做一个行业的设备方案设计，或者做一项应用技术研究，你或多或少的都会考虑到或者用到图中的知识点。 初级机械工程师（绘图员）常见误区：常见误区一：机械只是搞结构，结构只是使用creo、solidworks或者其他什么软件； 常见误区二：机械行业越老越吃香，切勿相信这句心灵鸡汤。越老越吃香是骗人的，这主要看你在什么平台了。一个浮躁的企业，靠山寨生存，什么挣钱干什么，你要在这公司里，干再多年也只是画图狗，画图会把人累死，天天画图改图，天天加班，你连玩儿的心情都木有了，那还有心情学习？不学习，哪能越老越吃香？ 常见误区三：搞机械不需要了解编程知识。编程作为互联网时代工程师的基本技能，也是机械工程师的基础。 机械工程师进阶准备：克服浮躁的心理，搞机械结构的是个漫长痛苦的锻炼过程。 机械工程师进阶之路：萌级小菜鸟1级：会使用AUTOCAD画一些简单的二维图，根据这个图，你能想象产品的三维形态。 萌级小菜鸟2级：你的二维图上能够看到公差，材料，表面处理，工艺技术要求等信息了。而且这些信息是你自己标上去的，你知道他们意味着什么。 萌级小菜鸟3级：你会画二维图了，并且你画的图看上去真的能加工出实物来了，尽管有时候会犯一些错误，例如精度要求高的的连德国人都做不出来，更何况你们车间的王师傅。应领导的要求你能用一些三维软件出个效果图看看，虽然没什么实用价值，至少很有成就感。 入门1级：你已经很清楚你的产品是怎么加工出来的了，而且了解每一道工艺工序的意义何在。如果需要改进，你也大体上能够判断从那里入手，对改进后可能产生的影响，你也能猜到一二。这个时候，你已经对深刻的认识到二维工程图远比三维模型有意义的多。你开始鄙视那些只会用三维软件建一些三维模型的所谓机械工程师。 入门2级：你开始了解什么叫企业信息化。知道了三维设计其实很有用，并且可以把你热爱的工艺信息融入到三维设计中来。这个时候你应该已经能够熟练地应用三维软件设计一些常用的零部件，并且生成足以指导生产的二维工程图，或者直接拿到数控设备上加工出来。 专家1级：你已经能够使用相关设计软件管理生产了，包括设计出图，零部件清单管理（BOM）；你对生产流程已经很清楚，能够识别技术关键点并着力解决；甚至已经开始尝试利用有限元分析进行强度、疲劳等的分析，并且可以轻易的写篇洋洋洒洒的设计文档出来，忽悠菜鸟是不成问题了。而且如果你还没有当上设计主管的话，可能是人际关系上需要再努把力了。 专家2级：你已经隐隐约约的感受到简单而重复的设计出图是在浪费你的时间，因为这些东西你已经烂熟于胸。你更希望有更多的时间去致力于提升产品的整机竞争力，比如如何降成本，如何改进工艺流程，如何提升设计效率。你能够看到你的产品在结构、材料、功能上还有不足，你能够意识到这不是你一个人能改变的，你开始利用周边的技术资源进行系统的考量，制定产品竞争力提升的计划，并列出技术节点去一一攻破。 专家3级：这个时候你已经超越“结构设计”的范畴了。你应该很清楚，你的产品在结构上已经没什么潜力可以挖掘了。但是围绕着结构，你能够关注到整机产品的各个特性需求，在EMC、散热、噪声、安规、环境、人机工程、DFX(DFM可制造性、DFI可安装性、DFA可装配性、DFT可测试性)等等一系列领域都能够灵活渗透应用，全面提升产品的核心竞争力； 大师级：对整个产品的核心竞争力负责，是你的基础工作了。同时，你要了解国内外制造业相关标准规范，知道你的产品要在欧洲或北美销售会面临什么样的门槛，需要提供什么样的认证，你怎样提升你的产品来满足这些需求。你还必须对竞争对手的产品了如指掌，能够一针见血的指出对方的短木板，和你自己产品的优势所在。你了解行业动态，能够预见将来5年甚至十年该产品的发展趋势，并制定长期的发展战略，指导你的手下进行相关的技术积累。 其他能力：一、扎实的理论基础：一般来说，机械（产品、结构）设计设计人员需要有一定的学历背景，我不是说非本科生不可，在这个行业，实践远比学历重要，一定要知道的课程是：几何学、机械设计制图、材料学、公差与配合、机构学，力学。材料学博大精深，连一般的机械设计专业毕业的本科生都很难全面掌握，一般没用过的材料就不太知道了。我认为材料是最重要的，机构是要服务于材料和功能的，而且机构的发明已经到了极限，书店里有上下两册的《机构设计手册》就完全可以应付了，就看你用得好不好，巧不巧。 二、说说能力问题：我们今天要讲到的是学习能力、搜索能力、思维能力、创新能力，一个好的设计人员要不断学习，学习他人的长处，设计行业没有捷径可走，一个软件拿来从不会到会，是一个学习的过程，从能模仿到能干活是要有一段时间的，学习的能力非常重要；同时要勤于思考，书上的教案不一定对。一个软件用熟了，比如Autocad、Creo、SolidWorks、UG、Catia、Rhino、Floefd、ANSYS等等，用它来开发一些新的功能，方便使用，就是创新，创新出来的东西就是你自己的了。 三、建立思维模式：打破旧的观念，然后是建立新的模式。明确为什么要用三维，好玩吗？不是直观吗？都不是，而是为了减少错误，减轻设计的工作量，把问题消灭在初始阶段，Autocad的两维图纸只是一个甩图板的过程，从两维转向三维是个痛苦的过程，老板要花钱，设计人员要下决心，改变设计习惯，在各个三维讨论区里经常可以看到对三维设计的非难，认为没有两维设计快，同时也过于烦琐，有问题我们必须承认。 四、认识美学：现代的工业设计很大程度上依赖美学和工程学的结合，产品也好设备也好，欧美发达国家的设计工艺水平都要高过我们很多，我们国家的工业一般只求实用耐用，但是随着社会的发展和进步，人们对产品的美观程度也有了相当程度的要求，要搞好设计必须从美学和工程学两个方面入手，工程方面在学校里学得很多，实践中也会积累一些，美学就很难了，我有个客户，想要我帮他搞工业造型，我跟他说工业造型没有什么神奇的，造型没做出来之前谁都不知道是什么样子的，谁都没有主意，设计出来以后大家都知道了，都会模仿抄袭；我们国家的一些地方的衣服款式和皮带、箱包样式都是从国外抄袭过来的，我们国家的教育体系是不鼓励发展创造力的，日本人在世界上老是排在第二，过去学中国的大唐文化，后来学德国的法西斯主义，现在学美国的现代资本主义，很难说有什么有影响力的东西是日本人发明的；不要看不起创造，它是一个国家在世界上领先发展的前提条件。 五、了解工艺过程：这个问题也是现在大学生难以解决的一个问题，在实习的时候要多看多学多问，有机会看看大工厂，也要看看小工厂，要想在一两年之内解决这个问题比较困难，但是这是一个累积的过程；要踏踏实实地做。]]></content>
      <tags>
        <tag>学习</tag>
        <tag>机械设计</tag>
        <tag>读书</tag>
        <tag>职业规划</tag>
        <tag>机械工程师</tag>
      </tags>
  </entry>
</search>
